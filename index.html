<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIBE_WEAVERS - A VibeCode Open Playground P2P Colaborative Game Project</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>  
           
        /* ===================================================================== */
        /* == STYLE CONTROL PANEL - MENU & LOBBY                              == */
        /* ===================================================================== */

        /* --- Main Buttons (Single Player, Host, Guest, etc.) --- */
        .menu-main-button {
            background-color: #c000c0;      /* Darker magenta background color */
            color: white;                   /* Font color */
            border: 4px solid white;        /* Border style */
            padding: 15px 40px;             /* Inner spacing (vertical, horizontal) */
            font-size: 24px;                /* Font size */
            font-weight: bold;              /* Makes the font bold */
            border-radius: 50px;            /* Highly rounded corners for a pill shape */
            cursor: pointer;                /* Changes the mouse cursor to a pointer on hover */
            text-transform: uppercase;      /* Makes all text uppercase */
            letter-spacing: 1.5px;          /* Adds space between letters */
            transition: all 0.2s ease-in-out; /* Enables smooth animations for all properties */
            min-width: 300px;               /* Ensures a consistent minimum width */
            text-align: center;             /* Centers the text inside the button */
        }

        .menu-main-button:hover {
            background-color: #ff00ff;      /* Brighter magenta on mouse hover */
            transform: scale(1.05);         /* Creates a subtle zoom effect */
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.7); /* Adds a magenta glow effect */
        }

        /* --- Social Link Styles --- */
        /* Styles for the Social Links on the Splash Screen */
        .social-links-container {
            margin-top: 60px;               /* Grande espaçamento para separar dos botões principais */
            display: flex;                  /* Habilita o layout flexbox */
            flex-direction: column;         /* Organiza os itens verticalmente */
            align-items: center;            /* Centraliza os itens horizontalmente */
            text-align: center;             /* Centraliza o conteúdo de texto */
        }

        .main-channels-row {
            display: flex;                  /* Habilita flexbox, que por padrão organiza em linha (row) */
            justify-content: center;        /* Centraliza os links na linha */
            align-items: center;            /* Alinha os links verticalmente */
            gap: 40px;                      /* CRÍTICO: Cria um espaço de 40px ENTRE os links */
        }

        .social-link {
            display: inline-flex;
            align-items: center;
            color: #c000c0;
            text-decoration: none;
            font-size: 22px;
            font-family: sans-serif;
            font-weight: bold;
            margin-top: 10px;
            text-shadow: 1px 1px 3px rgba(255, 255, 255, 1.0);
            transition: all 0.2s ease-in-out;
            padding: 8px 20px;              /* AJUSTADO: Aumentei o preenchimento para acomodar os ícones maiores */
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.25); /* NOVO: Fundo sombreado agora é permanente */
        }

        .social-link:hover {
            color: #ff00ff;
            background-color: rgba(0, 0, 0, 0.4); /* AJUSTADO: Fundo fica um pouco mais escuro no hover */
            transform: scale(1.05);
            /*text-shadow: 0 0 5px rgba(255, 255, 255, 1.0);8*/
        }

        /* Estilo específico para o ícone dentro do link */
        .social-link i {
            font-size: 32px;                /* AJUSTADO: Ícones significativamente maiores */
            margin-right: 15px;             /* AJUSTADO: Mais espaço entre o ícone e o texto */
        }

        .personal-links {
            margin-top: 20px;               /* Espaço extra entre o link do canal principal e os links pessoais */
            display: flex;                  /* Habilita o layout flexbox */
            flex-direction: column;         /* Organiza os itens verticalmente */
            align-items: center;            /* Centraliza os itens horizontalmente */
        }
  
        
        /* --- Secondary Buttons (Back, etc.) --- */
        .menu-secondary-button {
            background-color: #555;         /* Dark gray background color */
            border-color: #888;             /* Light gray border color */
            margin-top: 50px !important;    /* Spacing above the button (!important overrides other margin-top rules) */
        }

        .menu-secondary-button:hover {
            background-color: #777;         /* Lighter gray on hover */
            box-shadow: 0 0 15px rgba(180, 180, 180, 0.5); /* Subtle white glow */
        }

        /* --- Specific Style for the 'Start Game' Button --- */
        #start-multiplayer-game-btn {
            background-color: #4CAF50;      /* Main green color (a common web standard) */
            border-color: #ffffff;          /* White border */
        }

        #start-multiplayer-game-btn:hover {
            background-color: #00ff00;      /* Brighter green on hover */
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7); /* Adds a green glow effect */
        }

        /* --- General Styles for Lobby/Host/Guest Screens --- */
        .lobby-container {
            /* This is the main container for the lobby screens */
            display: flex;                  /* Enables flexbox layout (NOTE: JS toggles this between 'none' and 'flex') */
            position: absolute;             /* Positions relative to the viewport */
            top: 0;                         /* Aligns to the top edge */
            left: 0;                        /* Aligns to the left edge */
            width: 100%;                    /* Fills the full width */
            height: 100%;                   /* Fills the full height */
            z-index: 999;                   /* Ensures the lobby is on top of other elements */
            flex-direction: column;         /* Stacks items vertically */
            justify-content: center;        /* Centers items vertically */
            align-items: center;            /* Centers items horizontally */
            font-family: sans-serif;        /* Sets the font */
            color: white;                   /* Sets the text color */
            text-align: center;             /* Centers the text */
        }

        .lobby-background {
            /* This controls the background image for the lobby */
            position: absolute;             /* Positions relative to the parent (.lobby-container) */
            top: 0;                         /* Aligns to the top */
            left: 0;                        /* Aligns to the left */
            width: 100%;                    /* Fills the full width */
            height: 100%;                   /* Fills the full height */
            object-fit: cover;              /* Makes the image cover the entire area without distortion */
            z-index: -1;                    /* Places the image behind all other content */
        }

        .lobby-box {
            /* This is the semi-transparent black box that holds the content */
            background-color: rgba(0, 0, 0, 0.7); /* Black background with 70% opacity */
            padding: 30px;                  /* Inner spacing */
            border-radius: 10px;            /* Rounded corners */
            max-width: 500px;               /* Maximum width on large screens */
            width: 90%;                     /* Width on smaller screens */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37); /* Adds a shadow for a depth effect */
        }

        .lobby-title {
            /* This styles the main <h1> titles in the lobby */
            text-shadow: 2px 2px 4px black; /* Adds a shadow to the text */
            margin-bottom: 25px;            /* Adds space below the title */
        }

        .lobby-text {
            /* This styles the paragraph <p> text */
            margin-bottom: 10px;            /* Adds space below the text */
        }

        /* --- Host Screen Specific Styles --- */
        .lobby-id-display {
            /* This styles the Host ID display box */
            font-size: 1.5em;               /* Larger font size */
            color: #00ffff;                 /* Cyan color for high visibility */
            user-select: text;              /* Allows the user to select and copy the text */
            cursor: pointer;                /* Hand cursor to indicate it's clickable (for copying) */
            word-break: break-all;          /* Prevents the long ID from overflowing on small screens */
            padding: 10px;                  /* Inner spacing */
            background-color: rgba(0,0,0,0.3); /* Dark, semi-transparent background */
            border-radius: 5px;             /* Slightly rounded corners */
        }

        .lobby-player-list {
            /* This styles the box that lists connected players */
            min-height: 100px;              /* Minimum height to maintain its shape */
            width: 100%;                    /* Fills the width of its parent (.lobby-box) */
            box-sizing: border-box;         /* Ensures padding is included in the total width */
            background: rgba(0,0,0,0.5);    /* Darker, semi-transparent background */
            border-radius: 5px;             /* Slightly rounded corners */
            padding: 15px;                  /* Inner spacing */
            text-align: left;               /* Aligns player names to the left */
            margin-top: 10px;               /* Space above the list */
        }

        /* --- Guest Screen Specific Styles --- */
        .lobby-input {
            /* This styles the text input field for the Host ID */
            padding: 12px;                  /* Inner spacing */
            font-size: 1.2em;               /* Larger font size */
            text-align: center;             /* Centers the typed text */
            border-radius: 5px;             /* Slightly rounded corners */
            border: 2px solid #ff00ff;      /* Magenta border to match the theme */
            background: #222;               /* Darker background */
            color: white;                   /* White text color */
            width: 100%;                    /* Fills the width of its parent (.lobby-box) */
            box-sizing: border-box;         /* Ensures padding is included in the total width */
        }

        .lobby-status {
            /* This styles the status message (e.g., "Connecting...", "Error") */
            margin-top: 20px;               /* Space above the message */
            min-height: 20px;               /* Minimum height to prevent layout shifts */
            font-weight: bold;              /* Makes the text bold */
        }

        /* ===================================================================== */
        /* == PLAYGROUND & RACE MENU STYLES                                   == */
        /* ===================================================================== */

        /* --- Specific Style for 'Position Portal' Button (Green) --- */
        #positionPortalBtn {
            background-color: #4CAF50;      /* Same green as the 'Start Game' button */
            border-color: #ffffff;          /* White border */
        }

        #positionPortalBtn:hover {
            background-color: #00ff00;      /* Brighter green on hover */
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7); /* Green glow effect */
        }

        /* --- Style for the cleanup button (warning action) --- */
        #cleanupPortalsBtn {
            background-color: #c00000;      /* A darker, sober red for a warning action */
            border-color: #ff8a8a;          /* Light red border */
        }

        #cleanupPortalsBtn:hover {
            background-color: #ff4d4d;      /* A more vivid red on hover */
            transform: scale(1.05);         /* Subtle zoom effect */
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.7); /* Red glow effect */
        }

        /* --- Style for disabled main buttons --- */
        .menu-main-button:disabled {
            background-color: #333;         /* Very dark background */
            color: #777;                     /* Light gray text */
            border-color: #555;             /* Dark gray border */
            cursor: not-allowed;            /* "Not allowed" mouse cursor */
        }

        /* Removes hover effects from disabled buttons to avoid confusion */
        .menu-main-button:disabled:hover {
            transform: none;                /* Disables the zoom effect */
            box-shadow: none;               /* Disables the glow effect */
            background-color: #333;         /* Ensures the color does not change on hover */
        }
        
        /* ===================================================================== */
        /* == GENERAL IN-GAME UI & BODY STYLES                                == */
        /* ===================================================================== */
  
        body {
            margin: 0;                      /* Removes default browser margin */
            overflow: hidden;               /* Prevents scrollbars from appearing */
            background-color: #68aae8;      /* Default light blue background color */
            
            /* The following properties prevent text selection by the user */
            user-select: none;              /* Standard property */
            -webkit-user-select: none;      /* For Chrome, Safari, Opera */
            -moz-user-select: none;         /* For Firefox */
            -ms-user-select: none;          /* For Internet Explorer/Edge */
        }

        /* --- Style for the 2D UI Canvas (Nametags) --- */
        #ui-canvas {
            position: absolute;             /* Allows it to float over other elements */
            top: 0;                         /* Aligns to the top */
            left: 0;                        /* Aligns to the left */
            z-index: 100;                   /* Ensures it's above the 3D game but below menus */
            /* CRITICAL: Makes the canvas "invisible" to the mouse, allowing clicks to pass through to the game underneath. */
            pointer-events: none;
        }

        canvas { 
            display: block;                 /* Removes extra space below the canvas element */
        }

        #instructions {
            position: absolute;             /* Positions relative to the viewport */
            top: 10px;                      /* 10px from the top */
            width: 100%;                    /* Spans the full width */
            text-align: center;             /* Centers the text */
            color: white;                   /* Text color */
            font-family: sans-serif;        /* Standard sans-serif font */
            font-size: 14px;                /* Font size */
            z-index: 100;                   /* Same layer as the UI canvas */
            background-color: rgba(0,0,0,0.5); /* Semi-transparent black background for readability */
            padding: 10px;                  /* Inner spacing */
            display: none;                  /* Starts hidden; controlled by JavaScript */
        }

        #crosshair {
            position: absolute;             /* Positions relative to the viewport */
            top: 50%;                       /* Centers vertically */
            left: 50%;                      /* Centers horizontally */
            width: 10px;                    /* Width of the crosshair */
            height: 10px;                   /* Height of the crosshair */
            border: 1px solid white;        /* A simple white border */
            border-radius: 50%;             /* Makes it a circle */
            transform: translate(-50%, -50%); /* Adjusts position to be perfectly centered */
            z-index: 99;                    /* Sits just below the UI canvas */
            mix-blend-mode: difference;     /* Makes it visible on most background colors */
            display: none;                  /* Hidden until the pointer is locked */
        }

        #hudInfo {
            position: absolute;             /* Positions relative to the viewport */
            bottom: 20px;                   /* 20px from the bottom */
            left: 20px;                     /* 20px from the left */
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
            color: white;                   /* Text color */
            font-family: sans-serif;        /* Font family */
            font-size: 16px;                /* Font size */
            padding: 10px;                  /* Inner spacing */
            border-radius: 5px;             /* Rounded corners */
            z-index: 101;                   /* Sits above instructions and the crosshair */
            text-align: left;               /* Aligns text to the left */
            line-height: 1.4;               /* Increases space between lines of text */
        }
      
        /* --- PODRACER STRAFE VISUALIZER STYLES --- */
        #strafe-visual-container {
            /* Defines the main container for the strafe arrows */
            position: absolute;             /* Positions relative to the viewport */
        }
        .arrow-anchor-strafe {
            /* Defines the anchor points for the left and right arrows */
            position: absolute;             /* Positions relative to the container */
            top: 0;
            left: 0;
        }
        .arrow-wrapper-strafe {
            /* A wrapper for each SVG arrow, used by JS for positioning */
            position: absolute;             /* Positions relative to the anchor */
        }
        .strafe-arrow-svg {
            /* The SVG element itself */
            display: block;                 /* Removes extra space below the SVG */
            overflow: visible;              /* Allows glow effects to spill outside the SVG bounds */
        }
        /* --- END OF STRAFE VISUALIZER STYLES --- */

    </style>
</head>
<body>
    <canvas id="ui-canvas"></canvas> 
          
        <!-- START: SPLASH SCREEN & MAIN MENU -->
    <div 
        id="splash-screen" 
        style="
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 1000; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            color: white; 
            font-family: sans-serif;
        ">

        <!-- Splash screen background image -->
        <img 
            src="assets/images/vibe-weavers-splash-screen.png" 
            alt="Splash Screen" 
            style="
                position: absolute; 
                top: 0; 
                left: 0; 
                width: 100%; 
                height: 100%; 
                object-fit: cover; 
                z-index: -1;
            "
        />

        <!-- Container for the menu buttons (starts hidden) -->
        <div 
            id="menu-buttons" 
            style="
                display: none; 
                flex-direction: column; 
                align-items: center; 
                margin-top: 450px;
            ">
            <!-- Button to start a single-player game -->
            <button id="single-player-btn" class="menu-main-button">Single Player</button>
            <!-- Button to enter the multiplayer lobby -->
            <button id="multiplayer-btn" class="menu-main-button" style="margin-top: 20px;">Multiplayer P2P</button>

            <!-- Container for social and personal links -->
            <div class="social-links-container">
                <!-- Link principal do canal do jogo -->
                <!-- Container específico para organizar os links principais em uma linha -->
                <div class="main-channels-row">
                    <!-- Link do YouTube -->
                    <a href="https://www.youtube.com/@VIBE_RIDERS" target="_blank" class="social-link">
                        <i class="fab fa-youtube"></i>
                        <span>@VIBE_WEAVERS</span>
                    </a>

                    <!-- Link do Discord -->
                    <a href="https://discord.com/channels/1396102100521582695/1396102103658926182" target="_blank" class="social-link">
                        <i class="fab fa-discord"></i>
                        <span>Join our Discord</span>
                    </a>                  
                </div>

                <!-- Container para os links pessoais do desenvolvedor -->
                <div class="personal-links">
                    <a href="https://github.com/leoawen" target="_blank" class="social-link">
                        <!-- Ícone do GitHub -->
                        <i class="fab fa-github"></i>
                        <span>leoawen</span>
                    </a>
                    <a href="https://www.linkedin.com/in/leonardoawen/" target="_blank" class="social-link">
                        <!-- Ícone do LinkedIn -->
                        <i class="fab fa-linkedin"></i>
                        <span>leonardoawen</span>
                    </a>
                    <a href="https://www.behance.net/leonardoawen" target="_blank" class="social-link">
                        <!-- Ícone do Behance -->
                        <i class="fab fa-behance"></i>
                        <span>leonardoawen</span>
                    </a>
                </div>
            </div>
        </div>

        <!-- Container for loading status, progress bar, and error messages -->
        <div 
            id="loading-container" 
            style="
                display: flex; 
                flex-direction: column; 
                align-items: center; 
                justify-content: center;
                position: absolute;
                top: 50%;
                transform: translateY(-60%); 
            ">

            <!-- Box for the virtual console logs -->
            <div 
                id="virtual-console-box" 
                style="
                    width: 70vw;                            /* 70% of the viewport width */
                    max-width: 800px;                       /* Maximum width on large screens */
                    height: 40vh;                           /* 40% of the viewport height */
                    background-color: rgba(0, 0, 0, 0.5);   /* Semi-transparent black background */
                    border: 1px solid rgba(255, 255, 255, 0.2); /* Faint white border */
                    border-radius: 8px;                     /* Rounded corners */
                    padding: 15px;                          /* Inner spacing */
                    overflow-y: auto;                       /* Adds a scrollbar if content overflows */
                    display: flex;                          /* Enables flexbox layout */
                    flex-direction: column-reverse;         /* CRITICAL: New logs appear at the top! */
                    color: white;                           /* Text color */
                    font-family: 'Courier New', Courier, monospace; /* Monospaced font for a console look */
                    font-size: 14px;                        /* Font size */
                    line-height: 1.5;                       /* Space between lines */
                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);  /* Adds a subtle shadow */
                ">
                <!-- Logs will be added here via JavaScript -->
            </div>

            <!-- Progress Bar (now separate from the log box) -->
            <div 
                id="loading-progress-bar-container" 
                style="
                    width: 70vw;
                    max-width: 800px;
                    height: 25px;
                    background-color: rgba(0, 0, 0, 0.5);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 5px;
                    margin-top: 20px;
                    padding: 3px;
                    box-sizing: border-box;
                ">
                <!-- The inner bar that fills up -->
                <div 
                    id="loading-progress-bar" 
                    style="
                        width: 0%;                         
                        height: 100%;
                        background-color: #ff00ff;         
                        border-radius: 3px;
                        transition: width 0.2s ease-out;    
                    ">
                </div>
            </div>
            <!-- Text below the progress bar (e.g., "Loading...") -->
            <div id="loading-progress-text" style="margin-top: 10px; font-size: 16px; text-shadow: 1px 1px 2px black;">
                Loading...
            </div>
        </div>
    </div>
    <!-- END: SPLASH SCREEN & MAIN MENU -->
        
    <!-- START: P2P MULTIPLAYER LOBBY SCREENS -->
        <!-- SCREEN 1: Choose between Host and Guest -->
        <div id="lobby-screen" class="lobby-container" style="display: none;">
            <!-- Background image for the lobby -->
            <img src="assets/images/vibe-weavers-lobby-screen.png" alt="Lobby Background" class="lobby-background">
            
            <!-- Content box -->
            <div class="lobby-box">
                <h1 class="lobby-title">P2P Multiplayer Lobby</h1>
                <button id="host-btn" class="menu-main-button">Matchmaker (Host)</button>
                <button id="guest-btn" class="menu-main-button" style="margin-top: 20px;">Join Game (Guest)</button>
            </div>
        
            <!-- Button to return to the main menu -->
            <button id="back-to-splash-btn" class="menu-main-button menu-secondary-button">Back</button>
        </div>

        <!-- SCREEN 2: The Host's Screen -->
        <div id="host-screen" class="lobby-container" style="display: none;">
            <!-- Background image for the host screen -->
            <img src="assets/images/vibe-weavers-lobby-screen.png" alt="Host Background" class="lobby-background">
            
            <!-- Content box -->
            <div class="lobby-box">
                <h1 class="lobby-title">You are the Host</h1>
                <p class="lobby-text">Share this ID with your friends:</p>
                <strong id="host-id-display" class="lobby-id-display" title="Click to copy">Waiting for network ID...</strong>
                
                <h3 style="margin-top: 30px;">Connected Players:</h3>
                <div id="connected-players-list" class="lobby-player-list">
                    <!-- The list of connected players will appear here -->
                </div>
                
                <button id="start-multiplayer-game-btn" class="menu-main-button" style="margin-top: 20px;">Start Game</button>
            </div>

            <!-- Button to return to the lobby selection screen -->
            <button id="back-to-lobby-btn-host" class="menu-main-button menu-secondary-button">Back to Lobby</button>
        </div>

        <!-- SCREEN 3: The Guest's Screen -->
        <div id="guest-screen" class="lobby-container" style="display: none;">
            <!-- Background image for the guest screen -->
            <img src="assets/images/vibe-weavers-lobby-screen.png" alt="Guest Background" class="lobby-background">
            
            <!-- Content box -->
            <div class="lobby-box">
                <h1 class="lobby-title">Join as Guest</h1>
                <p class="lobby-text">Ask your Host for the ID and paste it below:</p>
                <input type="text" id="host-id-input" placeholder="Host ID" class="lobby-input">
                <button id="check-in-btn" class="menu-main-button" style="margin-top: 20px;">Check IN</button>
                <p id="guest-status-message" class="lobby-status">Waiting for ID...</p>
                <button id="join-multiplayer-game-btn" class="menu-main-button" style="margin-top: 10px; display: none;">Join Game</button>
            </div>
            
            <!-- Button to return to the lobby selection screen -->
            <button id="back-to-lobby-btn-guest" class="menu-main-button menu-secondary-button">Back to Lobby</button>
        </div>
    <!-- END: P2P MULTIPLAYER LOBBY SCREENS -->
  
    <!-- This div displays in-game instructions to the player -->
    <div id="instructions">
        Loading...<br/>
        WASD: Move | SPACE: Jump | MOUSE: Look<br/>
        H: Enter/Exit Podracer | R: Respawn<br/>
        (Click to lock mouse after loading in FPS mode)
    </div>

    <!-- This div acts as the in-game crosshair -->
    <div id="crosshair"></div>

    <!-- START: DEBUG HUDs -->
        <!-- HUD for Network Statistics -->
        <div 
            id="networkStatsHud" 
            style="
                position: absolute;
                top: 55px;
                right: 20px;
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                font-family: 'Courier New', Courier, monospace;
                font-size: 14px;
                padding: 10px;
                border-radius: 5px;
                z-index: 250; /* Above other UI elements */
                text-align: left;
                min-width: 200px;
                border: 1px solid #ff00ff;
                display: none; /* Starts hidden, shown by JavaScript */
                line-height: 1.2; /* Increases space between lines */
            ">
            <!-- Content will be filled by JavaScript -->
        </div>
    
        <!-- HUD for Frames Per Second (FPS) Counter -->
        <div 
            id="fpsCounter" 
            style="
                position: absolute;
                top: 20px;
                right: 20px;
                background-color: rgba(0, 0, 0, 0.7);
                color: #00ff00; /* Green to differentiate from network stats */
                font-family: 'Courier New', Courier, monospace;
                font-size: 18px;
                padding: 5px 10px;
                border-radius: 5px;
                z-index: 250;
                border: 1px solid #00ff00;
                display: none; /* Starts hidden */
            ">
            -- FPS
        </div>
    <!-- END: DEBUG HUDs -->
 
    <!-- START: PODRACER VISUAL "V" INDICATORS -->
        <!-- Container for the VERTICAL "V"s (for Podracer Pitch control) -->
        <div 
            id="podracerMousePitchIndicator" 
            style="
                position: absolute;
                top: 50%; 
                left: 50%;
                transform: translate(-50%, -50%);
                width: 24px;        /* Width of a vertical 'V' arrow */
                height: 60px;       /* Height to accommodate both 'V's and deflection space */
                z-index: 99; 
                display: none;      /* Starts hidden */
                pointer-events: none; /* Allows mouse events to pass through */
            ">

            <!-- Static Top 'V' (shown when the bottom conveyor is active) -->
            <div 
                id="podracerStaticTopV" 
                style="
                    position:absolute; 
                    top: 0px; 
                    left:50%; 
                    transform: translateX(-50%);
                    display: none;
                ">
                <svg width="24" height="18" viewbox="0 0 24 18">
                    <polyline id="staticTopVShape" points="2,16 12,2 22,16" style="fill:none;stroke:rgba(255, 255, 255, 0.5);stroke-width:2.5;stroke-linecap:round;stroke-linejoin:round;" />
                </svg>
            </div>

            <!-- Container for the Top Conveyor Arrow Effect (Pitch Up - Cyan) -->
            <div 
                id="podracerTopArrowEffectContainer" 
                style="
                    position:absolute;
                    top: calc(50% + 18px); /* Starts from the vertical center */
                    left: 50%;
                    width: 24px;
                    height: 18px;
                    display: none;
                    pointer-events: none;
                ">
                <!-- ConveyorArrowEffect (rotated -90deg) will be rendered here -->
            </div>

            <!-- Static Bottom 'V' (shown when the top conveyor is active) -->
            <div 
                id="podracerStaticBottomV" 
                style="
                    position:absolute; 
                    top: calc(50% + 12px); /* Fine-tuned to center below the exact middle */
                    left:50%; 
                    transform: translateX(-50%);
                    display: none;
                ">
                <svg width="24" height="18" viewbox="0 0 24 18">
                    <polyline id="staticBottomVShape" points="2,2 12,16 22,2" style="fill:none;stroke:rgb(255, 255, 255, 0.5);stroke-width:2.5;stroke-linecap:round;stroke-linejoin:round;" />
                </svg>
            </div>

            <!-- Container for the Bottom Conveyor Arrow Effect (Pitch Down - Magenta) -->
            <div 
                id="podracerBottomArrowEffectContainer" 
                style="
                    position:absolute;
                    top: calc(50% - 20px); /* Starts from the vertical center */
                    left: 50%;
                    width: 24px;
                    height: 18px;
                    display: none;
                    pointer-events: none;
                ">
                <!-- ConveyorArrowEffect (rotated 90deg) will be rendered here -->
            </div>
        </div>
    
        <!-- Container for the HORIZONTAL "V"s (for Podracer Yaw control) -->
        <div 
            id="podracerMouseYawIndicator" 
            style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 60px;        /* Total width for two 'V's side-by-side */
                height: 24px;       /* Height of a horizontal 'V' */
                z-index: 99;
                display: none;
                pointer-events: none;
            ">

            <!-- Static Left 'V' (shown when the right side is active) -->
            <div id="podracerStaticLeftV" style="position:absolute; left: 0px; top:0px; display: none;">
                <svg width="18" height="24" viewbox="0 0 18 24">
                    <polyline id="staticLeftVShape" points="16,2 2,12 16,22" style="fill:none;stroke:rgb(255, 255, 255, 0.5);stroke-width:2.5;stroke-linecap:round;stroke-linejoin:round;" />
                </svg>
            </div>

            <!-- Container for the Left Conveyor Arrow Effect -->
            <div 
                id="podracerLeftArrowEffectContainer" 
                style="
                    position:absolute;
                    left: 0px;
                    top: 0px;
                    width: 18px;
                    height: 24px;
                    display: none;
                    pointer-events: none;
                ">
                <!-- ConfigurableArrowEffect will be rendered here via JS -->
            </div>

            <!-- Static Right 'V' (shown when the left side is active) -->
            <div id="podracerStaticRightV" style="position:absolute; right: 0px; top:0px; display: none;">
                <svg width="18" height="24" viewbox="0 0 18 24">
                    <polyline id="staticRightVShape" points="2,2 16,12 2,22" style="fill:none;stroke:rgb(255, 255, 255, 0.5);stroke-width:2.5;stroke-linecap:round;stroke-linejoin:round;" />
                </svg>
            </div>

            <!-- Container for the Right Conveyor Arrow Effect -->
            <div 
                id="podracerRightArrowEffectContainer" 
                style="
                    position:absolute;
                    right: 0px;
                    top: 0px;
                    width: 18px;
                    height: 24px;
                    display: none;
                    pointer-events: none;
                ">
                <!-- ConfigurableArrowEffect will be rendered here via JS -->
            </div>
        </div>
    <!-- END: PODRACER VISUAL "V" INDICATORS -->

    <!-- Container for the Podracer Strafe Visualizer -->
    <div 
        id="strafe-visual-container" 
        style="
            position: absolute;
            left: 50%;
            /* 'bottom' position is set dynamically by JS */
            transform: translateX(-50%);
            z-index: 98; /* Sits below Yaw/Pitch indicators (99) and HUD (101) */
            display: none; /* Starts hidden, controlled by JS */
            pointer-events: none; /* Should not interfere with mouse events */
        ">
        <!-- Anchors for the left and right animated arrows -->
        <div id="left-arrow-anchor-strafe" class="arrow-anchor-strafe"></div>
        <div id="right-arrow-anchor-strafe" class="arrow-anchor-strafe"></div>
    </div>

    <!-- This div displays the main game HUD (Speed, Altitude, etc.) -->
    <div id="hudInfo">
        Speed: 0.0 km/h<br>
        Altitude: 0.0 m<br>
        Thrust: 0%
    </div>
        
    <!-- START: PAUSE MENU -->
    <div 
        id="pauseMenu" 
        style="
            display: none; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background-color: rgba(0, 0, 0, 0.8); 
            color: white; 
            padding: 30px; 
            border-radius: 10px; 
            z-index: 200; 
            text-align: center; 
            font-family: sans-serif; 
            min-width: 250px; 
            border: 2px solid white;
        ">
        <!-- Menu Title -->
        <h2>Menu</h2>
        <!-- Render Style Option -->
        <div class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Render Style:</span>
            <div>
                <button id="renderStylePrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="renderStyleValue" style="display: inline-block; min-width: 70px; text-align: center; font-weight: bold;">Normal</span>
                <button id="renderStyleNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>

        <!-- Antialiasing Option -->
        <div class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Antialiasing:</span>
            <div>
                <button id="aaPrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>                   
                <span id="aaValue" style="display: inline-block; min-width: 110px; text-align: center; font-weight: bold;">SMAA</span>
                <button id="aaNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>

        <!-- Dynamic Pixelation Option (only appears when Antialiasing is off) -->
        <div id="pixelationOption" class="menu-option" style="display: none; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Dynamic Pixelation:</span>
            <div>
                <button id="pixelationPrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="pixelationValue" style="display: inline-block; min-width: 110px; text-align: center; font-weight: bold;">Off</span>
                <button id="pixelationNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>

        <!-- Outline Options -->
        <!-- Option to enable/disable the visual outline effect -->
        <div class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Outline:</span>
            <div>
                <button id="outlineEnabledPrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="outlineEnabledValue" style="display: inline-block; min-width: 110px; text-align: center; font-weight: bold;">Enabled</span>
                <button id="outlineEnabledNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>

        <!-- Option to change the outline color -->
        <div class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Outline Color:</span>
            <div>
                <button id="outlineColorPrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="outlineColorValue" style="display: inline-block; min-width: 110px; text-align: center; font-weight: bold;">Black</span>
                <button id="outlineColorNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>

        <!-- Option for Podracer Mouse Flight Control Mode -->
        <div id="podracerMouseFlightModeOption" class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Mouse Flight (Pod):</span>
            <div>
                <button id="podracerMouseFlightModePrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="podracerMouseFlightModeValue" style="display: inline-block; min-width: 100px; text-align: center; font-weight: bold;">Steering</span>
                <button id="podracerMouseFlightModeNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>

        <!-- Option for Podracer Mouse Ground Control Mode -->
        <div id="podracerMouseSoloModeOption" class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Mouse Ground (Pod):</span>
            <div>
                <button id="podracerMouseSoloModePrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="podracerMouseSoloModeValue" style="display: inline-block; min-width: 100px; text-align: center; font-weight: bold;">Steering</span>
                <button id="podracerMouseSoloModeNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>

        <!-- Option for Podracer Ground Camera Roll -->
        <div id="podracerSoloCameraRollOption" class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Camera Roll (Pod Ground):</span>
            <div>
                <button id="podracerSoloCameraRollPrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="podracerSoloCameraRollValue" style="display: inline-block; min-width: 100px; text-align: center; font-weight: bold;">Enabled</span>
                <button id="podracerSoloCameraRollNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>
             
        <!-- Option for Podracer Ground W/S Acceleration Mode -->
        <div id="podracerSoloWSAccelModeOption" class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Accel. W/S (Pod Ground):</span>
            <div>
                <button id="podracerSoloWSAccelModePrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="podracerSoloWSAccelModeValue" style="display: inline-block; min-width: 100px; text-align: center; font-weight: bold;">Race</span>
                <button id="podracerSoloWSAccelModeNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>
             
        <!-- Option for Podracer Arrow Keys Acceleration Mode -->
        <div id="podracerArrowsAccelModeOption" class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Accel. Arrows (Pod):</span>
            <div>
                <button id="podracerArrowsAccelModePrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="podracerArrowsAccelModeValue" style="display: inline-block; min-width: 100px; text-align: center; font-weight: bold;">Throttle</span>
                <button id="podracerArrowsAccelModeNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>
              
        <!-- Option for Podracer Ground Key Control Mode (A/D, Q/E) -->
        <div id="podracerSoloKeyControlModeOption" class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Ground Keys (Pod):</span>
            <div>
                <button id="podracerSoloKeyControlModePrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="podracerSoloKeyControlModeValue" style="display: inline-block; min-width: 170px; text-align: center; font-weight: bold;">A/D:Strafe, Q/E:Yaw</span>
                <button id="podracerSoloKeyControlModeNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>          
             
        <!-- Option to adjust the Podracer's maximum speed -->
        <div id="podracerMaxSpeedOption" class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <span>Max Speed Pod (km/h):</span>
            <div>
                <button id="podracerMaxSpeedPrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                <span id="podracerMaxSpeedValue" style="display: inline-block; min-width: 100px; text-align: center; font-weight: bold;">600</span>
                <button id="podracerMaxSpeedNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
            </div>
        </div>

        <!-- Button to return to the game -->
        <button id="returnButton" class="menu-button" style="padding: 10px 20px; cursor: pointer; background-color: #4CAF50; border: none; color: white; border-radius: 5px; margin-top: 20px;">Return</button>
    </div>
    <!-- END: PAUSE MENU -->
          
    <!-- START: PLAYGROUND & RACE MODE MENUS -->
        <!-- Playground Menu: Main entry point for in-game activities -->
        <div id="playgroundMenu" class="lobby-container" style="display: none; z-index: 200;">
            <div class="lobby-box" style="border: 2px solid #ff00ff;">
                <h2 class="lobby-title">Playground</h2>
                <button id="createRaceBtn" class="menu-main-button">Create Race</button>
                <!-- Other game modes can be added here in the future -->
                <button id="closePlaygroundMenuBtn" class="menu-main-button menu-secondary-button">Close</button>
            </div>
        </div>
        
        <!-- Race Setup Menu: Choose race type -->
        <div id="raceSetupMenu" class="lobby-container" style="display: none; z-index: 201;">
            <div class="lobby-box" style="border: 2px solid #00ffff;">
                <h2 class="lobby-title">Setup Race</h2>
                <button id="soloRaceBtn" class="menu-main-button">Solo Race</button>
                <button id="invitePlayersBtn" class="menu-main-button" style="margin-top: 20px;" disabled>Invite Players (Coming Soon)</button>
                <button id="cleanupPortalsBtn" class="menu-main-button" style="margin-top: 20px;">Clean Up Portals</button>
                <button id="backToPlaygroundMenuBtn" class="menu-main-button menu-secondary-button">Back</button>
            </div>
        </div>  
        
        <!-- Solo Race Configuration Menu: Set laps, place portal -->
        <div id="soloRaceConfigMenu" class="lobby-container" style="display: none; z-index: 202;">
            <div class="lobby-box" style="border: 2px solid #00ff00;">
                <h2 class="lobby-title">Setup Solo Race</h2>
                <!-- Option to set the number of laps -->
                <div class="menu-option" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                    <span style="margin-right: 10px; font-size: 18px;">Number of Laps:</span>
                    <div>
                        <button id="lapsPrev" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-right: 5px;"><</button>
                        <span id="lapsValue" style="display: inline-block; min-width: 40px; text-align: center; font-weight: bold; font-size: 20px;">1</span>
                        <button id="lapsNext" class="menu-button" style="padding: 5px 10px; cursor: pointer; background-color: #555; border: 1px solid #888; color: white; margin-left: 5px;">></button>
                    </div>
                </div>
                <button id="positionPortalBtn" class="menu-main-button" style="margin-top: 20px;">Position Start Portal</button>
                <button id="backToRaceSetupMenuBtn" class="menu-main-button menu-secondary-button">Back</button>
            </div>
        </div>   

        <!-- On-screen message for portal placement mode -->
        <div 
            id="portalPlacementHint" 
            style="
                display: none; 
                position: absolute; 
                bottom: 10%; 
                left: 50%; 
                transform: translateX(-50%); 
                background-color: rgba(0,0,0,0.7); 
                color: white; 
                padding: 15px; 
                border-radius: 8px; 
                font-family: sans-serif; 
                font-size: 18px; 
                z-index: 250; 
                border: 2px solid yellow;
            ">
            Left Mouse: Accept | Right Mouse: Cancel
        </div>

        <!-- On-screen message for race status (countdown, etc.) -->
        <div 
            id="raceStatusMessage" 
            style="
                display: none; 
                position: absolute; 
                top: 30%; 
                left: 50%; 
                transform: translateX(-50%); 
                color: yellow; 
                font-family: sans-serif; 
                font-size: 80px; 
                font-weight: bold; 
                z-index: 250; 
                text-shadow: 4px 4px 8px black;
            ">
            PREPARE
        </div>

        <!-- On-screen element for the race stopwatch -->
        <div 
            id="raceTimerDisplay" 
            style="
                display: none; 
                position: absolute; 
                top: 20px; 
                left: 50%; 
                transform: translateX(-50%); 
                color: white; 
                font-family: 'Courier New', Courier, monospace; 
                font-size: 48px; 
                font-weight: bold; 
                z-index: 250; 
                text-shadow: 2px 2px 6px black;
                background-color: rgba(0,0,0,0.3);
                padding: 5px 20px;
                border-radius: 10px;
                min-width: 250px;
                text-align: center;
            ">
            00:00.000
        </div>
    <!-- END: PLAYGROUND & RACE MODE MENUS -->
       

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "three/addons/loaders/DRACOLoader.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/DRACOLoader.js",
                "@dimforge/rapier3d-compat": "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.16.0/+esm",
                "peerjs": "https://cdn.jsdelivr.net/npm/peerjs@1.5.2/+esm"
            }
        }
    </script>

    <script type="module">

    // ===================================================================
    // Copyright (c) 2025 Leonardo (leoawen) S. Gonçalves
    //
    // This software is released under the MIT License.
    // https://opensource.org/licenses/MIT
    // ===================================================================   
     
    // ===================================================================
    // ARCHITECTURE HEADER FOR AI COLLABORATION
    // ===================================================================
    //
    // DEAR AI ASSISTANT,
    //
    // This project is intentionally maintained as a SINGLE, MONOLITHIC FILE
    // to simplify sharing and ensure you always have the complete
    // context of the code with every interaction.
    //
    // The code is organized into NUMBERED SECTIONS (e.g., "1. IMPORTS",
    // "7. CORE GAME LOGIC", etc.) to simulate a modular structure.
    // Please respect and maintain this organization.
    //
    // KEY ARCHITECTURAL PRINCIPLES:
    //
    // 1. CENTRALIZED STATE MANAGEMENT:
    //    - ALL of a player's state (position, movement, vehicle status)
    //      resides within the `players.get(playerId).state` object.
    //    - DO NOT use global variables to store a player's state.
    //
    // 2. DECOUPLING OF INPUT AND LOGIC:
    //    - `handleKeyDown`/`handleKeyUp`: ONLY update the `keyboard` object.
    //    - `processLocalInput()`: Is the ONLY function that reads the `keyboard`
    //      object and translates input into CHANGES in the `player.state`.
    //    - `handle...Movement()`: Physics functions that ONLY READ the
    //      `player.state` to apply forces. They must not
    //      contain any input logic.
    //
    // When generating or modifying code, please adhere strictly to this structure.
    //
    // THANK YOU!
    //
    // ===================================================================

    
        // ===================================================================
        // 1. MODULE IMPORTS
        // ===================================================================
        import * as THREE from 'three';                                    // Imports the core Three.js library.
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';   // Imports the loader for GLTF/GLB 3D models.
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';     // Imports the loader for OBJ 3D models (Note: Imported but not currently used).
        import RAPIER from '@dimforge/rapier3d-compat';                    // Imports the Rapier 3D physics engine.
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js'; // Imports the manager for post-processing effects.
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';       // Imports the basic pass that renders the scene.
        import { Pass, FullScreenQuad } from 'three/addons/postprocessing/Pass.js';   // Imports base classes for creating custom post-processing passes.
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';         // Imports a pass that applies a custom shader.
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';             // Imports the SMAA (Subpixel Morphological Antialiasing) pass.
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';         // Imports the final pass that renders the result to the screen.
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';   // Imports the shader for FXAA (Fast Approximate Antialiasing).
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';   // Imports the loader for HDR environment maps.
        import { clone } from 'three/addons/utils/SkeletonUtils.js';     // Imports a utility to correctly clone animated (skinned) models.
        import Peer from 'peerjs';                                         // Imports the PeerJS library for P2P networking.
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js'; // 


        // ===================================================================
        // 2. GLOBAL CONFIGURATIONS (CONSTANTS) 
        // ===================================================================
        // --- Resource URLs ---
        const PODRACER_GLB_URL = 'assets/models/nave-star-mesh.glb'; // Visual Podracer model
        const PODRACER_COLLIDER_GLB_URL = 'assets/models/nave-star-colisor.glb'; // Podracer's physics collider shape.
        const TERRAIN_GLB_URL = 'assets/models/playground-compressed.glb'; // Main terrain/level model.
        const AJAXSON_GLB_URL = "assets/models/ajaxson-mesh-animado.glb"; // URL for the animated player character model.
        
        // -------------------------------------------------------------------
        // --- General Scene & Rendering Settings ---
        // -------------------------------------------------------------------
        const GRAVITY = { x: 0.0, y: -9.81, z: 0.0 };                // Defines the world's gravity vector (standard Earth gravity).
        const PHYSICS_TIMESTEP = 1.0 / 60.0;                         // Sets the physics simulation to run at a fixed 60 steps per second.
        const ENABLE_CCD = true;                                     // Enables Continuous Collision Detection to prevent fast objects from passing through thin walls.
        const BACKGROUND_COLOR = 0x87ceeb;                           // Sky blue background color for the scene.
        const SHADOW_MAP_SIZE = 2048;                                // Resolution of the shadow maps (higher is better quality but more expensive).
        const ENABLE_ANTIALIAS = true;                               // A general flag to indicate antialiasing is desired (specific method is chosen later).
        const CAMERA_FOV = 75;                                       // Camera's vertical field of view in degrees.
        const CAMERA_NEAR = 0.1;                                     // The closest distance the camera can see.
        const CAMERA_FAR = 50000;                                    // The farthest distance the camera can see.
        const AMBIENT_LIGHT_COLOR = 0xffffff;                        // Color of the ambient light (white).
        const AMBIENT_LIGHT_INTENSITY = 0.0;                         // Intensity of the ambient light (set to 0, relying on directional light).
        const TERRAIN_SCALE_FACTOR = 1.0;                            // A global multiplier for the size of the terrain model.
        const TERRAIN_FRICTION = 1.0;                                // The friction coefficient of the terrain surface.
        const TERRAIN_RESTITUTION = 0.1;                             // The "bounciness" of the terrain surface.
        const UNITS_PER_SECOND_TO_KM_PER_HOUR = 3.6;                 // Conversion factor from game units/sec to km/h for the HUD.
        const MAX_DELTA_TIME = 0.1;                                  // The maximum time allowed between frames to prevent physics instability on lag spikes.
        const FORWARD_VECTOR = new THREE.Vector3(0, 0, -1);          // A constant representing the forward direction in local space.
        const UP_VECTOR = new THREE.Vector3(0, 1, 0);                // A constant representing the up direction in local space.
        const RENDER_STYLES = ['NORMAL', 'NEAREST'];                 // Available texture filtering styles for the pause menu.

        // --- Nametag UI Settings ---
        const NAMETAG_PARAMS = {
            fontSize: 13,                   // The font size of the nametag text in pixels.
            fontFamily: 'sans-serif',       // The font family for the nametag.
            fontWeight: 'bold',             // The weight of the nametag font.
            textColor: '#FFFFFF',           // The color of the nametag text (white).
            fontOpacity: 1.0,               // The opacity of the text (fully opaque).
            backgroundColor: '#000000',     // The color of the nametag's background box (black).
            backgroundOpacity: 0.3,         // The opacity of the background box (semi-transparent).
            padding: 4,                     // The internal spacing (padding) of the background box.
        };
       
        // --- Directional Light (Sun) Constants ---
        const DIRECTIONAL_LIGHT_COLOR = 0xffffff;                    // The color of the main light source (white).
        const DIRECTIONAL_LIGHT_INTENSITY = 2.0;                     // The brightness of the main light.
        const DIRECTIONAL_LIGHT_DISTANCE = 9000.0;                   // How far away the light source is positioned.
        const DIRECTIONAL_LIGHT_SHADOW_MAP_SIZE = 1024;              // The resolution of the shadows cast by this light.
        const DIRECTIONAL_LIGHT_SHADOW_CAMERA_SIZE = 20000.0;        // The size of the area that will cast shadows.
        const SUN_DIRECTION = new THREE.Vector3(1, 1, 1).normalize(); // The normalized vector pointing from the light source towards the origin.
            
        // -------------------------------------------------------------------
        // --- Physics & Collision Settings ---
        // -------------------------------------------------------------------
        // Defines collision groups for granular control over physics interactions.
        // We use bitmasks to allow combining them in the future (e.g., GROUP_A | GROUP_B).
        const COLLISION_GROUP_GENERAL = 1 << 0;                      // = 1. For terrain, players, podracers.
        const COLLISION_GROUP_PORTAL  = 1 << 1;                      // = 2. An exclusive group for the race portal sensor.
        const COLLISION_GROUP_HOVER_RAY = 1 << 2;                    // = 4. An EXCLUSIVE group for the Podracer's hover/stabilization rays.
         
        // -------------------------------------------------------------------
        // --- Player (FPS Mode) Settings ---
        // -------------------------------------------------------------------
        const PLAYER_MOVE_SPEED = 10.0;                              // The base movement speed of the player character.
        const PLAYER_ACCELERATION = 2.0;                             // How quickly the player reaches their target speed.
        const SPRINT_MULTIPLIER = 2.0;                               // Multiplier applied to move speed when sprinting.
        const PLAYER_JUMP_THRUST_FORCE = 1800.0;                     // The upward force applied during a jump/jetpack burst.
        const PLAYER_JUMP_FUEL_DURATION = 1.0;                       // The duration the jump/jetpack can be used.
        const PLAYER_AIR_CONTROL_FACTOR = 0.1;                       // The amount of movement control the player has in mid-air near walls.
        const PLAYER_FULL_AIR_CONTROL_FACTOR = 1.0;                  // The amount of movement control the player has in open air.
        const PLAYER_AIR_WALL_DETECT_DISTANCE = 0.7;                 // The distance to check for nearby walls while airborne.
        const PLAYER_HEIGHT = 1.53;                                  // The total height of the player's physics capsule.
        const PLAYER_EYE_HEIGHT = 1.1;                               // The vertical position of the first-person camera within the capsule.
        const PLAYER_RADIUS = 0.4;                                   // The radius of the player's physics capsule.
        const PLAYER_DENSITY = 97.0;                                 // The density used to calculate the player's mass.
        const PLAYER_FRICTION = 0.7;                                 // The friction coefficient of the player's capsule.
        const PLAYER_RESTITUTION = 0.1;                              // The bounciness of the player's capsule.
        const PLAYER_LINEAR_DAMPING = 0.02;                          // The rate at which the player's movement slows down naturally.
        const INITIAL_PLAYER_POS = { x: 0, y: 10, z: 5 };             // The initial spawn position for the player.
        const PLAYER_EXIT_SIDE_OFFSET = 0.1;                         // Extra horizontal distance to place the player when exiting a vehicle.
        const PLAYER_EXIT_HEIGHT_OFFSET = 1.0;                       // Extra vertical distance to place the player when exiting a vehicle.
        const PLAYER_GROUND_CONTROL = {                              // An object containing settings for ground detection.
            MAX_SLOPE_ANGLE_DEG: 60.0,                               // The maximum slope angle the player can walk on.
            RAY_EXTRA_LENGTH: 0.5,                                   // Extra length for the ground detection ray.
            RAY_ORIGIN_OFFSET_Y: 0.1,                                // Vertical offset for the ray's origin.
            MAX_SLOPE_COS_ANGLE: Math.cos(THREE.MathUtils.degToRad(60.0)) // Pre-calculated cosine of the max slope angle for efficiency.
        };
        PLAYER_GROUND_CONTROL.MAX_SLOPE_COS_ANGLE = Math.cos(THREE.MathUtils.degToRad(PLAYER_GROUND_CONTROL.MAX_SLOPE_ANGLE_DEG)); // Re-calculation to ensure value is set.
        const animationSpeedFactors = {                              // An object containing speed multipliers for each character animation.
            walk: 1.5, walk_backward: 1.5, run: 1.0, run_backward: 1.0, strafe_left: 1.5, strafe_right: 1.5,
            strafe_run_left: 1.0, strafe_run_right: 1.0, walk_forward_right: 1.5, walk_forward_left: 1.5,
            run_forward_right: 1.0, run_forward_left: 1.0, turn_right: 1.0, turn_left: 1.0,
            idle: 0.5, jump: 0.5, fall: 0.5
        };
        
        // -------------------------------------------------------------------
        // --- Camera (FPS Mode) Settings ---
        // -------------------------------------------------------------------
        const FPS_THIRD_PERSON_OFFSET = new THREE.Vector3(0, 1.0, 2.5); // The camera's default offset from the player in third-person mode.
        const FPS_THIRD_PERSON_LOOKAT_Y_OFFSET = 0.8;                // Vertical offset for the point the third-person camera looks at.
        const FPS_THIRD_PERSON_MIN_ZOOM_DISTANCE = 1.0;              // The minimum zoom distance in third-person mode.
        const FPS_THIRD_PERSON_MAX_ZOOM_DISTANCE = 8.0;              // The maximum zoom distance in third-person mode.
        const FPS_THIRD_PERSON_ZOOM_SENSITIVITY = 0.2;               // The sensitivity of the mouse wheel for zooming.
        const FPS_THIRD_PERSON_CAM_LERP_FACTOR = 0.25;               // The smoothness factor for the third-person camera's movement.
        const FPS_PLATFORMER_INITIAL_AZIMUTH_OFFSET_FROM_PLAYER_FORWARD = 0; // Initial horizontal angle offset for the platformer camera.
        const FPS_PLATFORMER_INITIAL_ELEVATION = -Math.PI / 6;       // Initial vertical angle for the platformer camera.
        const FPS_PLATFORMER_INITIAL_DISTANCE = 4.0;                 // Initial distance for the platformer camera.
        const FPS_PLATFORMER_MIN_DISTANCE = 2.0;                     // Minimum distance for the platformer camera.
        const FPS_PLATFORMER_MAX_DISTANCE = 15.0;                    // Maximum distance for the platformer camera.
        const FPS_PLATFORMER_ZOOM_SENSITIVITY = 0.3;                 // Zoom sensitivity for the platformer camera.
        const FPS_PLATFORMER_MOUSE_SENSITIVITY_X = 0.005;            // Horizontal mouse sensitivity for the platformer camera.
        const FPS_PLATFORMER_MOUSE_SENSITIVITY_Y = 0.005;            // Vertical mouse sensitivity for the platformer camera.
        const FPS_PLATFORMER_MIN_ELEVATION = -Math.PI / 2 + 0.2;     // The lowest vertical angle the platformer camera can go.
        const FPS_PLATFORMER_MAX_ELEVATION = Math.PI / 2 - 0.2;      // The highest vertical angle the platformer camera can go.
        const PLAYER_PLATFORMER_YAW_SPEED = Math.PI * 1.5;           // The turning speed of the player character in platformer mode.
        const PLAYER_PLATFORMER_LOOKAT_Y_OFFSET = 1.0;               // Vertical offset for the point the platformer camera looks at.
        
        // -------------------------------------------------------------------
        // --- Podracer (General & Physics) Settings ---
        // -------------------------------------------------------------------
        const PODRACER_DENSITY = 170.0;                              // The density used to calculate the Podracer's mass.
        const PODRACER_DIMENSIONS = { x: 2.3, y: 0.9, z: 4.0 };      // The approximate dimensions of the Podracer.
        const PODRACER_LINEAR_DAMPING = 0.02;                        // The rate at which the Podracer's linear movement slows down naturally.
        const PODRACER_ANGULAR_DAMPING = 0.02;                       // The rate at which the Podracer's rotation slows down naturally.
        const PODRACER_FRICTION = 0.0;                               // The friction coefficient of the Podracer (set to 0 for a hover vehicle).
        const PODRACER_RESTITUTION = 0.1;                            // The bounciness of the Podracer.
        const PODRACER_SPAWN_OFFSET_X = 0.0;                         // Horizontal offset when spawning the Podracer.
        const PODRACER_SPAWN_OFFSET_Y = 0.0;                         // Vertical offset when spawning the Podracer.
        const PODRACER_ENTRY_SPAWN_DISTANCE = 0.0;                   // Forward distance from the player to spawn the Podracer.
        const PODRACER_JUMP_IMPULSE_FORCE = 100000.0;                // The upward impulse force applied when the Podracer jumps.
        const PODRACER_DOWN_IMPULSE_FORCE = 80000.0;                 // The downward impulse force applied in flight.
        const PODRACER_STRAFE_IMPULSE_FORCE = 50000.0;               // The lateral impulse force applied when the Podracer strafes.
        const PODRACER_MAX_THRUST_FORCE = 100000.0;                  // The maximum forward thrust force.
        const PODRACER_THRUST_ADJUST_RATE = 0.5;                     // The rate at which the thrust level changes (for throttle mode).
        const PODRACER_MAX_FORWARD_THRUST_NORMALIZED = 1.0;          // The maximum forward thrust, represented as a normalized value (100%).
        const PODRACER_MAX_REVERSE_THRUST_NORMALIZED = -0.10;        // The maximum reverse thrust, represented as a normalized value (-10%).
        const PODRACER_THRUST_APPLICATION_THRESHOLD = 0.01;          // The minimum thrust level required to apply any force.
        const PODRACER_DEFAULT_MAX_SPEED_KMH = 600.0;                // The default maximum speed of the Podracer in km/h.
        const PODRACER_MIN_ADJUSTABLE_MAX_SPEED_KMH = 100.0;         // The minimum adjustable max speed in the pause menu.
        const PODRACER_MAX_ADJUSTABLE_MAX_SPEED_KMH = 9999.0;        // The maximum adjustable max speed in the pause menu.
        const PODRACER_SPEED_ADJUSTMENT_STEP_KMH = 100.0;            // The increment/decrement step for adjusting max speed.
        const PODRACER_MAX_REVERSE_SPEED_KMH = 30.0;                 // The maximum reverse speed in km/h.
        const PODRACER_MAX_REVERSE_SPEED_MS = PODRACER_MAX_REVERSE_SPEED_KMH / UNITS_PER_SECOND_TO_KM_PER_HOUR; // Pre-calculated max reverse speed in m/s.
        const PODRACER_SPEED_LIMIT_REDUCTION_FACTOR = 1000.0;        // A factor that reduces thrust when exceeding the dynamic speed limit.
        const ENABLE_ACTIVE_DRIFT_CONTROL = true;                    // A flag to enable or disable the anti-drift system.
        const DRIFT_CORRECTION_IMPULSE_FACTOR_SOLO = 0.02;           // The strength of the anti-drift correction force on the ground.
        const FLIGHT_VELOCITY_ALIGNMENT_FACTOR = 0.04;               // The strength of the force that aligns the vehicle's velocity with its forward direction in flight.
        const MIN_SPEED_FOR_DRIFT_CONTROL = 1.0;                     // The minimum speed required for the anti-drift system to activate.

         // -------------------------------------------------------------------
        // --- Podracer Rotation Settings ---
        // -------------------------------------------------------------------
        const PODRACER_MAX_YAW_VELOCITY = Math.PI * 2.0;             // Maximum turning speed (left/right).
        const PODRACER_MAX_PITCH_VELOCITY = Math.PI * 2.0;           // Maximum pitching speed (up/down).
        const PODRACER_YAW_VELOCITY_ZERO_THRESHOLD_KEYBOARD = 0.005; // Small value below which keyboard yaw velocity is considered zero.
        const PODRACER_YAW_VELOCITY_ZERO_THRESHOLD_MOUSE_INPUT = 0.01; // Small value below which mouse yaw velocity is considered zero.
        const PODRACER_YAW_ACCEL_SHARED = 100.0;                     // General yaw acceleration rate.
        const PODRACER_YAW_DECEL_SHARED = 100.0;                     // General yaw deceleration rate.
        const PODRACER_YAW_KP_SHARED = 3000.0;                       // Proportional gain for the yaw PID controller (shared modes).
        const PODRACER_MOUSE_YAW_SENSITIVITY_STEERING = Math.PI * 2.0; // Mouse sensitivity for yaw in 'Steering' mode.
        const PODRACER_MOUSE_YAW_MOVEMENT_SENSITIVITY_STEERING = 0.001; // How much mouse movement contributes to the virtual steering wheel.
        const PODRACER_KEY_YAW_ACCELERATION_WHEN_MOUSE_STEERING = 1.0; // Keyboard yaw acceleration when mouse is in 'Steering' mode.
        const PODRACER_KEY_YAW_DECELERATION_WHEN_MOUSE_STEERING = 2.0; // Keyboard yaw deceleration when mouse is in 'Steering' mode.
        const PODRACER_MAX_YAW_NON_STEERING_VELOCITY = Math.PI * 4.0;  // Maximum yaw speed when mouse is in 'Non-Steering' mode.
        const PODRACER_MOUSE_SOLO_YAW_DIRECT_SENSITIVITY_NON_STEERING = 0.1; // Mouse sensitivity for direct yaw control on the ground.
        const PODRACER_MOUSE_FLIGHT_YAW_DIRECT_SENSITIVITY_NON_STEERING = 0.1; // Mouse sensitivity for direct yaw control in flight.
        const PODRACER_YAW_KP_NON_STEERING = 10000.0;                // Proportional gain for yaw in 'Non-Steering' mode.
        const PODRACER_YAW_DAMPING_FACTOR_NON_STEERING = 0.04;       // Damping factor for yaw in 'Non-Steering' mode.
        const PODRACER_KEY_YAW_ACCELERATION_FOR_NON_STEERING_MOUSE = 1.0; // Keyboard yaw acceleration when mouse is in 'Non-Steering' mode.
        const PODRACER_KEY_YAW_DECELERATION_FOR_NON_STEERING_MOUSE = 2.0; // Keyboard yaw deceleration when mouse is in 'Non-Steering' mode.
        const PODRACER_KEY_MAX_YAW_VELOCITY_FOR_NON_STEERING_MOUSE = Math.PI * 2.0; // Maximum keyboard yaw speed when mouse is in 'Non-Steering' mode.
        const PODRACER_KEY_YAW_KP_FOR_NON_STEERING_MOUSE = 3000.0;    // Proportional gain for keyboard yaw when mouse is in 'Non-Steering' mode.
        const PODRACER_PITCH_ACCEL_SHARED = 100.0;                   // General pitch acceleration rate.
        const PODRACER_PITCH_DECEL_SHARED = 100.0;                   // General pitch deceleration rate.
        const PODRACER_PITCH_KP_SHARED = 3000.0;                     // Proportional gain for the pitch PID controller (shared modes).
        const PODRACER_MOUSE_PITCH_SENSITIVITY_STEERING = Math.PI * 2.0; // Mouse sensitivity for pitch in 'Steering' mode.
        const PODRACER_MOUSE_PITCH_MOVEMENT_SENSITIVITY_STEERING = 0.001; // How much mouse movement contributes to the virtual joystick.
        const PODRACER_KEY_PITCH_ACCELERATION_WHEN_MOUSE_STEERING = 1.0; // Keyboard pitch acceleration when mouse is in 'Steering' mode.
        const PODRACER_KEY_PITCH_DECELERATION_WHEN_MOUSE_STEERING = 2.0; // Keyboard pitch deceleration when mouse is in 'Steering' mode.
        const PODRACER_MAX_PITCH_NON_STEERING_VELOCITY = Math.PI * 4.0; // Maximum pitch speed when mouse is in 'Non-Steering' mode.
        const PODRACER_MOUSE_FLIGHT_PITCH_DIRECT_SENSITIVITY_NON_STEERING = 0.1; // Mouse sensitivity for direct pitch control in flight.
        const PODRACER_PITCH_KP_NON_STEERING = 10000.0;              // Proportional gain for pitch in 'Non-Steering' mode.
        const PODRACER_PITCH_DAMPING_FACTOR_NON_STEERING = 0.04;     // Damping factor for pitch in 'Non-Steering' mode.
        const PODRACER_KEY_PITCH_ACCELERATION_FOR_NON_STEERING_MOUSE = 1.0; // Keyboard pitch acceleration when mouse is in 'Non-Steering' mode.
        const PODRACER_KEY_PITCH_DECELERATION_FOR_NON_STEERING_MOUSE = 2.0; // Keyboard pitch deceleration when mouse is in 'Non-Steering' mode.
        const PODRACER_KEY_MAX_PITCH_VELOCITY_FOR_NON_STEERING_MOUSE = Math.PI * 2.0; // Maximum keyboard pitch speed when mouse is in 'Non-Steering' mode.
        const PODRACER_KEY_PITCH_KP_FOR_NON_STEERING_MOUSE = 3000.0;  // Proportional gain for keyboard pitch when mouse is in 'Non-Steering' mode.
        const PODRACER_YAW_VELOCITY_ZERO_THRESHOLD = 0.01;           // General threshold below which yaw velocity is considered zero.
        const PODRACER_PITCH_VELOCITY_ZERO_THRESHOLD = 0.01;         // General threshold below which pitch velocity is considered zero.
        const PODRACER_ROLL_ACCELERATION = 1.0;                      // The acceleration rate for rolling (A/D keys in flight).
        const PODRACER_ROLL_DECELERATION = 2.0;                      // The deceleration rate for rolling.
        const PODRACER_MAX_ROLL_VELOCITY = Math.PI * 2.0;            // Maximum rolling speed.
        const PODRACER_ROLL_KP = 3000.0;                             // Proportional gain for the roll PID controller.
        const PODRACER_ANGULAR_VELOCITY_ZERO_THRESHOLD = 0.01;       // General threshold below which any angular velocity is considered zero.
        const PODRACER_MOUSE_NON_STEERING_DEADZONE = 1.0;            // Mouse movement deadzone for 'Non-Steering' mode.
        const PODRACER_MOUSE_DEADZONE_X = 0.0001;                    // Mouse movement deadzone for 'Steering' mode.

        // --- Pitch Indicator Constants ---
        const TOP_V_ACTIVE_COLOR_PITCH = '#00FFFF';                  // Cyan color for the "Pitch Up" indicator.
        const BOTTOM_V_ACTIVE_COLOR_PITCH = '#FF00FF';               // Magenta color for the "Pitch Down" indicator.
        const PODRACER_PITCH_V_EFFECT_MAX_DEFLECTION_PX = 800;       // Maximum vertical deflection in pixels for the pitch indicator effect.
        const PODRACER_YAW_V_EFFECT_MAX_DEFLECTION_PX = 800;         // Maximum horizontal deflection in pixels for the yaw indicator effect.

        // -------------------------------------------------------------------
        // --- Podracer Hover & Raycasting Settings ---
        // -------------------------------------------------------------------
        const PODRACER_HOVER_RAY_MAX_LENGTH = 6.0;                   // Maximum length of the downward hover rays.
        const PODRACER_HOVER_FORCE_KP = 60000.0;                     // Proportional gain for the hover force (spring strength).
        const PODRACER_HOVER_FORCE_KD = 6000.0;                      // Derivative gain for the hover force (damper strength).
        const PODRACER_STABILIZE_TORQUE_KP = 30000.0;                // Proportional gain for the self-righting torque.
        const PODRACER_STABILIZE_TORQUE_KD = 3000.0;                 // Derivative gain for the self-righting torque.
        const PODRACER_INITIAL_SPAWN_HOVER_OFFSET = 0.5;             // Extra height added when spawning the Podracer to prevent ground collision.
        const PODRACER_TETO_NORMAL_THRESHOLD_Y = -0.1;               // The Y-component threshold for a normal to be considered "ceiling".
        const PODRACER_STABILIZE_ANGLE_THRESHOLD = 0.01;             // The minimum angle error required to apply stabilization torque.
        const PODRACER_STABILIZE_AXIS_THRESHOLD_SQ = 0.0001;         // The minimum squared length of the rotation axis to apply stabilization torque.
        const PODRACER_MIN_DYNAMIC_HOVER_HEIGHT = 1.5;               // The minimum hover height at low speeds.
        const PODRACER_MAX_DYNAMIC_HOVER_HEIGHT = 3.5;               // The maximum hover height at high speeds.
        const PODRACER_SPEED_FOR_MAX_HOVER_HEIGHT_KMH = 600.0;       // The speed at which the maximum hover height is reached.
        const PODRACER_DYNAMIC_HOVER_HEIGHT_LERP_RATE = 0.2;         // The smoothness of the transition between hover heights.
        const PODRACER_FLIGHT_GRAVITY_SCALE_ON = 1.0;                // Gravity multiplier when flight gravity is enabled.
        const PODRACER_FLIGHT_GRAVITY_SCALE_OFF = 0.0;               // Gravity multiplier when flight gravity is disabled.
        const PODRACER_SUSPENSION_POINTS = [                         // The local positions of the four main hover/suspension points.
            new THREE.Vector3( 0.5, -0.45, -2.8), new THREE.Vector3(-0.5, -0.45, -2.8),
            new THREE.Vector3( 1.8, -0.45, 2.0), new THREE.Vector3(-1.8, -0.45, 2.0)
        ];
        const PODRACER_FORWARD_RAY_ENABLED = true;                   // Flag to enable the forward-facing obstacle detection ray.
        const PODRACER_FORWARD_RAY_ABSOLUTE_MAX_LENGTH = 30.0;       // The absolute maximum length of the forward ray.
        const PODRACER_FORWARD_RAY_MIN_LENGTH = 2.0;                 // The minimum length of the forward ray at zero speed.
        const PODRACER_FORWARD_RAY_TARGET_MAX_SPEED_KMH = 1000.0;    // The speed at which the forward ray reaches its maximum length.
        const PODRACER_FORWARD_RAY_LENGTH_EXPONENT = 2.0;            // The exponent for the non-linear scaling of the forward ray's length.
        const PODRACER_FORWARD_RAY_ORIGIN_OFFSET = new THREE.Vector3(0, 0, 0); // The local offset for the origin of the forward ray.
        const PODRACER_FORWARD_RAY_NORMAL_WEIGHT = 1.2;              // The influence weight of the forward ray's hit normal on stabilization.
        const PODRACER_SIDE_RAYS_ENABLED = false;                    // Flag to enable the side-facing obstacle detection rays.
        const PODRACER_SIDE_RAY_MAX_LENGTH = 4.0;                    // The maximum length of the side rays.
        const PODRACER_LEFT_REAR_RAY_ORIGIN_OFFSET = new THREE.Vector3(-PODRACER_DIMENSIONS.x / 2, -PODRACER_DIMENSIONS.y / 2 + 0.3, PODRACER_DIMENSIONS.z / 2); // The local offset for the left side ray.
        const PODRACER_RIGHT_REAR_RAY_ORIGIN_OFFSET = new THREE.Vector3(PODRACER_DIMENSIONS.x / 2, -PODRACER_DIMENSIONS.y / 2 + 0.3, PODRACER_DIMENSIONS.z / 2); // The local offset for the right side ray.
        const PODRACER_LEFT_RAY_NORMAL_WEIGHT = 1.0;                 // The influence weight of the left side ray's hit normal.
        const PODRACER_RIGHT_RAY_NORMAL_WEIGHT = 1.0;                // The influence weight of the right side ray's hit normal.
        const PODRACER_VELOCITY_RAY_ENABLED = true;                  // Flag to enable the ray that points in the direction of velocity.
        const PODRACER_VELOCITY_RAY_ABSOLUTE_MAX_LENGTH = 50.0;      // The absolute maximum length of the velocity ray.
        const PODRACER_VELOCITY_RAY_MIN_LENGTH = 2.0;                // The minimum length of the velocity ray.
        const PODRACER_VELOCITY_RAY_TARGET_MAX_SPEED_KMH = 600.0;    // The speed at which the velocity ray reaches its max length.
        const PODRACER_VELOCITY_RAY_LENGTH_EXPONENT = 2.0;           // The exponent for the non-linear scaling of the velocity ray's length.
        const PODRACER_VELOCITY_RAY_MIN_SPEED_THRESHOLD = 0.5;       // The minimum speed required to cast the velocity ray.
        const PODRACER_VELOCITY_RAY_ORIGIN_OFFSET = new THREE.Vector3(0, 0, 0); // The local offset for the origin of the velocity ray.
        const PODRACER_VELOCITY_RAY_NORMAL_WEIGHT = 1.0;             // The influence weight of the velocity ray's hit normal.
        const PODRACER_DOWNWARD_RAYS_TOTAL_WEIGHT = 1.0;             // The total influence weight of all downward-facing hover rays combined.
        const PODRACER_TARGET_UP_WEIGHT_THRESHOLD = 0.01;            // The minimum total weight required to use the calculated target up vector.
        const PODRACER_AERO_BRAKE_MAX_LINEAR_DAMPING = 8.0;          // The maximum linear damping applied when the aero brake is active.
        const PODRACER_AERO_BRAKE_MAX_ANGULAR_DAMPING = 3.0;         // The maximum angular damping applied when the aero brake is active.
        const PODRACER_AERO_BRAKE_RATE = 1.0;                        // The rate at which the aero brake damping is applied.

        // -------------------------------------------------------------------
        // --- Podracer Camera Settings ---
        // -------------------------------------------------------------------
        const PODRACER_CAM_MODE = { FIRST_PERSON: 1, ATTACHED: 2, ATTACHED_FAR: 3 }; // An object to represent the available camera modes.
        const PODRACER_FIRST_PERSON_CAM_OFFSET = new THREE.Vector3(0, 0, 0); // The local offset for the first-person camera.
        const PODRACER_FIRST_PERSON_CAM_LERP_FACTOR = 0.98;          // The smoothness factor for the first-person camera (very high for responsiveness).
        const PODRACER_ATTACHED_CAM_OFFSET = new THREE.Vector3(0, 2.5, 3.0); // The local offset for the standard third-person camera.
        const PODRACER_TARGET_AIM_DISTANCE = 50.0;                   // The desired aiming distance in meters for camera tilt calculation.
        const PODRACER_ATTACHED_CAM_LERP_FACTOR = 0.6;               // The smoothness factor for the standard third-person camera.
        const PODRACER_ATTACHED_FAR_CAM_OFFSET = new THREE.Vector3(0, 5.0, 5.0); // The local offset for the far third-person camera.
        const PODRACER_ATTACHED_FAR_CAM_LERP_FACTOR = 0.6;           // The smoothness factor for the far third-person camera.
        const PODRACER_SOLO_VISUAL_ROLL_MAX_ANGLE_DEG = 30.0;        // The maximum visual roll angle (in degrees) when turning on the ground.
        const PODRACER_SOLO_VISUAL_ROLL_MAX_ANGLE_RAD = THREE.MathUtils.degToRad(PODRACER_SOLO_VISUAL_ROLL_MAX_ANGLE_DEG); // Pre-calculated max roll angle in radians.
        const PODRACER_YAW_RATE_FOR_MAX_VISUAL_ROLL = PODRACER_MAX_YAW_VELOCITY / 3.0; // The turning speed at which the maximum visual roll is achieved.
        const PODRACER_SOLO_VISUAL_ROLL_LERP_RATE = 3.0;             // The smoothness of the visual roll effect.
        const PODRACER_COLLIDER_HELPER_COLOR = 0xffff00;             // The color of the debug wireframe for the Podracer's collider.
        const PODRACER_COLLIDER_HELPER_OPACITY = 0.5;                // The opacity of the debug wireframe.
        const CAMERA_BASE_FOV = CAMERA_FOV;                          // The camera's base field of view.
        const PODRACER_MAX_SPEED_FOV_ADDITION = 30.0;                // The additional FOV added at maximum speed to create a "speed" effect.
        const PODRACER_SPEED_FOR_MAX_FOV_EFFECT_KMH = 500.0;         // The speed at which the maximum FOV effect is achieved.

        // -------------------------------------------------------------------
        // --- Podracer Visual Indicator Settings ---
        // -------------------------------------------------------------------
        const PODRACER_V_INDICATOR_DEFAULT_COLOR = 'rgba(255, 255, 255, 0.5)'; // The default color for the static 'V' indicators.
        const PODRACER_V_INDICATOR_YAW_LEFT_COLOR = '#FF0000';        // The active color for the left yaw indicator.
        const PODRACER_V_INDICATOR_YAW_RIGHT_COLOR = '#00FF00';       // The active color for the right yaw indicator.
        const PODRACER_V_INDICATOR_PITCH_UP_COLOR = '#00FFFF';        // The active color for the pitch up indicator.
        const PODRACER_V_INDICATOR_PITCH_DOWN_COLOR = '#FF00FF';      // The active color for the pitch down indicator.
        const PODRACER_V_INDICATOR_CONVEYOR_START_COLOR = 'rgba(255,255,255,0.5)'; // The starting color for the animated conveyor effect.
        const PODRACER_V_INDICATOR_ACTIVATION_THRESHOLD = 0.005;     // The minimum input required to activate the animated indicators.
        const PODRACER_V_INDICATOR_MAX_DEFLECTION_PX = 800;          // The maximum deflection in pixels for the indicator container.
        const PODRACER_V_INDICATOR_MAX_SCALE_FACTOR = 10.0;          // The maximum scale multiplier for the indicator container.
        const PODRACER_V_INDICATOR_TARGET_OPACITY = 0.5;             // The target opacity for the animated indicators.
        const PODRACER_V_INDICATOR_TARGET_SCALE = 1.0;               // The target scale for the animated indicators.
        const PODRACER_V_INDICATOR_TARGET_GLOW_BLUR = 0;             // The target glow blur radius for the animated indicators.
        const PODRACER_PITCH_V_TOP_STATIC_OFFSET_PX = -28;           // The vertical offset for the static top 'V' indicator.
        const PODRACER_PITCH_V_BOTTOM_STATIC_OFFSET_PX = 12;         // The vertical offset for the static bottom 'V' indicator.
        const PODRACER_PITCH_V_EFFECT_BASE_OFFSET_PX = 8;            // The base vertical offset for the animated pitch effect container.

        // -------------------------------------------------------------------
        // --- Podracer Strafe (SVG) Indicator Settings ---
        // -------------------------------------------------------------------
        const params_strafe = {
            maxBarWidth: 200, barHeight: 25, arrowTipLength: 30, arrowStemHeightRatio: 0.6, globalOpacity: 0.9,
            leftBarTipColor: '#FF0000', rightBarTipColor: '#00FF00', enableGlow: true, leftGlowColor: '#FF0000',
            rightGlowColor: '#00FF00', glowBlur: 3, enableShimmer: true, shimmerColor: '#FFFF00', shimmerOpacity: 0.5,
            shimmerWidthPercent: 0.5, shimmerSpeed: 2, verticalOffsetVhFromBottom: 12,
            currentLeftWidth: 0, currentRightWidth: 0, animationSpeed: 800
        }; // An object containing all settings for the SVG-based strafe visualizer.
        const SVG_NS_STRAFE = "http://www.w3.org/2000/svg";          // The XML namespace for creating SVG elements.

        // -------------------------------------------------------------------
        // --- Visual Debugging Settings ---
        // -------------------------------------------------------------------
        const DEBUG_MESH_COLOR = 0x00ff00;                           // The color of the wireframe debug meshes for physics colliders.
        const DEBUG_MESH_OPACITY = 0.2;                              // The opacity of the debug meshes.
        const DEBUG_PODRACER_RAY_HIT_COLOR = 0x00ff00;               // The color of a debug ray that hits a surface.
        const DEBUG_PODRACER_RAY_MISS_COLOR = 0xff0000;              // The color of a debug ray that misses a surface.
        const DEBUG_PODRACER_NORMAL_LINE_LENGTH = 1.5;               // The length of the debug line that shows a surface normal.
        const DEBUG_PODRACER_NORMAL_DOWN_COLOR = 0xff0000;           // The color of a downward-pointing surface normal.
        const DEBUG_PODRACER_NORMAL_UP_COLOR = 0x0000ff;             // The color of an upward-pointing surface normal.
        const DEBUG_PODRACER_FWD_RAY_HIT_COLOR = 0x00ff00;           // The color of the forward debug ray when it hits.
        const DEBUG_PODRACER_FWD_RAY_MISS_COLOR = 0xff0000;          // The color of the forward debug ray when it misses.
        const DEBUG_PODRACER_FWD_NORMAL_COLOR = 0x0000ff;            // The color of the forward ray's hit normal.
        const DEBUG_PODRACER_SIDE_RAY_HIT_COLOR = 0x00ffff;          // The color of the side debug rays when they hit.
        const DEBUG_PODRACER_SIDE_RAY_MISS_COLOR = 0x800080;         // The color of the side debug rays when they miss.
        const DEBUG_PODRACER_SIDE_NORMAL_COLOR = 0x00ffff;           // The color of the side rays' hit normal.
        const DEBUG_PODRACER_VEL_RAY_HIT_COLOR = 0x00ffff;           // The color of the velocity debug ray when it hits.
        const DEBUG_PODRACER_VEL_RAY_MISS_COLOR = 0x800080;          // The color of the velocity debug ray when it misses.
        const DEBUG_PODRACER_VEL_NORMAL_COLOR = 0xffa500;            // The color of the velocity ray's hit normal.
        const DEBUG_PODRACER_TARGETUP_GRAV_COLOR = 0xffff00;         // The color of the target-up vector when flight gravity is ON.
        const DEBUG_PODRACER_TARGETUP_NOGRAV_COLOR = 0x0000ff;       // The color of the target-up vector when flight gravity is OFF.
        const DEBUG_PODRACER_TARGETUP_LINE_LENGTH = 3.0;             // The length of the target-up debug line.
        const DEBUG_PODRACER_RAY_LINEWIDTH = 2;                      // The width of the debug ray lines.
        const DEBUG_PODRACER_TARGETUP_LINEWIDTH = 3;                 // The width of the target-up debug line.
        
        // ===================================================================
        // SHADER DEFINITIONS (GLSL)
        // ===================================================================
        
        // --- START: SHADERS FOR CAUSTICS EFFECT ---
        const vertexShaderCaustics = `
            #include <common>
            #include <logdepthbuf_pars_vertex>
            out vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                #include <logdepthbuf_vertex>
            }`; // This vertex shader is standard; it passes UV coordinates and calculates the screen position.
        const fragmentShaderCaustics = `
            precision highp float;
            precision highp int;
            #include <logdepthbuf_pars_fragment>
            in vec2 vUv;
            out vec4 frogFragOut;
            uniform vec2 resolution;
            uniform vec2 flowSpeed_1746463289601_38;
            uniform vec3 backgroundColor_1746463289601_38;
            uniform vec3 color;
            uniform float speed_1746463289601_38;
            uniform float brightness;
            uniform float time;
            vec4 main_Tiling_Caustics() {
                vec2 local_uv = ( vUv.xy + ( time * flowSpeed_1746463289601_38 ) ) * resolution;
                vec2 p = mod(local_uv * 6.28318530718, 6.28318530718) - 250.0;
                vec2 i = vec2(p); float c = 1.0; float inten = 0.005;
                for ( int n = 0; n < 5; n++ ) {
                    float t = time * speed_1746463289601_38 * (1.0 - (3.5 / float(n + 1)));
                    i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
                    c += 1.0 / length(vec2(p.x / (sin(i.x + t) / inten), p.y / (cos(i.y + t) / inten)));
                }
                c /= float(5); c = 1.17 - pow( c, brightness );
                vec3 rgb = vec3( pow( abs( c ), 8.0 ) );
                return vec4( rgb * color + backgroundColor_1746463289601_38, length( rgb ) + 0.1 );
            }
            void main() {
                frogFragOut = main_Tiling_Caustics();
                #include <logdepthbuf_fragment>
            }`; // This fragment shader calculates a procedural, animated water caustics effect.
        // --- END: SHADERS FOR CAUSTICS EFFECT ---
        
        // --- START: SHADERS FOR GOD RAYS EFFECT ---
        const godRaysVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }`; // A simple vertex shader that passes through UV coordinates for post-processing.
        const godRaysFragmentShader = `
            uniform sampler2D tDiffuse;      // The input texture (occlusion mask).
            uniform vec2 lightPosition;     // The 2D screen-space position of the sun.
            uniform vec3 sunColor;          // The color of the god rays.
            uniform float density;          // The overall intensity/density of the rays.
            uniform float decay;            // How quickly the rays fade with distance from the sun.
            uniform float weight;           // The brightness of each ray sample.
            uniform float exposure;         // A final brightness multiplier.
            uniform int samples;            // The number of samples (controls quality vs. performance).
            varying vec2 vUv;               // The UV coordinate of the current pixel.
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
            }
            void main() {
                vec2 lightPos = (lightPosition + 1.0) * 0.5;
                vec2 delta = lightPos - vUv;
                vec2 step = delta / float(samples) * (1.0 + random(vUv) * 0.01);
                vec3 color = vec3(0.0);
                float illuminationDecay = 1.0;
                for(int i = 0; i < samples; i++) {
                    vec2 sampleCoord = vUv + float(i) * step;
                    vec4 sampleColor = texture2D(tDiffuse, sampleCoord);
                    sampleColor *= illuminationDecay * weight;
                    color += sampleColor.rgb;
                    illuminationDecay *= decay;
                }
                gl_FragColor = vec4(color * sunColor * density * exposure, 1.0);
            }`; // This fragment shader performs radial blurring from a light source to create volumetric light shafts (god rays).
        const finalCompositeFragmentShader = `
            uniform sampler2D tDiffuse; // The texture of the main rendered scene.
            uniform sampler2D tGodRays; // The texture containing the generated god rays.
            varying vec2 vUv;
            void main() {
                vec4 sceneColor = texture2D(tDiffuse, vUv);
                vec4 godraysColor = texture2D(tGodRays, vUv);
                // Adds the god rays on top of the scene color for a light-blending effect.
                gl_FragColor = sceneColor + godraysColor;
            }
        `; // This fragment shader combines the final rendered scene with the god rays texture.
        // --- END: SHADERS FOR GOD RAYS EFFECT ---


        // ===================================================================
        // NETWORK OPTIMIZATION ENUMERATION MAPS
        // ===================================================================
        // These maps translate state strings into small numbers to reduce the size of data packets sent over the network.
        
        // --- Mapping for ControlMode ---
        const CONTROL_MODE_MAP = { FPS: 0, PODRACER: 1 };             // Maps control mode strings to numbers for sending.
        const REVERSE_CONTROL_MODE_MAP = { 0: 'FPS', 1: 'PODRACER' }; // Maps numbers back to strings for receiving.

        // --- Mapping for AnimationState ---
        const ANIMATION_STATE_MAP = {                                // Maps animation state strings to numbers.
            'idle': 0, 'walk': 1, 'walk_backward': 2, 'run': 3, 'run_backward': 4, 'strafe_left': 5,
            'strafe_right': 6, 'strafe_run_left': 7, 'strafe_run_right': 8, 'jump': 9, 'fall': 10,
            'walk_forward_right': 11, 'walk_forward_left': 12, 'run_forward_right': 13, 'run_forward_left': 14,
            'turn_right': 15, 'turn_left': 16
        };
        const REVERSE_ANIMATION_STATE_MAP = {                        // Maps numbers back to animation state strings.
            0: 'idle', 1: 'walk', 2: 'walk_backward', 3: 'run', 4: 'run_backward', 5: 'strafe_left',
            6: 'strafe_right', 7: 'strafe_run_left', 8: 'strafe_run_right', 9: 'jump', 10: 'fall',
            11: 'walk_forward_right', 12: 'walk_forward_left', 13: 'run_forward_right', 14: 'run_forward_left',
            15: 'turn_right', 16: 'turn_left'
        };
        
        // ===================================================================
        // NETWORK DATA PACKING BITMASKS
        // ===================================================================
        // These masks allow packing multiple boolean states into a single number, drastically reducing data packet size.
        
        // --- Flags for the main player state ---
        const PLAYER_STATE_FLAGS = {
            IS_IN_VEHICLE:      1 << 0,                              // Bit 0: Represents the value 1
        };

        // --- Flags for the vehicle (Podracer) state ---
        const VEHICLE_STATE_FLAGS = {
            IS_IN_FLIGHT_MODE:      1 << 0,                          // Represents 1
            IS_JUMPING:             1 << 1,                          // Represents 2
            IS_AERO_BRAKING:        1 << 2,                          // Represents 4
            IS_APPLYING_DOWN_FORCE: 1 << 3,                          // Represents 8
            IS_RACE_THRUSTING:      1 << 4,                          // Represents 16
            IS_ROLLING_LEFT:        1 << 5,                          // Represents 32
            IS_ROLLING_RIGHT:       1 << 6,                          // Represents 64
            IS_STRAFING_LEFT:       1 << 7,                          // Represents 128
            IS_STRAFING_RIGHT:      1 << 8,                          // Represents 256
            IS_STRAFING_LEFT_IN_FLIGHT:  1 << 9,                     // Represents 512
            IS_STRAFING_RIGHT_IN_FLIGHT: 1 << 10,                    // Represents 1024
            IS_FLIGHT_GRAVITY_ACTIVE:    1 << 11,                    // Represents 2048
        };

        // -------------------------------------------------------------------
        // --- Network & Interpolation Settings ---
        // -------------------------------------------------------------------
        const INTERPOLATION_BUFFER_MS = 200.0;                       // The deliberate delay applied to smooth remote player movement, allowing packets time to arrive.
        const STATE_BUFFER_SIZE = 64;                                // The maximum size of the state buffer for each remote player to prevent memory leaks.


        // ===================================================================
        // 3. GLOBAL STATE VARIABLES
        // ===================================================================

        // --- Global State & Network Management ---
        const GameMode = {
            SPLASH: 'SPLASH',                       // The initial screen with Single/Multiplayer buttons.
            LOBBY: 'LOBBY',                         // The screen where the player chooses to be a Host or Guest.
            GAME_SINGLE_PLAYER: 'GAME_SINGLE_PLAYER', // The active single-player game state.
            GAME_MULTIPLAYER: 'GAME_MULTIPLAYER'      // The active multiplayer game state.
        };
        let currentGlobalMode = GameMode.SPLASH;    // The game starts on the splash screen.

        const NetworkRole = {
            NONE: 'NONE',                           // For single-player mode.
            HOST: 'HOST',                           // When the player is hosting a multiplayer game.
            GUEST: 'GUEST'                          // When the player is a guest in a multiplayer game.
        };
        let currentNetworkRole = NetworkRole.NONE;  // The initial network role is none.

        // --- PeerJS Variables ---
        let peer;                                   // Will hold our PeerJS instance.
        const connections = new Map();              // Stores all active P2P connections (maps peerId -> connection object).
        let localPlayerId = null;                   // The unique ID for the local player, set by PeerJS or generated locally.
        const playerRegistry = new Map();           // Central registry of players (ID -> Name), maintained by the Host.
        let isLobbyOpen = true;                     // Controls whether the Host is currently accepting new connections.

    
        // --- Scene & Rendering ---
        let scene, camera, renderer, controls, composer, renderPass, smaaPass, fxaaPass, pixelPass; // Core Three.js and post-processing components.
        let physicsWorld, eventQueue, integrationParameters; // Core Rapier physics components.
        const clock = new THREE.Clock();            // Three.js clock to measure time between frames (delta time).
        let frameCount = 0;                         // A counter for frames, used to calculate FPS.

        // --- Resource Management ---
        let terrainGltf = null, podracerVisualGltf = null, podracerColliderGltf = null, ajaxsonGltf = null; // Will hold the loaded GLTF asset data.
        let terrainMesh = null;                     // A direct reference to the terrain's visual mesh group.
        let allTexturedObjects = [];                // An array to hold all objects that need texture filtering updates.
        let causticsMaterialSet1, causticsMaterialSet2, causticsMaterialSet3, causticsMaterialSet4; // References to the custom caustics shader materials.
        
        // --- Player Management ---
        const players = new Map();                  // The central map holding all player objects (local and remote), mapping playerId to player data.

        // --- UI & Game State ---
        let isGameStarted = false;                  // A flag indicating if the game loop is active.
        let isPaused = false;                       // A flag indicating if the game is paused.
        let currentRenderStyle = 'NORMAL';          // The current texture filtering style ('NORMAL' or 'NEAREST').
        const AA_LEVELS = ['Off', 'FXAA', 'SMAA'];  // The available antialiasing options.
        let currentAALevel = 'SMAA';                // The currently selected antialiasing level.
        let isPixelationActive = false;             // A flag indicating if the dynamic pixelation effect is active.
        let isDebugVisible = false;                 // A flag to toggle the visibility of debug helpers.
        const ControlMode = { FPS: 'FPS', PODRACER: 'PODRACER' }; // An object representing the player's control modes.

        // --- Outline Effect Variables ---
        let isOutlineEnabled = true;                // The outline effect starts enabled by default.
        let currentOutlineColorName = 'Preto';      // The default color name for the outline effect.

        // A map to associate user-friendly color names with hexadecimal values for the outline.
        const OUTLINE_COLORS_MAP = {
            'Preto': '#000000', 'Branco': '#FFFFFF', 'Magenta': '#FF00FF', 'Ciano': '#00FFFF', 'Verde': '#00FF00',
            'Vermelho': '#FF0000', 'Azul': '#0000FF', 'Amarelo': '#FFFF00', 'Laranja': '#FFA500', 'Dourado': '#FFD700',
            'Pink': '#FFC0CB', 'Chocolate': '#D2691E', 'Cinza': '#808080'
        };

        // Arrays to store references to all outline materials and meshes.
        // This is ESSENTIAL for enabling/disabling and changing the color of all outlines at once.
        let allOutlineMaterials = [];               // Stores all created outline material instances.
        let allOutlineMeshes = [];                  // Stores all created outline mesh instances.

        // --- Control Mode States (from Pause Menu) ---
        const PODRACER_MOUSE_FLIGHT_MODE = { STEERING: 'STEERING', NON_STEERING: 'NON_STEERING' }; // Available mouse control modes for the Podracer in flight.
        let currentPodracerMouseFlightMode = PODRACER_MOUSE_FLIGHT_MODE.STEERING; // The default mouse flight mode.
        const PODRACER_MOUSE_SOLO_MODE = { STEERING: 'STEERING', NON_STEERING: 'NON_STEERING' }; // Available mouse control modes for the Podracer on the ground.
        let currentPodracerMouseSoloMode = PODRACER_MOUSE_SOLO_MODE.STEERING; // The default mouse ground mode.
        const PODRACER_SOLO_WS_ACCEL_MODE = { RACE: 'RACE', THROTTLE: 'THROTTLE' }; // Available acceleration modes for W/S keys on the ground.
        let currentPodracerSoloWSAccelMode = PODRACER_SOLO_WS_ACCEL_MODE.RACE; // The default W/S acceleration mode.
        const PODRACER_ARROWS_ACCEL_MODE = { RACE: 'RACE', THROTTLE: 'THROTTLE' }; // Available acceleration modes for arrow keys.
        let currentPodracerArrowsAccelMode = PODRACER_ARROWS_ACCEL_MODE.THROTTLE; // The default arrow key acceleration mode.
        const PODRACER_SOLO_KEY_CONTROL_MODE = { STRAFE_AD_YAW_QE: 'STRAFE_AD_YAW_QE', YAW_AD_STRAFE_QE: 'YAW_AD_STRAFE_QE' }; // Available key binding layouts for ground control.
        let currentPodracerSoloKeyControlMode = PODRACER_SOLO_KEY_CONTROL_MODE.STRAFE_AD_YAW_QE; // The default ground key layout.
        let isPodracerSoloCameraRollEnabled = true; // Flag to enable/disable the visual camera roll effect on the ground.
        let currentPodracerAdjustableMaxSpeedKmh = PODRACER_DEFAULT_MAX_SPEED_KMH; // The current maximum speed setting for the Podracer.
        
        // --- Game Logic State Variables (not part of player.state) ---
        let PODRACER_MAX_FORWARD_SPEED_MS = PODRACER_DEFAULT_MAX_SPEED_KMH / UNITS_PER_SECOND_TO_KM_PER_HOUR; // The max speed in meters/second, calculated from km/h.
        let currentDynamicTargetHoverHeight = PODRACER_MIN_DYNAMIC_HOVER_HEIGHT; // The current target hover height, which changes with speed.
        let lastCorrectionImpulse = new THREE.Vector3(0,0,0); // Stores the last anti-drift impulse for debugging.

        // --- Local Input Variables (not synchronized over network) ---
        const keyboard = {};                        // An object that holds the current state of all keyboard keys (true if pressed).
        let targetPodracerYawRateFromMouse = 0.0, targetPodracerPitchRateFromMouse = 0.0; // Stores the target rotation rates from mouse input.
        let mouseScreenOffsetX = 0.0;               // The normalized horizontal offset of the mouse from the screen center.
        let virtualSteeringWheelPosition = 0.0;     // A virtual "steering wheel" position controlled by the mouse for smooth turning.
        let virtualJoystickPitchPosition = 0.0;     // A virtual "joystick" position controlled by the mouse for smooth pitching.

        // --- HTML Element References ---
        let uiCanvas, uiContext;                    // References to the 2D UI canvas and its drawing context.
        let areNameTagsVisible = false;             // A flag to toggle the visibility of player nametags.
        let playerCounter = 0;                      // A counter to generate default player names.
        let splashScreen, menuButtons, singlePlayerBtn, multiplayerBtn; // References to splash screen elements.
        let loadingContainer, virtualConsoleBox, progressBar, progressText; // References to loading screen elements.
        let hudInfoElement;                         // Reference to the main in-game HUD element.
        let pauseMenuElement, returnButton;         // References to pause menu elements.
        let renderStyleValueElement, renderStylePrevButton, renderStyleNextButton; // References for the Render Style option.
        let aaValueElement, aaPrevButton, aaNextButton; // References for the Antialiasing option.
        let pixelationOptionElement, pixelationValueElement, pixelationPrevButton, pixelationNextButton; // References for the Pixelation option.
        let podracerMouseFlightModeOptionElement, podracerMouseFlightModeValueElement, podracerMouseFlightModePrevButton, podracerMouseFlightModeNextButton; // References for the Mouse Flight Mode option.
        let podracerMouseSoloModeOptionElement, podracerMouseSoloModeValueElement, podracerMouseSoloModePrevButton, podracerMouseSoloModeNextButton; // References for the Mouse Ground Mode option.
        let podracerSoloWSAccelModeOptionElement, podracerSoloWSAccelModeValueElement, podracerSoloWSAccelModePrevButton, podracerSoloWSAccelModeNextButton; // References for the W/S Acceleration Mode option.
        let podracerArrowsAccelModeOptionElement, podracerArrowsAccelModeValueElement, podracerArrowsAccelModePrevButton, podracerArrowsAccelModeNextButton; // References for the Arrows Acceleration Mode option.
        let podracerSoloKeyControlModeOptionElement, podracerSoloKeyControlModeValueElement, podracerSoloKeyControlModePrevButton, podracerSoloKeyControlModeNextButton; // References for the Ground Key Control Mode option.
        let podracerMaxSpeedOptionElement, podracerMaxSpeedValueElement, podracerMaxSpeedPrevButton, podracerMaxSpeedNextButton; // References for the Max Speed option.
        let podracerMouseYawIndicatorElement, podracerMouseIndicatorElementGlobalRef; // References for the Yaw indicator container.
        let staticLeftVElement, staticRightVElement, staticLeftVShape, staticRightVShape; // References for static 'V' elements (Yaw).
        let leftArrowEffectContainer, rightArrowEffectContainer, leftArrowEffectInstance, rightArrowEffectInstance; // References for animated arrow effects (Yaw).
        let podracerMousePitchIndicatorElement;     // Reference for the Pitch indicator container.
        let staticTopVElement, staticBottomVElement, staticTopVShape, staticBottomVShape; // References for static 'V' elements (Pitch).
        let topArrowEffectContainer, bottomArrowEffectContainer, topArrowEffectInstance, bottomArrowEffectInstance; // References for animated arrow effects (Pitch).

        // --- Debug Helper References ---
        let playerCapsuleHelper = null;             // Reference to the visual helper for the player's physics capsule.
        const playerGroundRayHelpers = [];          // An array to hold the visual helpers for the player's ground detection rays.
        let lastAirWallRayHelper = null;            // Reference to the visual helper for the player's air-wall detection ray.
        let physicsDebugMeshes = [];                // An array to hold all wireframe meshes that visualize physics colliders.
        let podracerDebugLines = [];                // An array to hold all debug lines related to the Podracer's raycasts.
        let podracerAimHelper = null;               // Reference to a helper object that visualizes the Podracer's aim point.

        // --- UI Visual Indicator Variables ---
        let leftArrowAnchor_strafe, rightArrowAnchor_strafe, strafeVisualContainer_strafe; // References for the strafe indicator elements.
        let leftStrafeArrowSVG_strafe, rightStrafeArrowSVG_strafe; // References for the strafe SVG arrow elements.
        let leftArrowWrapperEl_strafe, rightArrowWrapperEl_strafe; // References for the strafe arrow wrapper elements.
        let leftGradientId_strafe, rightGradientId_strafe; // IDs for the main strafe arrow gradients.
        let leftShimmerGradientId_strafe, rightShimmerGradientId_strafe; // IDs for the shimmer effect gradients.
        let lastTimestamp_strafe = 0, shimmerAnimationProgress_strafe = 0; // State variables for the shimmer animation.
        let isCameraCurrentlyObstructed = false;    // A flag indicating if the third-person camera is currently obstructed by terrain.
        let terrainOutlineMaterials = [];           // An array to specifically hold the outline materials for the terrain.

        // --- God Rays Effect Variables ---
        let godRaySun;                              // The THREE.Mesh object representing the sun in the sky.
        let occlusionRenderTarget;                  // The render target that will store the black and white occlusion mask.
        let godraysRenderTarget;                    // The render target that will store the final generated rays image.
        let occlusionMaterialBlack, occlusionMaterialWhite; // Simple materials used to create the occlusion mask.
        let godraysMaterial;                        // The custom shader material that generates the rays.
        let sunMaterial;                            // The material for the visible sun object.
        let post_scene, post_camera, post_quad;     // A separate scene for rendering the full-screen post-processing quad.
        let finalCompositeMaterial;                 // The material used for the final step of blending the god rays with the scene.

        // --- Race System State & References ---
        let playgroundMenu, raceSetupMenu, soloRaceConfigMenu; // References to the race menu HTML elements.
        let portalPlacementHint, raceStatusMessage; // References to on-screen message elements for the race.
        let isInPortalPlacementMode = false;        // A flag indicating if the player is currently placing the start/finish portal.
        let racePortalObject = null;                // Will hold the THREE.Mesh and physics data for the race portal.

        // Central state object for managing the race.
        let raceState = {
            isActive: false,                        // Is a race currently being set up or in progress?
            status: 'idle',                         // The current status of the race ('idle', 'placing', 'countdown', 'racing', 'finished').
            config: {                               // The configuration for the current race.
                laps: 1,                            // The number of laps.
                mode: 'none'                        // The race mode ('solo' or 'multi').
            },
            startTime: 0,                           // The timestamp when the race officially starts (first portal crossing).
            lapStartTime: 0,                        // The timestamp when the current lap started.
            racersData: new Map()                   // Maps a playerId to their race data ({ currentLap, lapTimes, ... }).
        };


        // ===================================================================
        // 4. HELPER CLASSES
        // ===================================================================
        
        // -----------------------------------------------------------------------
        // CLASS: PointerLockControls
        // Handles first-person camera controls by locking the mouse cursor.
        // This is a standard implementation, often found in Three.js examples.
        // -----------------------------------------------------------------------
        
        // Private helper variables for PointerLockControls to avoid creating new objects in the loop.
        const _euler_plc = new THREE.Euler( 0, 0, 0, 'YXZ' ); // An Euler object for calculating camera rotation. 'YXZ' order is standard for FPS controls.
        const _vector_plc = new THREE.Vector3();              // A reusable Vector3 for movement calculations.
        const _changeEvent_plc = { type: 'change' };          // A reusable event object dispatched when the camera moves.
        const _lockEvent_plc = { type: 'lock' };              // A reusable event object dispatched when the pointer is locked.
        const _unlockEvent_plc = { type: 'unlock' };          // A reusable event object dispatched when the pointer is unlocked.
        const _PI_2_plc = Math.PI / 2;                        // A constant for Pi / 2, used for clamping vertical rotation.

        class PointerLockControls extends THREE.EventDispatcher {
            constructor( camera, domElement ) {
                super(); // Calls the constructor of the parent class (THREE.EventDispatcher).
                
                this.camera = camera;               // The camera to be controlled.
                this.domElement = domElement;       // The HTML element that listens for mouse events (usually the body).
                
                this.isLocked = false;              // A boolean to track if the pointer is currently locked.
                
                // Flags to selectively enable/disable rotation on each axis.
                this.enablePitchControl = true;     // Enables up/down rotation.
                this.enableYawControl = true;       // Enables left/right rotation.
                
                // Clamps for vertical rotation to prevent the camera from flipping over.
                this.minPolarAngle = 0;             // The minimum vertical angle (0 = straight up).
                this.maxPolarAngle = Math.PI;       // The maximum vertical angle (Math.PI = straight down).
                
                this.pointerSpeed = 1.0;            // A multiplier for mouse sensitivity.
                
                // Binds the event handler functions to this instance to maintain the correct 'this' context.
                this._onMouseMove = onMouseMove_plc.bind( this );
                this._onPointerlockChange = onPointerlockChange_plc.bind( this );
                this._onPointerlockError = onPointerlockError_plc.bind( this );
                
                this.connect(); // Automatically attach event listeners on creation.
            }

            // Attaches the necessary event listeners to the document.
            connect() {
                this.domElement.ownerDocument.addEventListener( 'mousemove', this._onMouseMove );
                this.domElement.ownerDocument.addEventListener( 'pointerlockchange', this._onPointerlockChange );
                this.domElement.ownerDocument.addEventListener( 'pointerlockerror', this._onPointerlockError );
            }

            // Removes the event listeners.
            disconnect() {
                this.domElement.ownerDocument.removeEventListener( 'mousemove', this._onMouseMove );
                this.domElement.ownerDocument.removeEventListener( 'pointerlockchange', this._onPointerlockChange );
                this.domElement.ownerDocument.removeEventListener( 'pointerlockerror', this._onPointerlockError );
            }

            // A cleanup method that calls disconnect.
            dispose() { 
                this.disconnect(); 
            }

            // Returns the camera object.
            getObject() { 
                return this.camera; 
            }

            // Calculates the camera's forward direction and stores it in the provided vector 'v'.
            getDirection( v ) { 
                return v.set( 0, 0, - 1 ).applyQuaternion( this.camera.quaternion ); 
            }

            // Methods for simple camera movement (not used by the main physics system).
            moveForward( distance ) {
                _vector_plc.setFromMatrixColumn( this.camera.matrix, 0 );
                _vector_plc.crossVectors( this.camera.up, _vector_plc );
                this.camera.position.addScaledVector( _vector_plc, distance );
            }
            moveRight( distance ) {
                _vector_plc.setFromMatrixColumn( this.camera.matrix, 0 );
                this.camera.position.addScaledVector( _vector_plc, distance );
            }

            // Requests the browser to lock the mouse pointer.
            lock() { 
                this.domElement.requestPointerLock(); 
            }

            // Requests the browser to unlock the mouse pointer.
            unlock() { 
                this.domElement.ownerDocument.exitPointerLock(); 
            }
        }
        
        // Event handler for mouse movement.
        function onMouseMove_plc( event ) {
            if ( this.isLocked === false ) return; // Does nothing if the pointer isn't locked.

            // Gets the amount of mouse movement since the last event.
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            // Updates the camera's rotation based on mouse movement.
            _euler_plc.setFromQuaternion( this.camera.quaternion );

            if (this.enableYawControl) { // Handles left/right rotation.
                _euler_plc.y -= movementX * 0.002 * this.pointerSpeed; 
            }
            if (this.enablePitchControl) { // Handles up/down rotation.
                _euler_plc.x -= movementY * 0.002 * this.pointerSpeed;
                _euler_plc.x = Math.max( _PI_2_plc - this.maxPolarAngle, Math.min( _PI_2_plc - this.minPolarAngle, _euler_plc.x ) ); // Clamps the vertical angle.
            }
            
            this.camera.quaternion.setFromEuler( _euler_plc ); // Applies the new rotation to the camera.
            this.dispatchEvent( _changeEvent_plc ); // Notifies listeners that the camera has changed.
        }
        
        // Event handler for changes in the pointer lock state.
        function onPointerlockChange_plc() {
            if ( this.domElement.ownerDocument.pointerLockElement === this.domElement ) {
                this.dispatchEvent( _lockEvent_plc ); // Dispatches a 'lock' event.
                this.isLocked = true;
            } else {
                this.dispatchEvent( _unlockEvent_plc ); // Dispatches an 'unlock' event.
                this.isLocked = false;
            }
        }
        
        // Event handler for pointer lock errors.
        function onPointerlockError_plc() { 
            console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' ); 
        }

        // -----------------------------------------------------------------------
        // CLASS: ConveyorArrowEffect
        // A highly configurable class to create an animated SVG arrow effect.
        // Used for the Podracer's Yaw and Pitch UI indicators.
        // -----------------------------------------------------------------------
        class ConveyorArrowEffect {
            constructor(targetElement, customConfig = {}) {
                // Validates that a valid HTML element was provided.
                if (!targetElement || typeof targetElement.appendChild !== 'function') {
                    console.error("ConveyorArrowEffect: Invalid targetElement provided.");
                    return;
                }
                
                this.targetElement = targetElement; // The HTML element where the effect will be rendered.
                this.SVG_NS = "http://www.w3.org/2000/svg"; // The XML namespace for creating SVG elements.
                this.styleSheetId = 'conveyor-arrow-effect-styles'; // The ID for the dynamically injected CSS stylesheet.
                
                // Default configuration values for the effect.
                this.defaultConfig = {
                    overallDirection: 'left', colorStart: '#FFFFFF', colorEnd: '#FF0000', baseLength: 14, tipHeight: 10, stroke: 2.5,
                    numArrowsInFlow: 2, entryDelayFactor: 0.60, shouldShowFixedEndArrow: true, animateArrows: true, pathDuration: 1.2,
                    pathLength: 20, overallOpacityInitial: 0.50, overallOpacityFinal: 1.00, animScaleInitial: 0.50, animScaleFinal: 1.00,
                    reversePath: false, reverseOverallOpacity: false, reverseScale: false, enableGlow: false, colorGlow: '#FF0000', blurGlow: 3
                };
                
                this.config = { ...this.defaultConfig, ...customConfig }; // Merges default and custom configurations.
                
                this._ensureStyles(); // Injects the necessary CSS into the document head if it doesn't exist.
                
                // Internal state variables.
                this.arrowWrapper = null; 
                this.animatedArrowElements = []; 
                this.fixedArrowElement = null; 
                this.isBuilt = false;
                
                this._buildAndApplyInitialStyles(); // Builds the initial SVG structure.
            }

            // Injects the CSS required for the animations into the document's head.
            _ensureStyles() {
                if (document.getElementById(this.styleSheetId)) { return; } // Only injects once.
                const css = `
                    .conveyor-arrow-wrapper {} .conveyor-arrow-instance { position: absolute; top: 0; left: 0; }
                    .conveyor-arrow-instance svg { display: block; overflow: visible; }
                    .conveyor-arrow-instance polyline { fill: none; stroke-linecap: round; stroke-linejoin: round; }
                    @keyframes conveyorArrowPathAnimation_CAE {
                        0% { transform: translate(var(--path-from-tx, 0px), var(--path-from-ty, 0px)) scale(var(--path-from-scale, 1)); opacity: var(--overall-from-opacity, 0); }
                        100% { transform: translate(var(--path-to-tx, 0px), var(--path-to-ty, 0px)) scale(var(--path-to-scale, 1)); opacity: var(--overall-to-opacity, 1); } }
                    @keyframes conveyorColorCrossfadeStart_CAE { 0% { opacity: 1; } 100% { opacity: 0; } }
                    @keyframes conveyorColorCrossfadeEnd_CAE { 0% { opacity: 0; } 100% { opacity: 1; } }`;
                const styleElement = document.createElement('style');
                styleElement.id = this.styleSheetId; 
                styleElement.textContent = css; 
                document.head.appendChild(styleElement);
            }

            // Creates a single SVG arrow element.
            _createSVGArrowElementInternal() {
                const { baseLength, tipHeight, stroke } = this.config;
                const instanceDiv = document.createElement('div');
                instanceDiv.className = 'conveyor-arrow-instance';
                const p1x = baseLength + stroke / 2, p1y = stroke / 2, p2x = stroke / 2, p2y = tipHeight + stroke / 2;
                const p3x = baseLength + stroke / 2, p3y = 2 * tipHeight + stroke / 2;
                const pointsData = `${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`;
                const svgWidth = baseLength + stroke, svgHeight = 2 * tipHeight + stroke;
                const svg = document.createElementNS(this.SVG_NS, "svg");
                svg.setAttribute("width", String(svgWidth));
                svg.setAttribute("height", String(svgHeight));
                svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
                const polylineStart = document.createElementNS(this.SVG_NS, "polyline");
                polylineStart.setAttribute("points", pointsData);
                polylineStart.style.strokeWidth = String(stroke);
                polylineStart.classList.add('polyline-start-color');
                const polylineEnd = document.createElementNS(this.SVG_NS, "polyline");
                polylineEnd.setAttribute("points", pointsData);
                polylineEnd.style.strokeWidth = String(stroke);
                polylineEnd.classList.add('polyline-end-color');
                svg.appendChild(polylineStart);
                svg.appendChild(polylineEnd);
                instanceDiv.appendChild(svg);
                return instanceDiv;
            }

            // Builds the complete DOM structure for the effect.
            _buildAndApplyInitialStyles() {
                if (!this.isBuilt) {
                    this.targetElement.innerHTML = '';
                    this.animatedArrowElements = [];
                    this.fixedArrowElement = null;
                    this.arrowWrapper = document.createElement('div');
                    this.arrowWrapper.className = 'conveyor-arrow-wrapper';
                    this.arrowWrapper.style.position = 'absolute';
                    this.arrowWrapper.style.top = '50%';
                    this.arrowWrapper.style.left = '50%';
                    const { baseLength, tipHeight, stroke } = this.config;
                    this.arrowWrapper.style.width = `${baseLength + stroke}px`;
                    this.arrowWrapper.style.height = `${2 * tipHeight + stroke}px`;
                    this.targetElement.appendChild(this.arrowWrapper);
                    const { numArrowsInFlow, animateArrows, entryDelayFactor, pathDuration, pathLength, overallOpacityInitial, overallOpacityFinal,
                            animScaleInitial, animScaleFinal, shouldShowFixedEndArrow } = this.config;
                    let conveyorAnimFromX = this.config.reversePath ? 0 : pathLength;
                    let conveyorAnimToX = this.config.reversePath ? pathLength : 0;
                    if (numArrowsInFlow > 0 && animateArrows) {
                        for (let i = 0; i < numArrowsInFlow; i++) {
                            const instanceDiv = this._createSVGArrowElementInternal();
                            let currentOverallOpacityStart = this.config.reverseOverallOpacity ? overallOpacityFinal : overallOpacityInitial;
                            let currentOverallOpacityEnd = this.config.reverseOverallOpacity ? overallOpacityInitial : overallOpacityFinal;
                            let currentAnimScaleStart = this.config.reverseScale ? animScaleFinal : animScaleInitial;
                            let currentAnimScaleEnd = this.config.reverseScale ? animScaleInitial : animScaleFinal;
                            let currentEntryDelay = this.config.reversePath ? (numArrowsInFlow - 1 - i) * entryDelayFactor : i * entryDelayFactor;
                            instanceDiv.style.setProperty('--path-from-tx', `${conveyorAnimFromX}px`);
                            instanceDiv.style.setProperty('--path-from-ty', `0px`);
                            instanceDiv.style.setProperty('--path-to-tx', `${conveyorAnimToX}px`);
                            instanceDiv.style.setProperty('--path-to-ty', `0px`);
                            instanceDiv.style.setProperty('--path-from-scale', String(currentAnimScaleStart));
                            instanceDiv.style.setProperty('--path-to-scale', String(currentAnimScaleEnd));
                            instanceDiv.style.setProperty('--overall-from-opacity', String(currentOverallOpacityStart));
                            instanceDiv.style.setProperty('--overall-to-opacity', String(currentOverallOpacityEnd));
                            instanceDiv.style.animationName = 'conveyorArrowPathAnimation_CAE';
                            instanceDiv.style.animationDuration = `${pathDuration}s`;
                            instanceDiv.style.animationTimingFunction = 'linear';
                            instanceDiv.style.animationDelay = `${currentEntryDelay}s`;
                            instanceDiv.style.animationIterationCount = 'infinite';
                            instanceDiv.style.opacity = String(0);
                            const polyStart = instanceDiv.querySelector('.polyline-start-color');
                            const polyEnd = instanceDiv.querySelector('.polyline-end-color');
                            polyStart.style.opacity = '1';
                            polyEnd.style.opacity = '0';
                            polyStart.style.animation = `conveyorColorCrossfadeStart_CAE ${pathDuration}s linear ${currentEntryDelay}s infinite`;
                            polyEnd.style.animation = `conveyorColorCrossfadeEnd_CAE ${pathDuration}s linear ${currentEntryDelay}s infinite`;
                            this.arrowWrapper.appendChild(instanceDiv);
                            this.animatedArrowElements.push({ div: instanceDiv, polyStart, polyEnd });
                        }
                    }
                    if (shouldShowFixedEndArrow) {
                        const fixedDiv = this._createSVGArrowElementInternal();
                        this.arrowWrapper.appendChild(fixedDiv);
                        this.fixedArrowElement = { div: fixedDiv, polyStart: fixedDiv.querySelector('.polyline-start-color'), polyEnd: fixedDiv.querySelector('.polyline-end-color') };
                    }
                    this.isBuilt = true;
                }
                this._applyDynamicStyles();
            }

            // Applies styles based on the current configuration.
            _applyDynamicStyles() {
                if (!this.isBuilt || !this.arrowWrapper) return;
                const { colorStart, colorEnd, enableGlow, colorGlow, blurGlow, animScaleInitial, animScaleFinal,
                        overallOpacityInitial, overallOpacityFinal, overallDirection } = this.config;
                
                this.animatedArrowElements.forEach(elements => {
                    elements.polyStart.style.stroke = colorStart;
                    elements.polyEnd.style.stroke = colorEnd;
                    elements.div.style.filter = enableGlow ? `drop-shadow(0px 0px ${blurGlow}px ${colorGlow})` : 'none';
                });

                if (this.fixedArrowElement) {
                    const fixedElements = this.fixedArrowElement;
                    fixedElements.polyStart.style.stroke = colorStart;
                    fixedElements.polyEnd.style.stroke = colorEnd;
                    if (colorStart === colorEnd) {
                        fixedElements.polyStart.style.opacity = '1';
                        fixedElements.polyEnd.style.opacity = '0';
                    } else {
                        fixedElements.polyStart.style.opacity = '0';
                        fixedElements.polyEnd.style.opacity = '1';
                    }
                    fixedElements.div.style.filter = enableGlow ? `drop-shadow(0px 0px ${blurGlow}px ${colorGlow})` : 'none';
                    let fixedArrowScale = this.config.reverseScale ? animScaleInitial : animScaleFinal;
                    let fixedArrowOpacity = this.config.reverseOverallOpacity ? overallOpacityInitial : overallOpacityFinal;
                    fixedElements.div.style.transform = `translate(0px, 0px) scale(${fixedArrowScale})`;
                    fixedElements.div.style.opacity = String(fixedArrowOpacity);
                }

                let visualRotation = 0;
                switch (overallDirection) {
                    case 'left':  visualRotation = 0;   break;
                    case 'right': visualRotation = 180; break;
                    case 'up':    visualRotation = 90;  break;
                    case 'down':  visualRotation = -90; break;
                }
                this.arrowWrapper.style.transform = `translate(-50%, -50%) rotate(${visualRotation}deg)`;
            }

            // Updates the effect's configuration and rebuilds if necessary.
            updateConfig(newConfig) {
                const oldConfig = { ...this.config };
                this.config = { ...this.config, ...newConfig };
                
                const structuralProperties = [
                    'numArrowsInFlow', 'animateArrows', 'entryDelayFactor', 'pathDuration', 'pathLength', 'reversePath',
                    'shouldShowFixedEndArrow', 'baseLength', 'tipHeight', 'stroke', 'overallOpacityInitial', 'overallOpacityFinal',
                    'animScaleInitial', 'animScaleFinal', 'reverseOverallOpacity', 'reverseScale'
                ];
                
                let needsRebuild = structuralProperties.some(prop => this.config[prop] !== oldConfig[prop]);
                if (needsRebuild && this.isBuilt) {
                    this.isBuilt = false;
                }
                
                this._buildAndApplyInitialStyles();
            }

            // Public method to trigger a render/style update.
            render() { 
                this._buildAndApplyInitialStyles(); 
            }

            // Cleans up the DOM elements created by this instance.
            destroy() {
                this.targetElement.innerHTML = '';
                this.arrowWrapper = null;
                this.animatedArrowElements = [];
                this.fixedArrowElement = null;
                this.isBuilt = false;
            }
        }

        // -----------------------------------------------------------------------
        // CLASS: RenderPixelatedPass
        // A custom Three.js post-processing pass that renders the scene with a 
        // dynamic pixelated (retro) effect.
        // -----------------------------------------------------------------------
        class RenderPixelatedPass extends Pass {
            constructor( initialPixelSize, scene, camera, options = {} ) {
                super(); // Calls the parent Pass constructor.
                
                this.pixelSize = initialPixelSize; // The base size of the pixels.
                this.scene = scene;                // The scene to be pixelated.
                this.camera = camera;              // The camera used to view the scene.
                
                this.pixelatedMaterial = this.createPixelatedMaterial(); // Creates the custom shader material.
                this.fsQuad = new FullScreenQuad( this.pixelatedMaterial ); // Creates a full-screen plane to apply the shader.

                // A "render target" is an off-screen buffer (like a texture) that we can render to.
                this.beautyRenderTarget = new THREE.WebGLRenderTarget();
                this.beautyRenderTarget.texture.minFilter = THREE.NearestFilter; // Use nearest-neighbor filtering for a sharp, pixelated look.
                this.beautyRenderTarget.texture.magFilter = THREE.NearestFilter;
                this.beautyRenderTarget.texture.type = THREE.HalfFloatType; // Use half-float for better precision.
                
                // CRITICAL: This enables the creation of a depth texture, which our shader will read.
                this.beautyRenderTarget.depthTexture = new THREE.DepthTexture();
                this.beautyRenderTarget.depthTexture.type = THREE.UnsignedInt248Type; // A common format for depth textures.
            }

            // Cleans up GPU resources.
            dispose() {
                this.beautyRenderTarget.dispose();
                this.pixelatedMaterial.dispose();
                this.fsQuad.dispose();
            }

            // Updates the size of the render target when the window is resized.
            setSize( width, height ) {
                this.beautyRenderTarget.setSize( width, height );
                this.pixelatedMaterial.uniforms.resolution.value.set(width, height);
            }

            // The main render method called by the EffectComposer.
            render( renderer, writeBuffer ) {
                // 1. Render the normal scene into our off-screen render target.
                renderer.setRenderTarget( this.beautyRenderTarget );
                renderer.render( this.scene, this.camera );

                // 2. Pass the resulting color and depth textures to our custom shader.
                this.fsQuad.material.uniforms.tDiffuse.value = this.beautyRenderTarget.texture;
                this.fsQuad.material.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture;

                // 3. Render our full-screen quad (with the pixelation shader) to the screen or the next pass.
                if ( this.renderToScreen ) {
                    renderer.setRenderTarget( null );
                } else {
                    renderer.setRenderTarget( writeBuffer );
                    if ( this.clear ) renderer.clear();
                }
                this.fsQuad.render( renderer );
            }

            // Creates the custom ShaderMaterial for the pixelation effect.
            createPixelatedMaterial() {
                return new THREE.ShaderMaterial({
                    // Defines required for logarithmic depth buffer compatibility.
                    defines: {
                        'USE_LOGDEPTHBUF': '',
                        'USE_LOGDEPTHBUF_EXT': ''
                    },
                    // Variables (uniforms) passed from JavaScript to the shader.
                    uniforms: {
                        "tDiffuse": { value: null },   // The scene's color texture.
                        "tDepth": { value: null },     // The scene's depth texture.
                        "resolution": { value: new THREE.Vector2() }, // The screen resolution.
                    },
                    // The vertex shader (standard for post-processing).
                    vertexShader: /* glsl */`
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                        }`,
                    // The fragment shader, where the pixelation logic happens.
                    fragmentShader: /* glsl */`
                        uniform sampler2D tDiffuse;
                        uniform sampler2D tDepth;
                        uniform vec2 resolution;
                        varying vec2 vUv;
                        
                        void main() {
                            // Logic to preserve silhouettes by checking the depth of a 2x2 block of pixels.
                            vec2 texelSize = 1.0 / resolution;
                            float depth_top_left     = texture2D(tDepth, vUv).r;
                            float depth_top_right    = texture2D(tDepth, vUv + vec2(texelSize.x, 0.0)).r;
                            float depth_bottom_left  = texture2D(tDepth, vUv + vec2(0.0, texelSize.y)).r;
                            float depth_bottom_right = texture2D(tDepth, vUv + texelSize).r;
                            float closestDepth = min(depth_top_left, min(depth_top_right, min(depth_bottom_left, depth_bottom_right)));

                            // Logic to set the pixel size based on the depth of the object.
                            float dynamicPixelSize;
                            if (closestDepth < 0.05) {
                                dynamicPixelSize = 6.0;
                            } else if (closestDepth < 0.1) {
                                dynamicPixelSize = 5.0;
                            } else if (closestDepth < 0.15) {
                                dynamicPixelSize = 4.0;
                            } else if (closestDepth < 0.2) {
                                dynamicPixelSize = 3.0;
                            } else {
                                dynamicPixelSize = 2.0;
                            }

                            // Calculates the new UV coordinate for the top-left of the "pixel block" and samples the color.
                            vec2 pixelatedUv = floor(vUv * resolution / dynamicPixelSize) * dynamicPixelSize / resolution;
                            gl_FragColor = texture2D(tDiffuse, pixelatedUv);
                        }`
                });
            }
        }

        // ===================================================================
        // CUSTOM POST-PROCESSING PASSES FOR GOD RAYS
        // ===================================================================

        // --- CLASS 1: GodRaysGeneratePass ---
        // This pass does the heavy lifting: it creates the occlusion mask and then
        // generates the god rays texture from it. It does NOT render to the screen,
        // it only prepares the 'godraysRenderTarget' for the next pass.
        class GodRaysGeneratePass extends Pass {
            constructor(scene, camera, sunObject, occlusionTarget, godraysTarget, blackMaterial, whiteMaterial, godraysShaderMaterial) {
                super();
                this.scene = scene;
                this.camera = camera;
                this.sunObject = sunObject;
                this.occlusionRenderTarget = occlusionTarget;
                this.godraysRenderTarget = godraysTarget;
                this.occlusionMaterialBlack = blackMaterial;
                this.occlusionMaterialWhite = whiteMaterial;
                this.godraysMaterial = godraysShaderMaterial;
                
                // A separate, simple scene is used to render the full-screen quad with our shader.
                this.post_scene = new THREE.Scene();
                this.post_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                this.post_quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.godraysMaterial);
                this.post_scene.add(this.post_quad);
            }

            render(renderer, writeBuffer, readBuffer) {
                // Save original scene state to restore it later.
                const originalSceneBackground = this.scene.background;
                const originalSunMaterial = this.sunObject.material;

                // --- PASS 1: RENDER OCCLUSION MASK ---
                this.scene.background = new THREE.Color(0x000000); // Black background.
                this.sunObject.material = this.occlusionMaterialWhite; // White sun.

                // Traverse all objects that should block light (occluders) and make them black.
                if (terrainMesh) {
                    terrainMesh.traverse(child => {
                        if (child.isMesh) {
                            child.userData.originalMaterial = child.material;
                            child.material = this.occlusionMaterialBlack;
                        }
                    });
                }
            
                // Render this black-and-white scene to our occlusion render target.
                renderer.setRenderTarget(this.occlusionRenderTarget);
                renderer.render(this.scene, this.camera);
                
                // --- Restore original materials and background ---
                this.sunObject.material = originalSunMaterial;
                if (terrainMesh) {
                    terrainMesh.traverse(child => {
                        if (child.isMesh && child.userData.originalMaterial) {
                            child.material = child.userData.originalMaterial;
                        }
                    });
                }
                this.scene.background = originalSceneBackground;


                // --- PASS 2: GENERATE RAYS ---
                // Update the sun's 2D screen position for the shader.
                const sunScreenPos = new THREE.Vector3().copy(this.sunObject.position).project(this.camera);
                this.godraysMaterial.uniforms.lightPosition.value.set(sunScreenPos.x, sunScreenPos.y);

                // Render the full-screen quad using the god rays shader, outputting to the god rays render target.
                renderer.setRenderTarget(this.godraysRenderTarget);
                renderer.render(this.post_scene, this.post_camera);
                
                // Reset the renderer to its default target.
                renderer.setRenderTarget(null);
            }
        }

        // --- CLASS 2: GodRaysCombinePass ---
        // A simple shader pass that takes the already-rendered scene and the god rays texture
        // and blends them together (additively) for the final image.
        class GodRaysCombinePass extends Pass {
            constructor(godraysTexture) {
                super();
                // Creates a full-screen quad with a material that uses our final compositing shader.
                this.fsQuad = new FullScreenQuad(new THREE.ShaderMaterial({
                    uniforms: {
                        tDiffuse: { value: null },           // This will be the normally rendered scene.
                        tGodRays: { value: godraysTexture }   // This is the texture of our generated rays.
                    },
                    vertexShader: godRaysVertexShader,       // We can reuse the simple vertex shader.
                    fragmentShader: finalCompositeFragmentShader // The shader that adds the two textures.
                }));
            }

            render(renderer, writeBuffer, readBuffer) {
                // The 'readBuffer' contains the output from the previous pass (the rendered scene).
                this.fsQuad.material.uniforms["tDiffuse"].value = readBuffer.texture;
                
                // Render the result to the screen or the next pass in the chain.
                if (this.renderToScreen) {
                    renderer.setRenderTarget(null);
                    this.fsQuad.render(renderer);
                } else {
                    renderer.setRenderTarget(writeBuffer);
                    if (this.clear) renderer.clear();
                    this.fsQuad.render(renderer);
                }
            }
        }


        // ===================================================================
        // 5. SETUP AND INITIALIZATION
        // ===================================================================

        // --- God Rays Effect Setup ---
        /**
         * ☀️ Sets up all the necessary components for the God Rays post-processing effect.
         */
        function setupGodRays() {
            console.log("☀️ Configuring God Rays effect (Direct Method)...");

            // --- 1. Create the 3D Sun Object ---
            const sunGeometry = new THREE.SphereGeometry(200, 32, 32); // Creates the geometry for our visual sun.
            sunMaterial = new THREE.MeshBasicMaterial({                // Creates a simple, unlit material for the sun.
                color: 0xffddaa,                                       // A warm, yellowish sun color.
                transparent: true,                                     // Allows the sun to be transparent if needed.
                fog: false                                             // Ensures the sun is not affected by scene fog.
            });
            godRaySun = new THREE.Mesh(sunGeometry, sunMaterial);      // Creates the final sun object (mesh).
            godRaySun.position.set(                                    // Positions the sun far away in the scene.
                DIRECTIONAL_LIGHT_DISTANCE, 
                DIRECTIONAL_LIGHT_DISTANCE, 
                DIRECTIONAL_LIGHT_DISTANCE
            );
            scene.add(godRaySun);                                      // Adds the sun object to the scene.
            console.log("   -> 'godRaySun' object created and positioned.");

            // --- 2. Create Render Targets ---
            const renderTargetOptions = {                              // Defines options for our off-screen render buffers.
                minFilter: THREE.LinearFilter,                         // How to sample the texture when it's smaller than the sample area.
                magFilter: THREE.LinearFilter,                         // How to sample the texture when it's larger than the sample area.
                format: THREE.RGBAFormat                               // The color format of the texture.
            };
            const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight); // Gets the current window size.
            occlusionRenderTarget = new THREE.WebGLRenderTarget(resolution.x, resolution.y, renderTargetOptions); // Creates the buffer for the occlusion mask.
            godraysRenderTarget = new THREE.WebGLRenderTarget(resolution.x, resolution.y, renderTargetOptions);   // Creates the buffer for the final rays image.
            console.log("   -> Render targets for occlusion and rays have been created.");

            // --- 3. Create Special Materials ---
            occlusionMaterialBlack = new THREE.MeshBasicMaterial({ color: 0x000000 }); // A simple black material for occluders.
            occlusionMaterialWhite = new THREE.MeshBasicMaterial({ color: 0xffffff }); // A simple white material for the sun in the occlusion pass.

            godraysMaterial = new THREE.ShaderMaterial({               // Creates the custom shader material that generates the rays.
                uniforms: {                                            // Defines variables to be passed to the shader.
                    tDiffuse: { value: occlusionRenderTarget.texture },// The occlusion mask texture.
                    lightPosition: { value: new THREE.Vector2(0.5, 0.5) }, // The 2D position of the sun on the screen.
                    sunColor: { value: new THREE.Color(0xffddaa) },    // The color of the rays.
                    density: { value: 0.7 },                           // The overall intensity.
                    decay: { value: 0.96 },                            // How quickly rays fade.
                    weight: { value: 0.4 },                            // The brightness of each sample.
                    exposure: { value: 0.4 },                          // A final brightness multiplier.
                    samples: { value: 80 }                             // The number of samples (quality).
                },
                vertexShader: godRaysVertexShader,                     // The vertex shader code.
                fragmentShader: godRaysFragmentShader                  // The fragment shader code.
            });

            // --- Material for the Final Composite ---
            // This material simply draws the generated rays texture.
            // The magic is in 'blending: THREE.AdditiveBlending', which SUMS the colors.
            finalCompositeMaterial = new THREE.MeshBasicMaterial({
                map: godraysRenderTarget.texture,                      // Uses the generated rays as its texture.
                transparent: true,                                     // Must be transparent to allow blending.
                blending: THREE.AdditiveBlending                       // The blending mode that adds light to the scene.
            });
            
            console.log("   -> Special materials for the effect have been created.");

            // --- 4. Create Post-Processing Scene ---
            // This is a simple 2D "stage" to run our full-screen shaders.
            post_scene = new THREE.Scene();                            // A new, separate scene.
            post_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1); // An orthographic camera that perfectly covers the screen.
            post_quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), godraysMaterial); // A plane that fills the screen, initially using the ray-generating material.
            post_scene.add(post_quad);                                 // Adds the plane to the post-processing scene.
            console.log("   -> Post-processing scene created.");

            console.log("✅ God Rays setup (Direct Method) complete.");
        }

        /**
         * 🛠️ Prepares the entire game scene after all assets are loaded,
         * but before the game loop starts. This includes setting up materials,
         * controls, UI, and the static terrain.
         */
        function prepareGameScene() {
            try {
                console.log("🛠️ Preparing game scene with pre-loaded assets...");
                const instructions = document.getElementById('instructions');

                // =================================================================================
                // ✨ SHADER MATERIAL CONFIGURATION ✨
                // Creates all custom shader materials that will be applied to the models.
                // =================================================================================
                console.log("✨ Configuring all shader materials...");

                // --- Tiling Caustics Material - Set 1 ---
                const shaderUniformsCausticsSet1 = THREE.UniformsUtils.merge([ // Merges standard uniforms with our custom ones.
                    THREE.UniformsLib.logdepthbuf,                             // Includes uniforms for logarithmic depth buffer.
                    {
                        time: { value: 0.0 },                                  // A time uniform for animation.
                        resolution: { value: new THREE.Vector2(30.0, 20.0) },  // Controls the tiling scale of the effect.
                        backgroundColor_1746463289601_38: { value: new THREE.Color(0x00ffff) }, // Base color.
                        color: { value: new THREE.Color(0xff00ff) },           // Highlight color.
                        speed_1746463289601_38: { value: 0.1 },                // Animation speed.
                        flowSpeed_1746463289601_38: { value: new THREE.Vector2(0.00, 0.00) }, // Flow direction.
                        brightness: { value: 1.5 }                             // Effect brightness/contrast.
                    }
                ]);
                causticsMaterialSet1 = new THREE.ShaderMaterial({              // Creates the final shader material object.
                    uniforms: shaderUniformsCausticsSet1,                      // Assigns the uniforms.
                    vertexShader: vertexShaderCaustics,                        // Assigns the vertex shader code.
                    fragmentShader: fragmentShaderCaustics,                    // Assigns the fragment shader code.
                    glslVersion: THREE.GLSL3,                                  // Specifies the GLSL version.
                    transparent: true,                                         // Allows the material to be transparent.
                    defines: { 'USE_LOGDEPTHBUF': '', 'USE_LOGDEPTHBUF_EXT': '' } // Defines for depth buffer compatibility.
                });

                // --- Tiling Caustics Material - Set 2 ---
                const shaderUniformsCausticsSet2 = THREE.UniformsUtils.merge([
                    THREE.UniformsLib.logdepthbuf,
                    {
                        time: { value: 0.0 },
                        resolution: { value: new THREE.Vector2(100.0, 30.0) },
                        backgroundColor_1746463289601_38: { value: new THREE.Color(0xff00ff) },
                        color: { value: new THREE.Color(0x00ffff) },
                        speed_1746463289601_38: { value: 0.05 },
                        flowSpeed_1746463289601_38: { value: new THREE.Vector2(0.00, 0.00) },
                        brightness: { value: 1.5 }
                    }
                ]);
                causticsMaterialSet2 = new THREE.ShaderMaterial({
                    uniforms: shaderUniformsCausticsSet2,
                    vertexShader: vertexShaderCaustics,
                    fragmentShader: fragmentShaderCaustics,
                    glslVersion: THREE.GLSL3,
                    transparent: true,
                    defines: { 'USE_LOGDEPTHBUF': '', 'USE_LOGDEPTHBUF_EXT': '' }
                });

                // --- Tiling Caustics Material - Set 3 ---
                const shaderUniformsCausticsSet3 = THREE.UniformsUtils.merge([
                    THREE.UniformsLib.logdepthbuf,
                    {
                        time: { value: 0.0 },
                        resolution: { value: new THREE.Vector2(25.0, 1.0) },
                        backgroundColor_1746463289601_38: { value: new THREE.Color(0x943b00) },
                        color: { value: new THREE.Color(0xffffff) },
                        speed_1746463289601_38: { value: 0.05 },
                        flowSpeed_1746463289601_38: { value: new THREE.Vector2(0.00, 0.00) },
                        brightness: { value: 1.5 }
                    }
                ]);
                causticsMaterialSet3 = new THREE.ShaderMaterial({
                    uniforms: shaderUniformsCausticsSet3,
                    vertexShader: vertexShaderCaustics,
                    fragmentShader: fragmentShaderCaustics,
                    glslVersion: THREE.GLSL3,
                    transparent: true,
                    defines: { 'USE_LOGDEPTHBUF': '', 'USE_LOGDEPTHBUF_EXT': '' }
                });

                // --- Tiling Caustics Material - Set 4 ---
                const shaderUniformsCausticsSet4 = THREE.UniformsUtils.merge([
                    THREE.UniformsLib.logdepthbuf,
                    {
                        time: { value: 0.0 },
                        resolution: { value: new THREE.Vector2(100.0, 100.0) },
                        backgroundColor_1746463289601_38: { value: new THREE.Color(0x00ffff) }, // Cyan color.
                        color: { value: new THREE.Color(0xff00ff) }, // Magenta color.
                        speed_1746463289601_38: { value: 0.1 },
                        flowSpeed_1746463289601_38: { value: new THREE.Vector2(0.00, 0.00) },
                        brightness: { value: 1.5 }
                    }
                ]);
                causticsMaterialSet4 = new THREE.ShaderMaterial({
                    uniforms: shaderUniformsCausticsSet4,
                    vertexShader: vertexShaderCaustics,
                    fragmentShader: fragmentShaderCaustics,
                    glslVersion: THREE.GLSL3,
                    transparent: true,
                    defines: { 'USE_LOGDEPTHBUF': '', 'USE_LOGDEPTHBUF_EXT': '' }
                });

                console.log("✅ All shader materials created.");

                // --- General Scene and Control Setup ---
                setupLights();                  // Sets up the main directional and ambient lights.
                setupGodRays();                 // Sets up the components for the god rays effect.
                setupPostProcessing();          // Sets up the main effect composer chain (AA, pixelation, etc.).
                setupControls();                // Sets up the PointerLockControls for the camera.
                
                // --- Process Terrain (Visual and Physics) ---
                // This is done here because the terrain is static and common to all game modes.
                setupTerrainFromGltf(terrainGltf);

                // --- Finalize UI and Input Setup ---
                initStrafeVisuals_mainGame();   // Initializes the SVG elements for the strafe indicator.
                setupInputListeners();          // Attaches all keyboard and mouse event listeners.
                window.addEventListener('resize', onWindowResize); // Adds the listener for window resizing.
                document.body.addEventListener('contextmenu', (event) => { // Prevents the right-click context menu from appearing in-game.
                    if (isPaused) return;
                    if (controls && controls.isLocked) event.preventDefault();
                });


                // --- Race Menu References (from the Playground Menu) ---
                playgroundMenu = document.getElementById('playgroundMenu');
                raceSetupMenu = document.getElementById('raceSetupMenu');
                soloRaceConfigMenu = document.getElementById('soloRaceConfigMenu');
                portalPlacementHint = document.getElementById('portalPlacementHint');
                raceStatusMessage = document.getElementById('raceStatusMessage');

                // =================================================================================
                // ⏸️ COMPLETE PAUSE MENU CONFIGURATION 
                // All pause menu UI logic is configured here.
                // =================================================================================
                console.log("⏸️ Configuring all Pause Menu elements...");
                
                // --- General Menu References ---
                pauseMenuElement = document.getElementById('pauseMenu');
                returnButton = document.getElementById('returnButton');

                // --- Option: Render Style ---
                renderStyleValueElement = document.getElementById('renderStyleValue');
                renderStylePrevButton = document.getElementById('renderStylePrev');
                renderStyleNextButton = document.getElementById('renderStyleNext');

                // --- Option: Antialiasing ---
                aaValueElement = document.getElementById('aaValue');
                aaPrevButton = document.getElementById('aaPrev');
                aaNextButton = document.getElementById('aaNext');
                
                // --- Option: Podracer Mouse Flight Mode ---
                podracerMouseFlightModeOptionElement = document.getElementById('podracerMouseFlightModeOption');
                podracerMouseFlightModeValueElement = document.getElementById('podracerMouseFlightModeValue');
                podracerMouseFlightModePrevButton = document.getElementById('podracerMouseFlightModePrev');
                podracerMouseFlightModeNextButton = document.getElementById('podracerMouseFlightModeNext');
                
                // --- Option: Podracer Mouse Ground Mode ---
                podracerMouseSoloModeOptionElement = document.getElementById('podracerMouseSoloModeOption');
                podracerMouseSoloModeValueElement = document.getElementById('podracerMouseSoloModeValue');
                podracerMouseSoloModePrevButton = document.getElementById('podracerMouseSoloModePrev');
                podracerMouseSoloModeNextButton = document.getElementById('podracerMouseSoloModeNext');

                // --- Option: W/S Acceleration (Pod Ground) ---
                podracerSoloWSAccelModeOptionElement = document.getElementById('podracerSoloWSAccelModeOption');
                podracerSoloWSAccelModeValueElement = document.getElementById('podracerSoloWSAccelModeValue');
                podracerSoloWSAccelModePrevButton = document.getElementById('podracerSoloWSAccelModePrev');
                podracerSoloWSAccelModeNextButton = document.getElementById('podracerSoloWSAccelModeNext');
                
                // --- Option: Arrow Acceleration (Pod) ---
                podracerArrowsAccelModeOptionElement = document.getElementById('podracerArrowsAccelModeOption');
                podracerArrowsAccelModeValueElement = document.getElementById('podracerArrowsAccelModeValue');
                podracerArrowsAccelModePrevButton = document.getElementById('podracerArrowsAccelModePrev');
                podracerArrowsAccelModeNextButton = document.getElementById('podracerArrowsAccelModeNext');

                // --- Option: Ground Key Controls (Pod) ---
                podracerSoloKeyControlModeOptionElement = document.getElementById('podracerSoloKeyControlModeOption');
                podracerSoloKeyControlModeValueElement = document.getElementById('podracerSoloKeyControlModeValue');
                podracerSoloKeyControlModePrevButton = document.getElementById('podracerSoloKeyControlModePrev');
                podracerSoloKeyControlModeNextButton = document.getElementById('podracerSoloKeyControlModeNext');

                // --- Option: Max Speed (Pod) ---
                podracerMaxSpeedOptionElement = document.getElementById('podracerMaxSpeedOption');
                podracerMaxSpeedValueElement = document.getElementById('podracerMaxSpeedValue');
                podracerMaxSpeedPrevButton = document.getElementById('podracerMaxSpeedPrev');
                podracerMaxSpeedNextButton = document.getElementById('podracerMaxSpeedNext');

                // --- Option: Camera Roll (Pod Ground) ---
                const podracerSoloCameraRollOptionElement = document.getElementById('podracerSoloCameraRollOption');
                const podracerSoloCameraRollValueElement = document.getElementById('podracerSoloCameraRollValue');
                const podracerSoloCameraRollPrevButton = document.getElementById('podracerSoloCameraRollPrev');
                const podracerSoloCameraRollNextButton = document.getElementById('podracerSoloCameraRollNext');

                // --- Option: Dynamic Pixelation ---
                pixelationOptionElement = document.getElementById('pixelationOption');
                pixelationValueElement = document.getElementById('pixelationValue');
                pixelationPrevButton = document.getElementById('pixelationPrev');
                pixelationNextButton = document.getElementById('pixelationNext');

                // --- Outline Element References ---
                const outlineEnabledValueElement = document.getElementById('outlineEnabledValue');
                const outlineEnabledPrevButton = document.getElementById('outlineEnabledPrev');
                const outlineEnabledNextButton = document.getElementById('outlineEnabledNext');
                const outlineColorValueElement = document.getElementById('outlineColorValue');
                const outlineColorPrevButton = document.getElementById('outlineColorPrev');
                const outlineColorNextButton = document.getElementById('outlineColorNext');

                // --- Add Pause Menu Event Listeners ---               
                // Render Style
                renderStylePrevButton.addEventListener('click', () => {
                    let i = RENDER_STYLES.indexOf(currentRenderStyle);
                    applyRenderStyle(RENDER_STYLES[(i - 1 + RENDER_STYLES.length) % RENDER_STYLES.length]);
                });
                renderStyleNextButton.addEventListener('click', () => {
                    let i = RENDER_STYLES.indexOf(currentRenderStyle);
                    applyRenderStyle(RENDER_STYLES[(i + 1) % RENDER_STYLES.length]);
                });

                // Antialiasing
                aaPrevButton.addEventListener('click', () => {
                    let i = AA_LEVELS.indexOf(currentAALevel);
                    applyAALevel(AA_LEVELS[(i - 1 + AA_LEVELS.length) % AA_LEVELS.length]);
                });
                aaNextButton.addEventListener('click', () => {
                    let i = AA_LEVELS.indexOf(currentAALevel);
                    applyAALevel(AA_LEVELS[(i + 1) % AA_LEVELS.length]);
                });

                // Dynamic Pixelation
                pixelationPrevButton.addEventListener('click', () => applyPixelationMode(!isPixelationActive));
                pixelationNextButton.addEventListener('click', () => applyPixelationMode(!isPixelationActive));


                // --- Listeners for enabling/disabling the outline ---
                outlineEnabledPrevButton.addEventListener('click', () => applyOutlineEnabled(!isOutlineEnabled));
                outlineEnabledNextButton.addEventListener('click', () => applyOutlineEnabled(!isOutlineEnabled));

                // --- Listeners for changing the outline color ---
                const colorNames = Object.keys(OUTLINE_COLORS_MAP); // Gets the list of color names: ['Black', 'White', ...]
                
                outlineColorPrevButton.addEventListener('click', () => {
                    let currentIndex = colorNames.indexOf(currentOutlineColorName);
                    let newIndex = (currentIndex - 1 + colorNames.length) % colorNames.length;
                    applyOutlineColor(colorNames[newIndex]);
                });

                outlineColorNextButton.addEventListener('click', () => {
                    let currentIndex = colorNames.indexOf(currentOutlineColorName);
                    let newIndex = (currentIndex + 1) % colorNames.length;
                    applyOutlineColor(colorNames[newIndex]);
                });

                // Mouse Flight Mode (Pod)
                const MOUSE_FLIGHT_MODES = Object.values(PODRACER_MOUSE_FLIGHT_MODE);
                podracerMouseFlightModePrevButton.addEventListener('click', () => {
                    let i = MOUSE_FLIGHT_MODES.indexOf(currentPodracerMouseFlightMode);
                    applyPodracerMouseFlightMode(MOUSE_FLIGHT_MODES[(i - 1 + MOUSE_FLIGHT_MODES.length) % MOUSE_FLIGHT_MODES.length]);
                });
                podracerMouseFlightModeNextButton.addEventListener('click', () => {
                    let i = MOUSE_FLIGHT_MODES.indexOf(currentPodracerMouseFlightMode);
                    applyPodracerMouseFlightMode(MOUSE_FLIGHT_MODES[(i + 1) % MOUSE_FLIGHT_MODES.length]);
                });

                // Mouse Ground Mode (Pod)
                const MOUSE_SOLO_MODES = Object.values(PODRACER_MOUSE_SOLO_MODE);
                podracerMouseSoloModePrevButton.addEventListener('click', () => {
                    let i = MOUSE_SOLO_MODES.indexOf(currentPodracerMouseSoloMode);
                    applyPodracerMouseSoloMode(MOUSE_SOLO_MODES[(i - 1 + MOUSE_SOLO_MODES.length) % MOUSE_SOLO_MODES.length]);
                });
                podracerMouseSoloModeNextButton.addEventListener('click', () => {
                    let i = MOUSE_SOLO_MODES.indexOf(currentPodracerMouseSoloMode);
                    applyPodracerMouseSoloMode(MOUSE_SOLO_MODES[(i + 1) % MOUSE_SOLO_MODES.length]);
                });
                
                // W/S Acceleration Mode (Pod Ground)
                const SOLO_WS_ACCEL_MODES = Object.values(PODRACER_SOLO_WS_ACCEL_MODE);
                podracerSoloWSAccelModePrevButton.addEventListener('click', () => {
                    let i = SOLO_WS_ACCEL_MODES.indexOf(currentPodracerSoloWSAccelMode);
                    applyPodracerSoloWSAccelMode(SOLO_WS_ACCEL_MODES[(i - 1 + SOLO_WS_ACCEL_MODES.length) % SOLO_WS_ACCEL_MODES.length]);
                });
                podracerSoloWSAccelModeNextButton.addEventListener('click', () => {
                    let i = SOLO_WS_ACCEL_MODES.indexOf(currentPodracerSoloWSAccelMode);
                    applyPodracerSoloWSAccelMode(SOLO_WS_ACCEL_MODES[(i + 1) % SOLO_WS_ACCEL_MODES.length]);
                });

                // Arrow Acceleration Mode (Pod)
                const ARROWS_ACCEL_MODES = Object.values(PODRACER_ARROWS_ACCEL_MODE);
                podracerArrowsAccelModePrevButton.addEventListener('click', () => {
                    let i = ARROWS_ACCEL_MODES.indexOf(currentPodracerArrowsAccelMode);
                    applyPodracerArrowsAccelMode(ARROWS_ACCEL_MODES[(i - 1 + ARROWS_ACCEL_MODES.length) % ARROWS_ACCEL_MODES.length]);
                });
                podracerArrowsAccelModeNextButton.addEventListener('click', () => {
                    let i = ARROWS_ACCEL_MODES.indexOf(currentPodracerArrowsAccelMode);
                    applyPodracerArrowsAccelMode(ARROWS_ACCEL_MODES[(i + 1) % ARROWS_ACCEL_MODES.length]);
                });

                // Ground Key Controls (Pod)
                const SOLO_KEY_MODES = Object.values(PODRACER_SOLO_KEY_CONTROL_MODE);
                podracerSoloKeyControlModePrevButton.addEventListener('click', () => {
                    let i = SOLO_KEY_MODES.indexOf(currentPodracerSoloKeyControlMode);
                    applyPodracerSoloKeyControlMode(SOLO_KEY_MODES[(i - 1 + SOLO_KEY_MODES.length) % SOLO_KEY_MODES.length]);
                });
                podracerSoloKeyControlModeNextButton.addEventListener('click', () => {
                    let i = SOLO_KEY_MODES.indexOf(currentPodracerSoloKeyControlMode);
                    applyPodracerSoloKeyControlMode(SOLO_KEY_MODES[(i + 1) % SOLO_KEY_MODES.length]);
                });
                
                // Max Speed (Pod)
                podracerMaxSpeedPrevButton.addEventListener('click', () => {
                    let newSpeed = Math.max(PODRACER_MIN_ADJUSTABLE_MAX_SPEED_KMH, currentPodracerAdjustableMaxSpeedKmh - PODRACER_SPEED_ADJUSTMENT_STEP_KMH);
                    applyPodracerMaxSpeed(newSpeed);
                });
                podracerMaxSpeedNextButton.addEventListener('click', () => {
                    let newSpeed = Math.min(PODRACER_MAX_ADJUSTABLE_MAX_SPEED_KMH, currentPodracerAdjustableMaxSpeedKmh + PODRACER_SPEED_ADJUSTMENT_STEP_KMH);
                    applyPodracerMaxSpeed(newSpeed);
                });
                
                // Camera Roll (Pod Ground)
                podracerSoloCameraRollPrevButton.addEventListener('click', () => applyPodracerSoloCameraRollMode(!isPodracerSoloCameraRollEnabled));
                podracerSoloCameraRollNextButton.addEventListener('click', () => applyPodracerSoloCameraRollMode(!isPodracerSoloCameraRollEnabled));

                // Return Button
                returnButton.addEventListener('click', () => { if (isPaused) togglePause(); });

                // --- Apply Initial Values to Menus ---
                applyAALevel(currentAALevel);
                applyPixelationMode(isPixelationActive);
                applyPodracerMouseFlightMode(currentPodracerMouseFlightMode);
                applyPodracerMouseSoloMode(currentPodracerMouseSoloMode);
                applyPodracerSoloWSAccelMode(currentPodracerSoloWSAccelMode);
                applyPodracerArrowsAccelMode(currentPodracerArrowsAccelMode);
                applyPodracerSoloKeyControlMode(currentPodracerSoloKeyControlMode);
                applyPodracerMaxSpeed(currentPodracerAdjustableMaxSpeedKmh);
                applyPodracerSoloCameraRollMode(isPodracerSoloCameraRollEnabled);
                applyOutlineEnabled(isOutlineEnabled);
                applyOutlineColor(currentOutlineColorName);
                console.log("✅ All menus and listeners have been configured.");

                // =================================================================================
                // 👁️ INITIALIZATION OF PODRACER "V" VISUAL INDICATORS 👁️
                // =================================================================================
                console.log("👁️ Initializing Podracer 'V' visual indicators...");

                // --- Get DOM Element References ---
                podracerMouseYawIndicatorElement = document.getElementById('podracerMouseYawIndicator');
                podracerMouseIndicatorElementGlobalRef = podracerMouseYawIndicatorElement;
                staticLeftVElement = document.getElementById('podracerStaticLeftV');
                staticRightVElement = document.getElementById('podracerStaticRightV');
                staticLeftVShape = document.getElementById('staticLeftVShape');
                staticRightVShape = document.getElementById('staticRightVShape');
                leftArrowEffectContainer = document.getElementById('podracerLeftArrowEffectContainer');
                rightArrowEffectContainer = document.getElementById('podracerRightArrowEffectContainer');
                podracerMousePitchIndicatorElement = document.getElementById('podracerMousePitchIndicator');
                staticTopVElement = document.getElementById('podracerStaticTopV');
                staticBottomVElement = document.getElementById('podracerStaticBottomV');
                staticTopVShape = document.getElementById('staticTopVShape');
                staticBottomVShape = document.getElementById('staticBottomVShape');
                topArrowEffectContainer = document.getElementById('podracerTopArrowEffectContainer');
                bottomArrowEffectContainer = document.getElementById('podracerBottomArrowEffectContainer');

                // --- Configure and create instances of the ConveyorArrowEffect ---
                const conveyorArrowConfigBase = {};
                leftArrowEffectInstance = new ConveyorArrowEffect(leftArrowEffectContainer, { ...conveyorArrowConfigBase, overallDirection: 'left', reversePath: false, });
                rightArrowEffectInstance = new ConveyorArrowEffect(rightArrowEffectContainer, { ...conveyorArrowConfigBase, overallDirection: 'right', reversePath: false, });
                topArrowEffectInstance = new ConveyorArrowEffect(topArrowEffectContainer, { ...conveyorArrowConfigBase, overallDirection: 'up', });
                bottomArrowEffectInstance = new ConveyorArrowEffect(bottomArrowEffectContainer, { ...conveyorArrowConfigBase, overallDirection: 'down', });
                console.log("   -> ✅ All ConveyorArrowEffect instances created.");
                
                // --- Apply initial render style and update UI ---
                applyRenderStyle(currentRenderStyle);
                instructions.innerHTML = "Loading complete. Please select a game mode.";
                updateCursorAndIndicators();
                
                // --- Set up lobby UI listeners at the end of preparation ---
                setupLobbyUIAndListeners();

                // --- Set up race menu listeners ---
                setupRaceMenuListeners();

            } catch (error) {
                console.error("💥 CRITICAL FAILURE during scene preparation (prepareGameScene):", error);
                document.getElementById('instructions').innerHTML = `Error preparing scene: ${error.message}.`;
                document.getElementById('instructions').style.backgroundColor = "red";
            }
        }

        /**
         * 🔗 Attaches all necessary event listeners for the multiplayer lobby UI.
         */
        function setupLobbyUIAndListeners() {
            console.log("🔗 Configuring UI listeners for the Lobby...");

            // --- Get DOM Element References ---
            const lobbyScreen = document.getElementById('lobby-screen');
            const hostScreen = document.getElementById('host-screen');
            const guestScreen = document.getElementById('guest-screen');
            const hostBtn = document.getElementById('host-btn');
            const guestBtn = document.getElementById('guest-btn');
            const backToSplashBtn = document.getElementById('back-to-splash-btn');
            const hostIdDisplay = document.getElementById('host-id-display');
            const startMultiplayerGameBtn = document.getElementById('start-multiplayer-game-btn');
            const backToLobbyBtnHost = document.getElementById('back-to-lobby-btn-host');
            const hostIdInput = document.getElementById('host-id-input');
            const checkInBtn = document.getElementById('check-in-btn');
            const guestStatusMessage = document.getElementById('guest-status-message');
            const joinMultiplayerGameBtn = document.getElementById('join-multiplayer-game-btn');
            const backToLobbyBtnGuest = document.getElementById('back-to-lobby-btn-guest');

            // --- "Become Host" Button Logic ---
            hostBtn.addEventListener('click', () => {
                lobbyScreen.style.display = 'none';
                hostScreen.style.display = 'flex';
                currentNetworkRole = NetworkRole.HOST;
                initializePeerAsHost();
            });

            // --- "Join Game" Button Logic ---
            guestBtn.addEventListener('click', () => {
                lobbyScreen.style.display = 'none';
                guestScreen.style.display = 'flex';
                currentNetworkRole = NetworkRole.GUEST;
                initializePeerAsGuest();
            });
            
            // --- Guest's "Check IN" Button Logic ---
            checkInBtn.addEventListener('click', () => {
                const hostId = hostIdInput.value.trim();
                if (hostId) {
                    guestStatusMessage.textContent = `Attempting to connect to Host: ${hostId}...`;
                    guestStatusMessage.style.color = 'yellow';
                    connectToHost(hostId);
                } else {
                    guestStatusMessage.textContent = 'Please enter a valid Host ID.';
                    guestStatusMessage.style.color = 'red';
                }
            });
            
            // --- Host's "Start Game" Button Logic ---
            startMultiplayerGameBtn.addEventListener('click', () => {
                isLobbyOpen = false; // Closes the lobby to new players.
                console.log("🚪 Lobby closed by Host. Starting game...");

                // Sends the start signal to all connected guests.
                const startPacket = { type: 'start_game' };
                for (const conn of connections.values()) {
                    conn.send(startPacket);
                }
                // Starts the game for the host as well.
                startMultiplayerGame();
            });
            
            // --- Back Button Logic ---
            backToSplashBtn.addEventListener('click', () => {
                lobbyScreen.style.display = 'none';
                splashScreen.style.display = 'flex';
                currentGlobalMode = GameMode.SPLASH;
                currentNetworkRole = NetworkRole.NONE;
            });

            // --- "Back to Lobby" Logic (shared by Host and Guest) ---
            const goBackToLobby = () => {
                isLobbyOpen = true; // Re-opens the lobby for new sessions.
                if (peer) { // Disconnects and cleans up the PeerJS instance.
                    peer.destroy();
                    peer = null;
                }
                connections.clear(); // Clears all active connections.
                hostScreen.style.display = 'none';
                guestScreen.style.display = 'none';
                lobbyScreen.style.display = 'flex';
                currentNetworkRole = NetworkRole.NONE;
                hostIdDisplay.textContent = 'Waiting for network ID...';
                document.getElementById('connected-players-list').innerHTML = '';
                guestStatusMessage.textContent = 'Waiting for ID...';
            };
            backToLobbyBtnHost.addEventListener('click', goBackToLobby);
            backToLobbyBtnGuest.addEventListener('click', goBackToLobby);
            
            // --- Copy Host ID on Click ---
            hostIdDisplay.addEventListener('click', () => {
                if (hostIdDisplay.textContent.includes('Waiting')) return;
                navigator.clipboard.writeText(hostIdDisplay.textContent)
                    .then(() => {
                        console.log('Host ID copied to clipboard!');
                    })
                    .catch(err => console.error('Failed to copy ID: ', err));
            });
        }

        /**
         * 🎮 Handles the user's choice from the main menu (Single Player or Multiplayer).
         * @param {string} choice - The choice made by the user ('single' or 'multi').
         */
        function handleMenuChoice(choice) {
            if (choice === 'single') {
                console.log("Selected option: Single Player");
                currentGlobalMode = GameMode.GAME_SINGLE_PLAYER;
                currentNetworkRole = NetworkRole.NONE;
                splashScreen.style.display = 'none';
                document.getElementById('instructions').style.display = 'block';
                startGame(); // Starts the game in single-player mode.
            } else if (choice === 'multi') {
                console.log("Selected option: Multiplayer");
                currentGlobalMode = GameMode.LOBBY;
                splashScreen.style.display = 'none';
                document.getElementById('lobby-screen').style.display = 'flex';
            }
        }

        // ===========================================================================
        // 🚀 The main entry point of the application. It sets up the loading manager,
        // initializes the physics engine, and starts loading all assets.
        // ===========================================================================
        function init() {
            // --- 1. Initialize the Virtual Console Immediately ---
            virtualConsoleBox = document.getElementById('virtual-console-box');
            setupVirtualConsole(); // Overwrites console.log, .warn, .error to also print to the screen.

            console.log("🚀 Initializing application...");
            
            // --- 2. Get References to Splash Screen Elements ---
            splashScreen = document.getElementById('splash-screen');
            menuButtons = document.getElementById('menu-buttons');
            singlePlayerBtn = document.getElementById('single-player-btn');
            multiplayerBtn = document.getElementById('multiplayer-btn');
            loadingContainer = document.getElementById('loading-container');
            progressBar = document.getElementById('loading-progress-bar');
            progressText = document.getElementById('loading-progress-text');

            // --- Attach Main Menu Button Listeners ---
            singlePlayerBtn.addEventListener('click', () => handleMenuChoice('single'));
            multiplayerBtn.addEventListener('click', () => handleMenuChoice('multi'));
            
            const instructions = document.getElementById('instructions');
            
            // --- 3. Configure the LoadingManager ---
            console.log("... Configuring LoadingManager...");
            const loadingManager = new THREE.LoadingManager();

            // Called when loading starts.
            loadingManager.onStart = (url, itemsLoaded, itemsTotal) => {
                console.log(`🏁 Started loading ${itemsTotal} files.`);
                progressBar.style.width = '0%';
                progressText.textContent = `Loading... 0%`;
            };

            // Called as each file is loaded.
            loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
                const progress = Math.round((itemsLoaded / itemsTotal) * 100);
                console.log(`... Loading file: ${url} (${itemsLoaded}/${itemsTotal})`);
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `Loading... ${progress}%`;
            };

            // Called when all files have been loaded successfully.
            loadingManager.onLoad = () => {
                console.log("✅ All files loaded successfully!");
                prepareGameScene(); // Prepare the game scene now that assets are ready.
                console.log("🎮 Game ready. Awaiting user interaction in the menu.");
                // Hide loading elements and show menu buttons.
                if (loadingContainer) loadingContainer.style.display = 'none';
                if (menuButtons) menuButtons.style.display = 'flex';
            };

            // Called if any file fails to load.
            loadingManager.onError = (url) => {
                console.error(`CRITICAL FAILURE while loading resource: ${url}.`);
                const progressBarContainer = document.getElementById('loading-progress-bar-container');
                if (progressBarContainer) {
                    progressBarContainer.style.display = 'none';
                }
                if (progressText) {
                    progressText.innerHTML = `Error loading.<br/>Please reload the page (CTRL+R or F5).`;
                    progressText.style.color = '#ff6b6b';
                }
            };

            // --- 4. Configure Basic Scene and Physics ---
            console.log("... Configuring Rapier physics world...");
            RAPIER.init().then(() => { // RAPIER.init() is asynchronous.
                console.log("✅ Rapier initialized:", RAPIER.version());
                physicsWorld = new RAPIER.World(GRAVITY);
                integrationParameters = physicsWorld.integrationParameters;
                integrationParameters.dt = PHYSICS_TIMESTEP;
                integrationParameters.ccdEnabled = ENABLE_CCD;
                eventQueue = new RAPIER.EventQueue(true);

                // --- 5. Start Loading All Assets ---
                console.log("... Starting load of all GLB and HDR models...");

                // --- CONFIGURAÇÃO DO CARREGADOR DRACO ---
                // 1. Crie uma instância do DRACOLoader, passando o loadingManager.
                const dracoLoader = new DRACOLoader(loadingManager);

                // 2. Aponte para a pasta com os arquivos decodificadores do Draco.
                //    Esses arquivos são a "mágica" que descompacta a geometria.
                //    Usaremos a versão oficial hospedada pelo Google/Three.js para simplificar.
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                
                // 3. Crie o GLTFLoader como antes.
                const gltfLoader = new GLTFLoader(loadingManager);

                // 4. INFORME ao GLTFLoader para USAR o dracoLoader que configuramos.
                //    Esta é a linha mais importante!
                gltfLoader.setDRACOLoader(dracoLoader);
                // --- FIM DA CONFIGURAÇÃO DRACO ---

                const rgbeLoader = new RGBELoader(loadingManager);

                // Load the HDR environment map.
                const hdrUrl = "assets/models/golden-gate-hills-1k.hdr";
                rgbeLoader.load(hdrUrl, (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture;
                    console.log("HDR loaded and applied.");
                });

                // Load all game models.
                gltfLoader.load(TERRAIN_GLB_URL, (gltf) => { terrainGltf = gltf; });
                gltfLoader.load(PODRACER_GLB_URL, (gltf) => { podracerVisualGltf = gltf; });
                gltfLoader.load(PODRACER_COLLIDER_GLB_URL, (gltf) => { podracerColliderGltf = gltf; });
                gltfLoader.load(AJAXSON_GLB_URL, (gltf) => { ajaxsonGltf = gltf; });
                
            }).catch(error => {
                console.error("💥 CRITICAL FAILURE on Rapier initialization:", error);
                instructions.innerHTML = `Rapier Error: ${error.message}.`;
                instructions.style.backgroundColor = "red";
            });

            // --- 6. Configure Renderer and Scene (can be done before loading finishes) ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(BACKGROUND_COLOR);
            camera = new THREE.PerspectiveCamera(CAMERA_FOV, window.innerWidth / window.innerHeight, CAMERA_NEAR, CAMERA_FAR);
            renderer = new THREE.WebGLRenderer({ 
                antialias: false,                    // Antialiasing is handled by post-processing passes.
                logarithmicDepthBuffer: true         // Helps prevent z-fighting in large scenes.
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // A high-quality tone mapping for more realistic lighting.
            renderer.toneMappingExposure = 0.6;
            document.body.appendChild(renderer.domElement);
            hudInfoElement = document.getElementById('hudInfo');

            // --- Get references to the 2D UI canvas ---
            uiCanvas = document.getElementById('ui-canvas');
            uiContext = uiCanvas.getContext('2d');

            // --- Initialize debug monitors ---
            setupNetworkStatsMonitor();
            setupFpsMonitor();
        }

        /**
         * 🏁 Starts a single-player game session.
         */
        function startGame() {
            console.log("🏁 Starting Game (Single Player Mode)...");
            isGameStarted = true;

            // 1. Define a local ID for the single player.
            localPlayerId = `single_player_${Math.random().toString(36).substr(2, 5)}`;
            console.log(`Local player ID set to: ${localPlayerId}`);

            // 2. Create the local player with a default name.
            const localPlayer = createPlayer(localPlayerId, true, INITIAL_PLAYER_POS, 'Player_1');

            // 3. Create debug helpers specific to the local player.
            const capsuleHalfHeight = PLAYER_HEIGHT / 2 - PLAYER_RADIUS;
            const capsuleGeometry = new THREE.CapsuleGeometry(PLAYER_RADIUS, capsuleHalfHeight * 2, 8, 16);
            const capsuleMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.5 });
            playerCapsuleHelper = new THREE.Mesh(capsuleGeometry, capsuleMaterial);
            playerCapsuleHelper.visible = false; 
            scene.add(playerCapsuleHelper);
        
            const numRays = 5;
            for (let i = 0; i < numRays; i++) {
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({ vertexColors: false, depthTest: false, renderOrder: 999 });
                const line = new THREE.Line(geometry, material);
                line.visible = false;
                playerGroundRayHelpers.push(line);
                scene.add(line);
            }
            console.log("🐛 Player debug helpers created in startGame.");

            // 4. Pre-compile shaders to prevent stutter on first appearance of models.
            console.log("⚡ Forcing OPTIMIZED pre-compilation of Ajaxson and Podracer shaders...");
            if (localPlayer && localPlayer.model) { 
                localPlayer.model.visible = true;
                renderer.compile(localPlayer.model, camera);
                localPlayer.model.visible = false; // Hide again after compilation.
            }
            if (localPlayer && localPlayer.vehicle && localPlayer.vehicle.mesh) { 
                localPlayer.vehicle.mesh.visible = true;
                renderer.compile(localPlayer.vehicle.mesh, camera);
                localPlayer.vehicle.mesh.visible = false; // Hide again after compilation.
            }
            console.log("   -> ✅ Shaders efficiently pre-compiled.");

            // 5. Update UI and indicators for the initial game state.
            updateInstructions();
            updateCursorAndIndicators();
            updatePlayerFPSCamera(localPlayer.body);

            // 6. Lock the mouse pointer to begin game control.
            if (controls) {
                setTimeout(() => { 
                    controls.lock(); 
                }, 100);
            }
        }

        // ==========================================
        // 🏭 PLAYER FACTORY
        // Creates a complete player object with physics, visuals, and state.
        // ==========================================
        /**
         * @param {string} playerId - The unique identifier for this player.
         * @param {boolean} isLocal - True if this is the locally controlled player.
         * @param {object} initialPos - The initial {x, y, z} spawn position.
         * @param {string} displayName - The display name for the player.
         */
        function createPlayer(playerId, isLocal, initialPos, displayName) {
            console.log(`🏭 Creating complete player: ID=${playerId}, Local=${isLocal}, Name=${displayName || 'undefined (will use fallback)'}`);
            
            if (!displayName) { // Provides a fallback name if one isn't given.
                playerCounter++; 
            }

            // --- 1. CREATE CHARACTER (AJAXSON) ---
            let playerRigidBodyDesc;
            let playerColliderDesc;
            const capsuleHalfHeight = PLAYER_HEIGHT / 2 - PLAYER_RADIUS;

            // Differentiates physics setup for local vs. remote players.
            if (isLocal) {
                // LOCAL PLAYER: Dynamic body with a SOLID collider. It needs to physically interact with the world.
                playerRigidBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(initialPos.x, initialPos.y, initialPos.z).setGravityScale(1.0).setCanSleep(false).lockRotations().setCcdEnabled(true).setLinearDamping(PLAYER_LINEAR_DAMPING);
                playerColliderDesc = RAPIER.ColliderDesc.capsule(capsuleHalfHeight, PLAYER_RADIUS)
                    .setDensity(PLAYER_DENSITY)
                    .setFriction(PLAYER_FRICTION)
                    .setRestitution(PLAYER_RESTITUTION)
                    .setCollisionGroups(createInteractionGroups(COLLISION_GROUP_GENERAL, COLLISION_GROUP_GENERAL));
            } else {
                // REMOTE PLAYER: Kinematic body with a SENSOR collider. It only detects collisions without creating physical responses.
                playerRigidBodyDesc = RAPIER.RigidBodyDesc.kinematicPositionBased().setTranslation(initialPos.x, initialPos.y, initialPos.z).setCanSleep(false).lockRotations().setCcdEnabled(true);
                playerColliderDesc = RAPIER.ColliderDesc.capsule(capsuleHalfHeight, PLAYER_RADIUS)
                    .setSensor(true); // CRITICAL: This prevents the remote player's body from physically pushing the local player.
            }
            const playerPhysicsBody = physicsWorld.createRigidBody(playerRigidBodyDesc);
            physicsWorld.createCollider(playerColliderDesc, playerPhysicsBody);
            const playerVisuals = setupAjaxsonFromGltf(ajaxsonGltf); // Sets up the visual model.

            // --- 2. CREATE VEHICLE (PODRACER) FOR THIS PLAYER ---
            const podracerData = setupPodracerFromGltfs(podracerVisualGltf, podracerColliderGltf, playerId);
            let podracerRigidBodyDesc;
            let podracerColliderDesc;

            if (isLocal) {
                // LOCAL PODRACER: Dynamic body with a SOLID collider.
                podracerRigidBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(0, -100, 0) // Initially hidden below the map.
                    .setGravityScale(0.0).setCanSleep(true).setCcdEnabled(true)
                    .setLinearDamping(PODRACER_LINEAR_DAMPING).setAngularDamping(PODRACER_ANGULAR_DAMPING);
                podracerColliderDesc = RAPIER.ColliderDesc.convexHull(podracerData.colliderData.vertices)
                    .setDensity(PODRACER_DENSITY)
                    .setFriction(PODRACER_FRICTION)
                    .setRestitution(PODRACER_RESTITUTION)
                    .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS) // Enable collision events for race logic.
                    .setCollisionGroups(createInteractionGroups(COLLISION_GROUP_GENERAL, COLLISION_GROUP_GENERAL | COLLISION_GROUP_PORTAL)); // It IS a GENERAL object and it INTERACTS with GENERAL and PORTAL objects.
            } else {
                // REMOTE PODRACER: Kinematic body with a SENSOR collider.
                podracerRigidBodyDesc = RAPIER.RigidBodyDesc.kinematicPositionBased().setTranslation(0, -100, 0)
                    .setCanSleep(true).setCcdEnabled(true);
                podracerColliderDesc = RAPIER.ColliderDesc.convexHull(podracerData.colliderData.vertices)
                    .setSensor(true)
                    .setCollisionGroups(createInteractionGroups(COLLISION_GROUP_GENERAL, COLLISION_GROUP_GENERAL | COLLISION_GROUP_PORTAL));
            }
            const podracerPhysicsBody = physicsWorld.createRigidBody(podracerRigidBodyDesc);
            const podracerCollider = physicsWorld.createCollider(podracerColliderDesc, podracerPhysicsBody);
            
            console.log(`[DEBUG PODRACER] Podracer collider created for player ${playerId}. Handle: ${podracerCollider.handle}, Groups: ${podracerCollider.collisionGroups()}`);
            podracerPhysicsBody.sleep(); // Starts asleep to save performance.

            // --- 3. ASSEMBLE THE COMPLETE PLAYER OBJECT ---
            const newPlayer = {
                id: playerId,                           // The unique ID.
                displayName: displayName || `Player_${playerCounter}`, // The player's name.
                isLocal: isLocal,                       // Is this the local player?
                body: playerPhysicsBody,                // The character's physics body.
                colliderDesc: playerColliderDesc,       // The description of the character's collider.
                model: playerVisuals.model,             // The character's visual model.
                mixer: playerVisuals.mixer,             // The animation mixer for the character.
                actions: playerVisuals.actions,         // A map of available animations.
                currentAction: null,                    // The currently playing animation action.
                
                vehicle: {                              // A sub-object containing all vehicle data.
                    body: podracerPhysicsBody,
                    mesh: podracerData.mesh,
                    colliderMeshHelper: podracerData.colliderMeshHelper,
                    collider: podracerCollider
                },

                network: {                              // A sub-object for network-related data.
                    lastPacket: null,                   // The last data packet received for this player.
                    lastSentState: null,                // The last state sent BY the local client (for calculating deltas).
                    stateBuffer: [],                    // A buffer to store incoming states for interpolation.
                    stats: {                            // An object for tracking network statistics.
                        packetsThisSecond: 0,
                        lastCalculatedHz: 0,
                    },
                    updatesSinceLastFullState: 0        // A counter to force sending a full state packet periodically.
                },

                state: {                                // The complete, authoritative state object for this player.
                    // General State
                    controlMode: ControlMode.FPS,
                    isInVehicle: false,
                    // FPS Mode State
                    moveForward: false, moveBackward: false, moveLeft: false, moveRight: false,
                    isSprinting: false, canJump: false, jumpFuel: 0.0, animationState: 'idle',
                    // FPS Camera State
                    isThirdPersonActive: true, isPlatformerCameraActive: false,
                    thirdPersonZoomDistance: FPS_THIRD_PERSON_OFFSET.z,
                    platformerCameraDistance: FPS_PLATFORMER_INITIAL_DISTANCE,
                    platformerCameraAzimuth: 0, platformerCameraElevation: FPS_PLATFORMER_INITIAL_ELEVATION,
                    // Vehicle State
                    vehicleState: {
                        isInFlightMode: false, 
                        previouslyInFlightMode: false, 
                        isJumping: false,
                        isAeroBraking: false, 
                        isApplyingDownForce: false, 
                        currentCameraMode: PODRACER_CAM_MODE.ATTACHED,
                        thrustLevel: 0.0, 
                        isRaceThrusting: false, 
                        raceThrustDirection: 0, 
                        isRollingLeft: false,
                        isRollingRight: false, 
                        isStrafingLeft: false, 
                        isStrafingRight: false,
                        isStrafingLeftInFlight: false, 
                        isStrafingRightInFlight: false, 
                        yawVelocity: 0.0,
                        pitchVelocity: 0.0, 
                        rollVelocity: 0.0, 
                        keyYawRate: 0.0, 
                        keyPitchRate: 0.0,
                        currentVisualRoll: 0.0, 
                        isVelocityRayFrozen: false, 
                        frozenVelocityRayLength: PODRACER_VELOCITY_RAY_MIN_LENGTH,
                        isFlightGravityActive: false, 
                        relativeAltitude: null,
                    }
                }
            };

            // --- 4. Final Setup ---
            players.set(playerId, newPlayer); // Adds the new player to the global map.
            
            if (isLocal) { // Additional setup only for the local player.
                if (newPlayer.model) {
                    const playerPosRapier = newPlayer.body.translation();
                    newPlayer.model.position.set(playerPosRapier.x, playerPosRapier.y - PLAYER_HEIGHT / 2, playerPosRapier.z);
                }
                updatePlayerFPSCamera(newPlayer.body);
            } else { // Additional setup for remote players.
                if (newPlayer.model) {
                    newPlayer.model.visible = false;
                }
            }
            
            playAnimation('idle', newPlayer); // Start the default animation.

            console.log(`✅ Player '${playerId}' and their personal vehicle have been created.`);
            return newPlayer;
        }

        // ==========================================
        // 🌐 NETWORK LOOP
        // ==========================================
        let networkLoopInterval = null; // A variable to hold the reference to our setInterval loop.

        /**
         * 🌐 Starts a fixed-interval loop to send network data.
         * @param {number} frequency - How many times per second the loop should run (in Hz).
         */
        function startNetworkLoop(frequency = 20) {
            if (networkLoopInterval) { // If a loop is already running, clear it first.
                clearInterval(networkLoopInterval);
            }

            const intervalMs = 1000 / frequency; // Calculate the interval in milliseconds.

            networkLoopInterval = setInterval(() => { // Start the loop.
                if (currentGlobalMode !== GameMode.GAME_MULTIPLAYER || isPaused) { // Only run if in multiplayer and not paused.
                    return;
                }

                const localPlayer = players.get(localPlayerId); // Get the local player object.
                if (!localPlayer) return;

                const packet = createOptimizedNetworkPacket(localPlayer); // Create the data packet.
                if (!packet) return;

                const finalPacket = { // Wrap the game data in a packet with a type identifier.
                    type: 'game_update',
                    packet: packet
                };

                // Send the packet to ALL active connections.
                for (const conn of connections.values()) {
                    if (conn && conn.open) {
                        conn.send(finalPacket);
                    }
                }
                
            }, intervalMs);

            console.log(`🌐 REAL network loop started. Frequency: ${frequency}Hz.`);
        }

        // ==========================================
        // 🎞️ POST-PROCESSING SETUP
        // ==========================================
        /**
         * 🎞️ Sets up or reconfigures the post-processing chain.
         */
        function setupPostProcessing() {
            console.log(`🎞️ Setting up default composer.`);

            composer = new EffectComposer(renderer); // The main manager for post-processing passes.

            // 1. Render Pass: The base pass that renders the 3D scene.
            renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // 2. Pixelation Pass: A custom pass for the pixelated effect.
            pixelPass = new RenderPixelatedPass(6, scene, camera);
            pixelPass.enabled = false; // Starts disabled.
            composer.addPass(pixelPass);

            // 3. Antialiasing Passes: SMAA and FXAA.
            const pixelRatio = renderer.getPixelRatio();
            const w = window.innerWidth * pixelRatio;
            const h = window.innerHeight * pixelRatio;

            fxaaPass = new ShaderPass(FXAAShader); // A pass that applies the FXAA shader.
            fxaaPass.material.uniforms['resolution'].value.x = 1 / w;
            fxaaPass.material.uniforms['resolution'].value.y = 1 / h;
            fxaaPass.enabled = (currentAALevel === 'FXAA'); // Enabled based on current setting.
            composer.addPass(fxaaPass);

            smaaPass = new SMAAPass(w, h); // The SMAA pass.
            smaaPass.enabled = (currentAALevel === 'SMAA'); // Enabled based on current setting.
            composer.addPass(smaaPass);

            // 4. Output Pass: The final pass that renders the result to the screen.
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        // ==========================================
        // 💡 LIGHTS SETUP
        // ==========================================
        /**
         * 💡 Sets up the lighting for the scene.
         */
        function setupLights() {
            // --- Ambient Light ---
            const ambientLight = new THREE.AmbientLight(AMBIENT_LIGHT_COLOR, AMBIENT_LIGHT_INTENSITY);
            scene.add(ambientLight);

            // --- Directional Light (Sun) ---
            const directionalLight = new THREE.DirectionalLight(DIRECTIONAL_LIGHT_COLOR, DIRECTIONAL_LIGHT_INTENSITY);

            // Position the light far away. It will point from this position towards its target.
            directionalLight.position.set(DIRECTIONAL_LIGHT_DISTANCE, DIRECTIONAL_LIGHT_DISTANCE, DIRECTIONAL_LIGHT_DISTANCE);
            
            // The target is (0,0,0) by default, which is the center of the scene.
            directionalLight.target.position.set(0, 0, 0);
            scene.add(directionalLight.target);

            // Enable shadow casting for this light.
            directionalLight.castShadow = true;

            // Configure the shadow map (the texture that holds the shadow information).
            directionalLight.shadow.mapSize.width = DIRECTIONAL_LIGHT_SHADOW_MAP_SIZE;
            directionalLight.shadow.mapSize.height = DIRECTIONAL_LIGHT_SHADOW_MAP_SIZE;

            // Configure the light's "camera" which defines the area that casts shadows.
            const shadowCamSize = DIRECTIONAL_LIGHT_SHADOW_CAMERA_SIZE / 2;
            directionalLight.shadow.camera.left = -shadowCamSize;
            directionalLight.shadow.camera.right = shadowCamSize;
            directionalLight.shadow.camera.top = shadowCamSize;
            directionalLight.shadow.camera.bottom = -shadowCamSize;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = DIRECTIONAL_LIGHT_SHADOW_CAMERA_SIZE; 

            // Adjust shadow bias to prevent "shadow acne" artifacts.
            directionalLight.shadow.bias = -0.0001;
            
            // Add the light to the scene.
            scene.add(directionalLight);
            
            console.log("💡 Directional light with shadows configured and added to the scene.");
        }

        // ==========================================
        // 🖱️ CONTROLS SETUP
        // ==========================================
        /**
         * 🖱️ Sets up the PointerLockControls and its event listeners.
         */
        function setupControls() {
            controls = new PointerLockControls(camera, document.body); // Creates the controls instance.

            // Event listener for when the mouse pointer is successfully locked.
            controls.addEventListener("lock", () => {
                const localPlayer = players.get(localPlayerId);
                const mode = localPlayer ? localPlayer.state.controlMode : 'N/A';
                console.log(`PointerLockControls: 'lock' event fired. Current Mode: ${mode}, Paused: ${isPaused}`);

                if (isPaused) { // If the game is paused, immediately unlock to prevent getting stuck.
                    console.warn("PointerLockControls: 'lock' occurred while paused. Unlocking.");
                    controls.unlock();
                    return;
                }
                requestAnimationFrame(() => { // Update UI on the next frame to ensure state is consistent.
                    if (controls.isLocked) {
                        updateCursorAndIndicators();
                        updateInstructions();
                    }
                });
            });

            // Event listener for when the mouse pointer is unlocked (e.g., by pressing Esc).
            controls.addEventListener("unlock", () => {
                const localPlayer = players.get(localPlayerId);
                const mode = localPlayer ? localPlayer.state.controlMode : 'N/A';
                console.log(`PointerLockControls: 'unlock' event fired. Current Mode: ${mode}, Paused: ${isPaused}`);

                // If the game isn't paused, an unlock means the user wants to stop controlling, so reset movement state.
                if (!isPaused && localPlayer && localPlayer.state.controlMode === ControlMode.FPS) {
                    localPlayer.state.moveForward = false;
                    localPlayer.state.moveBackward = false;
                    localPlayer.state.moveLeft = false;
                    localPlayer.state.moveRight = false;
                    localPlayer.state.isSprinting = false;
                    console.log("   -> FPS movement reset due to unlock (not paused).");
                }
                if (!isPaused && localPlayer && localPlayer.state.controlMode === ControlMode.PODRACER) {
                    mouseScreenOffsetX = 0.0;
                    console.log("   -> mouseScreenOffsetX reset for Podracer due to unlock (not paused).");
                }

                updateCursorAndIndicators();
                updateInstructions();
            });

            // Event listener for clicking anywhere on the page to lock the pointer.
            document.body.addEventListener("click", () => {
                const isGameActive = currentGlobalMode === GameMode.GAME_SINGLE_PLAYER || currentGlobalMode === GameMode.GAME_MULTIPLAYER;

                if (isGameActive && !isPaused && !controls.isLocked) {
                    const localPlayer = players.get(localPlayerId);
                    if(localPlayer){
                        const mode = localPlayer.state.controlMode;
                        if (mode === ControlMode.FPS || mode === ControlMode.PODRACER) {
                            console.log(`Body Click: Attempting to lock pointer for mode ${mode}.`);
                            controls.lock();
                        }
                    }
                }
            }, false);
            console.log("🖱️ PointerLockControls configured for FPS and Podracer.");
        }

        // ==========================================
        // 🌳 SETUP TERRAIN (FROM PRELOADED GLTF)
        // ==========================================
        function setupTerrainFromGltf(gltf) {

            // --- 1. VALIDATION ---
            // -----------------------
            // Verification step: If the GLTF asset failed to load for any reason,
            // stop execution to prevent further errors.
            if (!gltf) {
                // Throwing an error here will be caught by the try...catch block in the main init function,
                // informing the user of the critical failure.
                throw new Error("Failed to configure terrain: Terrain GLTF object is missing.");
            }
            console.log("🌳 Configuring terrain from pre-loaded GLTF...");

            // --- 2. CUSTOM SHADER SETUP ---
            // --------------------------------
            // Define the names of specific objects within the GLB file that will receive custom shader materials.
            // These names must exactly match the object names in the 3D modeling software (e.g., Blender).

            // Set 1: Caustics Shader Targets
            const CAUSTICS_SHADER_PARENT_NAME_SET1 = "PISTA_Cube_NEW_ROOT004_SEED001_Escalada_MESH002";
            const CAUSTICS_SHADER_TARGET_MESH_NAMES_SET1 = ["Cube001"];
            let causticsMeshesSet1FoundAndModified = 0;

            // Set 2: Caustics Shader Targets
            const CAUSTICS_SHADER_PARENT_NAME_SET2 = "PISTA_Cube_NEW_ROOT005_MINHOCÃO_V_3_2_Curve_NEW_MESH";
            const CAUSTICS_SHADER_TARGET_MESH_NAMES_SET2 = ["Cube009_1", "Cube009_2"];
            let causticsMeshesSet2FoundAndModified = 0;

            // Set 3: Caustics Shader Targets
            const CAUSTICS_SHADER_PARENT_NAME_SET3 = "Nova_Pista_1_RASCUNHO003_MESH";
            const CAUSTICS_SHADER_TARGET_MESH_NAMES_SET3 = ["Nova_Pista_1_RASCUNHO002_1", "Nova_Pista_1_RASCUNHO002_2"];
            let causticsMeshesSet3FoundAndModified = 0;
            
            // Set 4: Caustics Shader Targets
            const CAUSTICS_SHADER_PARENT_NAME_SET4 = "✅_PISTA_NOVA_S_Cochlea_V_4_Material001";
            const CAUSTICS_SHADER_TARGET_MESH_NAMES_SET4 = ["Circle004_1"];
            let causticsMeshesSet4FoundAndModified = 0;

            // --- Create a list of all meshes that should NOT receive an outline effect ---
            const causticMeshNamesToExclude = [
                ...CAUSTICS_SHADER_TARGET_MESH_NAMES_SET1,
                ...CAUSTICS_SHADER_TARGET_MESH_NAMES_SET2,
                ...CAUSTICS_SHADER_TARGET_MESH_NAMES_SET3,
                ...CAUSTICS_SHADER_TARGET_MESH_NAMES_SET4
            ];
            console.log(`🚫 Meshes to be excluded from outline:`, causticMeshNamesToExclude);

            // Counter for tracking processed meshes
            let meshesProcessedForPhysics = 0;
            // Get the root node of the terrain model from the loaded GLTF file.
            const terrainRootNode = gltf.scene; 

            // --- 3. VISUAL SETUP & SCENE INTEGRATION ---
            // ---------------------------------------------
            // Apply a global scale factor to the terrain's root node BEFORE any other processing.
            terrainRootNode.scale.set(TERRAIN_SCALE_FACTOR, TERRAIN_SCALE_FACTOR, TERRAIN_SCALE_FACTOR);
            
            // It's crucial to update the world matrix of all child objects so the scale is applied correctly.
            terrainRootNode.updateMatrixWorld(true);
            
            // Add the complete visual model of the terrain to the main 3D scene.
            scene.add(terrainRootNode);

            // ✅ Create the outline effect for the entire terrain model in a single, unified call.
            createUnifiedIlluminatedOutline(
                terrainRootNode, 
                { 
                    minThickness: 0.03,
                    maxThickness: 1.5,
                    minDistance: 1.0,
                    maxDistance: 220.0,
                    exclude: [
                        ...causticMeshNamesToExclude, 
                        'Mesh001',      // Exclude the VIBE_WEAVERS title meshes
                        'Mesh001_1', 
                        'Mesh001_2'
                    ]
                }, 
                terrainOutlineMaterials, // Store the created outline materials here
                allOutlineMeshes         // Store the created outline meshes here
            );

            // Add the newly created terrain outline materials to the global list for later management.
            allOutlineMaterials.push(...terrainOutlineMaterials);
            
            // Store a reference to the terrain's root visual object.
            terrainMesh = terrainRootNode; 
            console.log(`✅ Terrain visual model added to scene and scaled by ${TERRAIN_SCALE_FACTOR}.`);

            // --- 4. APPLY CUSTOM SHADER MATERIALS ---
            // ------------------------------------------
            // Traverse the scene graph to find the specific meshes and replace their default materials with our custom shaders.
            
            // Apply Caustics Shader - Set 1
            const causticsShaderParentSet1 = terrainRootNode.getObjectByName(CAUSTICS_SHADER_PARENT_NAME_SET1);
            if (causticsShaderParentSet1) {
                causticsShaderParentSet1.traverse((child) => {
                    if (child.isMesh && CAUSTICS_SHADER_TARGET_MESH_NAMES_SET1.includes(child.name)) {
                        if (child.geometry && child.geometry.attributes.uv) { // Check for UV coordinates, which shaders need
                            child.material = causticsMaterialSet1;
                            causticsMeshesSet1FoundAndModified++;
                        }
                    }
                });
            }

            // Apply Caustics Shader - Set 2
            const causticsShaderParentSet2 = terrainRootNode.getObjectByName(CAUSTICS_SHADER_PARENT_NAME_SET2);
            if (causticsShaderParentSet2) {
                causticsShaderParentSet2.traverse((child) => {
                    if (child.isMesh && CAUSTICS_SHADER_TARGET_MESH_NAMES_SET2.includes(child.name)) {
                        if (child.geometry && child.geometry.attributes.uv) {
                            child.material = causticsMaterialSet2;
                            causticsMeshesSet2FoundAndModified++;
                        }
                    }
                });
            }

            // Apply Caustics Shader - Set 3
            const causticsShaderParentSet3 = terrainRootNode.getObjectByName(CAUSTICS_SHADER_PARENT_NAME_SET3);
            if (causticsShaderParentSet3) {
                causticsShaderParentSet3.traverse((child) => {
                    if (child.isMesh && CAUSTICS_SHADER_TARGET_MESH_NAMES_SET3.includes(child.name)) {
                        if (child.geometry && child.geometry.attributes.uv) {
                            child.material = causticsMaterialSet3;
                            causticsMeshesSet3FoundAndModified++;
                        }
                    }
                });
            }
            
            // Apply Caustics Shader - Set 4
            const causticsShaderParentSet4 = terrainRootNode.getObjectByName(CAUSTICS_SHADER_PARENT_NAME_SET4);
            if (causticsShaderParentSet4) {
                causticsShaderParentSet4.traverse((child) => {
                    if (child.isMesh && CAUSTICS_SHADER_TARGET_MESH_NAMES_SET4.includes(child.name)) {
                        if (child.geometry && child.geometry.attributes.uv) {
                            child.material = causticsMaterialSet4;                         
                            causticsMeshesSet4FoundAndModified++;
                        }
                    }
                });
            }

            // Log the results of the shader application process.
            console.log(`✨ Shaders applied: Set1(${causticsMeshesSet1FoundAndModified}), Set2(${causticsMeshesSet2FoundAndModified}), Set3(${causticsMeshesSet3FoundAndModified}), Set4(${causticsMeshesSet4FoundAndModified})`);

            // --- 5. CREATE PHYSICS COLLIDERS (TRIMESH) ---
            // -----------------------------------------------
            // Iterate through every object inside the terrain model again.
            terrainRootNode.traverse((child) => {
                
                // Process only if the child is a Mesh and not an outline mesh we created.
                if (child.isMesh && child.name !== 'outline_mesh') {
                    
                    // General visual settings for each terrain mesh
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        // Ensure materials render on the front side only.
                        materials.forEach(mat => mat.side = THREE.FrontSide); 
                    }

                    // Logic to create a Trimesh collider for the current mesh
                    if (child.geometry && child.geometry.attributes.position && child.geometry.index) {
                        
                        // Extract vertex and index data from the mesh's geometry.
                        const geometry = child.geometry;
                        const originalVertices = geometry.attributes.position.array;
                        const scaledVertices = new Float32Array(originalVertices.length);

                        // We must apply the mesh's world transformation (position, rotation, scale) to each vertex
                        // to get their final positions in the physics world.
                        const tempVec = new THREE.Vector3();
                        for (let i = 0; i < originalVertices.length; i += 3) {
                            tempVec.set(originalVertices[i], originalVertices[i + 1], originalVertices[i + 2]);
                            tempVec.applyMatrix4(child.matrixWorld); // Apply the transformation
                            scaledVertices[i]     = tempVec.x;
                            scaledVertices[i + 1] = tempVec.y;
                            scaledVertices[i + 2] = tempVec.z;
                        }
                        const indices = geometry.index.array;

                        // Create a "fixed" (static, unmovable) rigid body for this part of the terrain.
                        const rigidBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, 0, 0);
                        const meshBody = physicsWorld.createRigidBody(rigidBodyDesc);

                        // Create the collider using the transformed vertex data (a "trimesh").
                        const colliderDesc = RAPIER.ColliderDesc.trimesh(scaledVertices, indices)
                            .setFriction(TERRAIN_FRICTION)
                            .setRestitution(TERRAIN_RESTITUTION);
                        
                        // Attach the collider to the rigid body.
                        physicsWorld.createCollider(colliderDesc, meshBody);
                        
                        meshesProcessedForPhysics++;
                        
                        // Create a visual wireframe mesh for debugging purposes.
                        createPhysicsDebugMesh(scaledVertices, indices, meshBody);
                    }
                }
            });

            // Final check to ensure colliders were created successfully.
            if (meshesProcessedForPhysics === 0) {
                throw new Error("No valid meshes were found in the GLB to create terrain colliders.");
            }
            console.log(`✅ ${meshesProcessedForPhysics} terrain physics colliders (Trimesh) were created.`);

            // Add the terrain to a list of objects whose textures can be updated by the render style menu.
            if (terrainMesh) {
                allTexturedObjects.push(terrainMesh);
                console.log("   📦 Terrain added to the list for texture/style updates.");
            }
        }

        // ==========================================
        // 🤖 SETUP AJAXSON (FROM PRELOADED GLTF)
        // ==========================================
        function setupAjaxsonFromGltf(gltf) {

            // --- 1. VALIDATION ---
            // -----------------------
            // Initial check: If the GLTF asset is missing, stop the creation process.
            if (!gltf) {
                throw new Error("Failed to configure Ajaxson: Character GLTF object is missing.");
            }
            console.log("🏃‍♂️ Configuring Ajaxson character from pre-loaded GLTF...");

            try {
                // --- 2. CLONE MODEL & GET ANIMATIONS ---
                // -----------------------------------------
                // We use SkeletonUtils.clone to create a fully independent copy of the model,
                // including its skeleton and bones. This is essential for having multiple characters.
                const model = clone(gltf.scene);
                const animations = gltf.animations;

                // --- 3. VISUAL SETUP & OUTLINE CREATION ---
                // ------------------------------------------
                model.traverse((child) => {
                    // SkinnedMeshes are meshes deformed by a skeleton (the character's body).
                    if (child.isSkinnedMesh) {
                        console.log(`   -> Found SkinnedMesh: ${child.name}. Setting up shadows and outline...`);
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Create an animated outline for this skinned mesh.
                        createUnifiedIlluminatedOutline(child, { 
                            thickness: 0.03, 
                            isSkinned: true 
                        }, allOutlineMaterials, allOutlineMeshes);

                    } else if (child.isMesh) {
                        // For other regular meshes attached to the model.
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                // --- 4. SCALE & POSITION ---
                // -----------------------------
                const scaleFactor = 0.9; 
                model.scale.set(scaleFactor, scaleFactor, scaleFactor);
                model.position.y = -PLAYER_HEIGHT / 2; // Adjust position relative to its physics capsule.
                model.visible = false; // Start hidden until it's assigned to a player.
                scene.add(model);
                
                // Add to the list of objects that can have their texture filtering changed.
                allTexturedObjects.push(model); 
                console.log("   -> Ajaxson model loaded, scaled, positioned, and added to the scene (initially invisible).");

                // --- 5. ANIMATION MIXER SETUP ---
                // ----------------------------------
                const mixer = new THREE.AnimationMixer(model); // The mixer is responsible for playing animations on this model.
                const actions = {}; // An object to store references to all animation actions for this specific model.
                console.log(`   -> AnimationMixer created for Ajaxson instance.`);

                // ======================================
                // 🤸‍♂️ ANIMATION MAPPING 
                // ======================================
                console.log("   -> Mapping animation actions...");
                
                // This map links user-friendly action names (e.g., 'walk') to the actual animation clip names
                // from the GLB file (e.g., 'Animation_04').
                const animationMap = {
                    idle: "Animation_00",
                    walk: "Animation_04",
                    walk_backward: "Animation_05",
                    run: "Animation_06",
                    run_backward: "Animation_07",
                    strafe_left: "Animation_10",
                    strafe_right: "Animation_09",
                    strafe_run_left: "Animation_12",
                    strafe_run_right: "Animation_11",
                    jump: "Animation_15",
                    fall: "Animation_14",
                    walk_forward_right: "Animation_19",
                    walk_forward_left: "Animation_20",
                    run_forward_right: "Animation_21",
                    run_forward_left: "Animation_22",
                    turn_right: "Animation_25",
                    turn_left: "Animation_26"
                };

                // Iterate over the map to find each animation clip and create a playable action for it.
                for (const [actionName, clipName] of Object.entries(animationMap)) {
                    const clip = THREE.AnimationClip.findByName(animations, clipName);
                    if (clip) {
                        const action = mixer.clipAction(clip);
                        actions[actionName] = action;

                        // The 'jump' animation should only play once.
                        if (actionName === 'jump') {
                            action.setLoop(THREE.LoopOnce);
                            action.clampWhenFinished = true; // Prevents the animation from resetting after it finishes.
                        }
                        
                        console.log(`      ✅ Action '${actionName}' mapped to clip '${clipName}'.`);
                    } else {
                        console.warn(`      ⚠️ Animation clip '${clipName}' (for action '${actionName}') NOT found in GLB!`);
                    }
                }
                
                // This event listener handles the transition from the 'jump' animation to the 'fall' animation
                // when the jump sequence is complete.
                mixer.addEventListener('finished', (event) => {
                    const localPlayer = players.get(localPlayerId);
                    if (!localPlayer) return;

                    // Check if the action that just finished was the jump.
                    if (event.action === localPlayer.actions.jump) {
                        // If the player is still in the air (can't jump), transition to the fall animation.
                        if (!localPlayer.state.canJump) {
                            playAnimation('fall', localPlayer);
                        }
                    }
                });
                console.log("   -> ✅ Event listener for 'finished' (jump->fall transition) configured.");
                // ======================================
                
                // Return an object containing all the created visual and animation components.
                return { model, mixer, actions };

            } catch (error) {
                console.error("❌ CRITICAL error while configuring Ajaxson character:", error);
                throw error; // Re-throw the error to be handled by a higher-level function.
            }
        }

        // ==========================================
        // 🏃 CREATE PLAYER PHYSICS (DYNAMIC CAPSULE)
        // ==========================================
        // This function now accepts a spawn position and returns the created physics objects.
        function createPlayerPhysics(spawnPosition) {
            console.log("🏃 Creating player physics (Dynamic Capsule)...");

            // --- Dynamic Rigid Body ---
            const rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                .setTranslation(spawnPosition.x, spawnPosition.y, spawnPosition.z) // Use the provided spawn position.
                .setGravityScale(1.0)       // Normal gravity.
                .setCanSleep(false)         // The player should always be simulated.
                .lockRotations()            // Prevent the capsule from tipping over.
                .setCcdEnabled(true)        // Enable Continuous Collision Detection for fast movements.
                .setLinearDamping(PLAYER_LINEAR_DAMPING); // Simulates air resistance.

            // Create the body as a local constant.
            const body = physicsWorld.createRigidBody(rigidBodyDesc);

            // --- Capsule-shaped Collider ---
            const capsuleHalfHeight = PLAYER_HEIGHT / 2 - PLAYER_RADIUS;
            const colliderDesc = RAPIER.ColliderDesc.capsule(capsuleHalfHeight, PLAYER_RADIUS)
                .setDensity(PLAYER_DENSITY)      // Determines the mass of the body.
                .setFriction(PLAYER_FRICTION)    // How much it grips surfaces.
                .setRestitution(PLAYER_RESTITUTION); // Bounciness.

            // Attach the collider shape to the rigid body.
            physicsWorld.createCollider(colliderDesc, body);

            console.log(`✅ Player physics created. Calculated Mass: ${body.mass().toFixed(2)} kg`);
            console.log(`   -> Initial State: GravityScale=${body.gravityScale()}, CanSleep=${!body.isSleeping() ? 'false' : 'true (problem!)'}, CCD=${body.isCcdEnabled()}`);

            // Return an object with the created physics components.
            return { body, colliderDesc };
        }

        // ==========================================
        // 🚀 PODRACER FACTORY (FROM PRELOADED GLTFs)
        // ==========================================
        function setupPodracerFromGltfs(gltfVisual, gltfCollider, ownerPlayerId = 'unassigned') {
            
            // --- 1. VALIDATION ---
            // -----------------------
            if (!gltfVisual || !gltfCollider) {
                throw new Error("Failed to configure Podracer: One or both GLTF objects are missing.");
            }
            console.log(`🚀 Creating a new Podracer instance for player: ${ownerPlayerId}`);

            try {
                // --- 2. VISUAL MESH SETUP ---
                // ----------------------------
                const mesh = gltfVisual.scene.clone(); // Clone the visual model.
                mesh.scale.set(1, 1, 1);
                mesh.rotation.set(0, 0, 0);
                
                // Iterate through the model to set properties for each mesh part.
                mesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.material) {
                            child.material = child.material.clone(); // Clone material to avoid sharing with other instances.
                        }
                        child.material.side = THREE.FrontSide;
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // Set texture filtering for a pixelated/retro style.
                        if (child.material && child.material.map) {
                            child.material.map.magFilter = THREE.NearestFilter;
                            child.material.map.minFilter = THREE.NearestFilter;
                            child.material.map.needsUpdate = true;
                        }
                    }
                });

                mesh.visible = false; // Start hidden.
                scene.add(mesh);

                // Create the outline effect for the Podracer.
                createUnifiedIlluminatedOutline(mesh, { thickness: 0.03 }, allOutlineMaterials, allOutlineMeshes);
                
                // --- 3. EXTRACT COLLIDER GEOMETRY ---
                // ------------------------------------
                let vertices = null;
                let indices = null;
                
                // Find the first valid mesh in the collider GLB and extract its geometry data.
                let foundColliderData = false;
                gltfCollider.scene.traverse((child) => {
                    if (!foundColliderData && child.isMesh && child.geometry && child.geometry.index) {
                        vertices = child.geometry.attributes.position.array;
                        indices = child.geometry.index.array;
                        foundColliderData = true; // Data found, stop searching.
                    }
                });

                if (!vertices) {
                    throw new Error("Could not find/extract valid vertex geometry from the Collider GLB.");
                }

                // --- 4. CREATE DEBUG COLLIDER HELPER ---
                // ---------------------------------------
                const colliderMeshHelper = gltfCollider.scene.clone();
                colliderMeshHelper.traverse((child) => {
                    if (child.isMesh) {
                        // Apply a simple wireframe material to visualize the collider shape.
                        child.material = new THREE.MeshBasicMaterial({
                            color: PODRACER_COLLIDER_HELPER_COLOR, wireframe: true,
                            transparent: true, opacity: PODRACER_COLLIDER_HELPER_OPACITY, depthWrite: false
                        });
                    }
                });
                mesh.add(colliderMeshHelper); // Attach the helper to the main visual mesh.
                colliderMeshHelper.visible = false; // Start hidden.
                
                // Add the Podracer to the list for render style updates.
                if (mesh) {
                    allTexturedObjects.push(mesh);
                }
                
                console.log(`✅ New Podracer instance for '${ownerPlayerId}' is ready.`);

                // Return all created components.
                return { mesh, colliderMeshHelper, colliderData: { vertices, indices } };

            } catch (error) {
                console.error(`   -> ❌ CRITICAL error during Podracer setup for '${ownerPlayerId}':`, error);
                throw error;
            }
        }

        // ===================================================================
        // 🖥️ VIRTUAL ON-SCREEN CONSOLE
        // ===================================================================
        function setupVirtualConsole() {

            // Store the original browser console functions.
            const originalLog = console.log;
            const originalWarn = console.warn;
            const originalError = console.error;

            // Helper function to add a message to the on-screen log box.
            const addLogToBox = (message, color) => {
                if (virtualConsoleBox) {
                    const logEntry = document.createElement('div');
                    logEntry.textContent = message;
                    logEntry.style.color = color;
                    logEntry.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';
                    logEntry.style.padding = '2px 0';
                    
                    // Add the new log to the top (since the div uses flex-direction: column-reverse).
                    virtualConsoleBox.prepend(logEntry);
                }
            };

            // Override console.log
            console.log = function() {
                // Call the original function so the log still appears in the browser console.
                originalLog.apply(console, arguments);
                // Build the message from the arguments.
                const message = Array.from(arguments).join(' ');
                // Add the message to our on-screen log box.
                addLogToBox(message, '#a7d1a7'); // Light green color
            };

            // Override console.warn
            console.warn = function() {
                originalWarn.apply(console, arguments);
                const message = `⚠️ WARNING: ${Array.from(arguments).join(' ')}`;
                addLogToBox(message, '#f0e68c'); // Khaki yellow color
            };

            // Override console.error
            console.error = function() {
                originalError.apply(console, arguments);
                const message = `❌ ERROR: ${Array.from(arguments).join(' ')}`;
                addLogToBox(message, '#ff6b6b'); // Light red color
            };
        }


        // ===================================================================
        // SECTION 6: INPUT LOGIC
        // ===================================================================
        // This section handles all user inputs, from keyboard presses to mouse movements.
        // It follows a "decoupled" architecture: listeners record the raw input, and 
        // separate functions interpret that input to change the player's state.

        // ==========================================
        // ⌨️ SETUP ALL INPUT LISTENERS
        // ==========================================
        /**
         * Attaches all necessary event listeners to the document for handling user input.
         * This function is called once during the game's initialization.
         */
        function setupInputListeners() {
            
            // --- KEYBOARD LISTENERS ---
            // 'keydown' is fired when a key is pressed down.
            document.addEventListener('keydown', (event) => {
                keyboard[event.code] = true; // Record that this key is currently held down.
                handleKeyDown(event);        // Call the specific handler for single-press actions.
            });
            // 'keyup' is fired when a key is released.
            document.addEventListener('keyup', (event) => {
                keyboard[event.code] = false; // Record that this key is no longer held down.
                handleKeyUp(event);           // Call the handler for key release actions.
            });

            // --- MOUSE LISTENERS ---
            // 'mousemove' is fired every time the mouse moves.
            document.addEventListener('mousemove', handleMouseMove);
           
            // 'wheel' is fired when the mouse wheel is scrolled.
            // { passive: false } allows us to call event.preventDefault() to stop the page from scrolling.
            document.addEventListener('wheel', handleMouseWheel, { passive: false });

            // 'mousedown' is fired when a mouse button is pressed.
            // This is specifically used for the race portal placement mode.
            document.addEventListener('mousedown', (event) => {
                
                // This logic only runs if the game is in portal placement mode.
                if (!isInPortalPlacementMode) return;

                // Prevent default browser actions, like text selection or context menus.
                event.preventDefault();

                // Check which mouse button was clicked.
                if (event.button === 0) { // 0 = Left mouse button
                    finalizePortalPlacement();
                } else if (event.button === 2) { // 2 = Right mouse button
                    cancelPortalPlacement();
                }
            });

            console.log("⌨️ Keyboard and mouse listeners configured.");
        }

        // ==========================================
        // ⏯️ HANDLE KEY PRESSES (ONE-SHOT ACTIONS)
        // ==========================================
        /**
         * Handles actions that should happen only once per key press (toggles, menus).
         * Continuous actions like movement are handled in `processLocalInput`.
         * @param {KeyboardEvent} event - The browser's keyboard event.
         */
        function handleKeyDown(event) {
            
            // Get the unique code for the key that was pressed.
            const code = event.code;
            
            // --- GLOBAL ACTIONS (Can be triggered anytime) ---

            // Toggle Pause Menu
            if (code === 'KeyP') {
                event.preventDefault(); // Prevent the default action for the 'P' key.
                togglePause();
                return; // Stop processing other inputs if the game is now paused.
            }

            // Open Playground/Race Menu
            if (code === 'KeyG' && !isPaused) {
                const localPlayer = players.get(localPlayerId);
                // This menu can only be opened while in FPS mode on foot.
                if (localPlayer && localPlayer.state.controlMode === ControlMode.FPS) {
                    event.preventDefault();
                    
                    // Manually pause the game state.
                    isPaused = true;
                    console.log(`Action: Game PAUSED (via Playground Menu).`);

                    // Manually release the mouse cursor.
                    if (controls && controls.isLocked) {
                        controls.unlock();
                    }

                    // Show the correct menu and ensure others are hidden.
                    if (playgroundMenu) playgroundMenu.style.display = 'flex';
                    if (pauseMenuElement) pauseMenuElement.style.display = 'none';
                    if (raceSetupMenu) raceSetupMenu.style.display = 'none';
                    if (soloRaceConfigMenu) soloRaceConfigMenu.style.display = 'none';
                    
                    // Update UI elements like the cursor and on-screen instructions.
                    updateCursorAndIndicators();
                    updateInstructions();
                    return;
                }
            }

            // --- IN-GAME ACTIONS (Ignored if paused) ---
            if (isPaused) {
                return;
            }
            
            // Get the local player object to modify its state.
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            // Use a switch statement to handle different key presses.
            switch (code) {
                
                // --- ⚙️ System & Mode Commands (Toggles) ---
                case 'KeyH': // Switch between FPS and Podracer modes.
                    switchControlMode(localPlayer.state.controlMode === ControlMode.PODRACER ? ControlMode.FPS : ControlMode.PODRACER);
                    break;
                case 'KeyT': // Toggle visibility of multiplayer nametags.
                    areNameTagsVisible = !areNameTagsVisible;
                    console.log(`Nametags ${areNameTagsVisible ? 'ENABLED' : 'DISABLED'}`);
                    break;
                case 'KeyI': // Toggle visibility of debug visuals.
                    toggleDebugVisuals();
                    break;
                case 'KeyR': // Respawn the player.
                    if (localPlayer.state.controlMode === ControlMode.FPS) {
                        respawnPlayer();
                    }
                    break;

                // --- 🎥 Camera Commands (Number Keys) ---
                case 'Digit1':
                case 'Digit2':
                case 'Digit3':
                    if (localPlayer.state.controlMode === ControlMode.FPS) {
                        handlePlayerCameraSwitch(code);
                    } else if (localPlayer.state.controlMode === ControlMode.PODRACER) {
                        const vs = localPlayer.state.vehicleState;
                        if (code === 'Digit1') vs.currentCameraMode = PODRACER_CAM_MODE.FIRST_PERSON;
                        if (code === 'Digit2') vs.currentCameraMode = PODRACER_CAM_MODE.ATTACHED;
                        if (code === 'Digit3') vs.currentCameraMode = PODRACER_CAM_MODE.ATTACHED_FAR;
                    }
                    break;
                
                // --- 🚀 Podracer Flight Gravity Toggle ---
                case 'KeyG':
                    if (localPlayer.state.controlMode === ControlMode.PODRACER && localPlayer.state.vehicleState.isInFlightMode) {
                        const vs = localPlayer.state.vehicleState;
                        vs.isFlightGravityActive = !vs.isFlightGravityActive; // Invert the state.
                        console.log(`🚀 Podracer Flight Gravity: ${vs.isFlightGravityActive ? "ON" : "OFF"}`);
                    }
                    break;

                // --- 🛑 Prevent Default Browser Behavior ---
                case 'Space':
                case 'AltLeft':
                    event.preventDefault(); // Prevents page scrolling or browser menu activation.
                    break;
            }
        }

        // ==========================================
        //  KEYUP HANDLER (SIMPLIFIED)
        // ==========================================
        /**
         * This function's only job is to update the `keyboard` state object when a key is released.
         * The game logic reads from this object in the main loop.
         * @param {KeyboardEvent} event - The browser's keyboard event.
         */
        function handleKeyUp(event) {
            // Its only responsibility is to record that the key was released.
            keyboard[event.code] = false;
        }

        // ==========================================
        // 🎥 PLAYER FPS CAMERA SWITCHING LOGIC
        // ==========================================
        /**
         * Changes the camera mode for the FPS player controller.
         * @param {string} code - The key code ('Digit1', 'Digit2', etc.).
         */
        function handlePlayerCameraSwitch(code) {
            
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer || localPlayer.state.controlMode !== ControlMode.FPS) return;

            switch (code) {
                case 'Digit1': // First Person
                    localPlayer.state.isThirdPersonActive = false;
                    localPlayer.state.isPlatformerCameraActive = false;
                    break;
                case 'Digit2': // Standard Third Person
                    localPlayer.state.isThirdPersonActive = true;
                    localPlayer.state.isPlatformerCameraActive = false;
                    break;
                case 'Digit3': // 3D Platformer Camera
                    if (!localPlayer.state.isPlatformerCameraActive) {
                        localPlayer.state.isPlatformerCameraActive = true;
                        localPlayer.state.isThirdPersonActive = false;
                        
                        // Set the initial orientation of the platformer camera based on the previous view.
                        if (controls && localPlayer.body) {
                            const cameraFPSQuaternion = camera.quaternion.clone();
                            const cameraFPSEuler = new THREE.Euler(0, 0, 0, 'YXZ');
                            cameraFPSEuler.setFromQuaternion(cameraFPSQuaternion, 'YXZ');
                            
                            const previousCameraYaw = cameraFPSEuler.y;
                            const playerTargetQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, previousCameraYaw, 0, 'YXZ'));
                            localPlayer.body.setRotation(playerTargetQuaternion, true);
                            
                            // Initialize camera state variables.
                            localPlayer.state.platformerCameraAzimuth = previousCameraYaw + FPS_PLATFORMER_INITIAL_AZIMUTH_OFFSET_FROM_PLAYER_FORWARD;
                            localPlayer.state.platformerCameraElevation = FPS_PLATFORMER_INITIAL_ELEVATION;
                            localPlayer.state.platformerCameraDistance = FPS_PLATFORMER_INITIAL_DISTANCE;
                        }
                    }
                    break;
            }

            // Update the player model's visibility and mouse controls after the switch.
            if (localPlayer.model) {
                localPlayer.model.visible = localPlayer.state.isThirdPersonActive || localPlayer.state.isPlatformerCameraActive;
            }
            if (controls) {
                // In platformer mode, the mouse orbits the camera, it doesn't control the player's view directly.
                controls.enablePitchControl = !localPlayer.state.isPlatformerCameraActive;
                controls.enableYawControl = !localPlayer.state.isPlatformerCameraActive;
            }
            
            // Update on-screen instructions to reflect the new controls.
            updateInstructions();
        }

        // ==========================================
        // 🖱️ MOUSE MOVEMENT HANDLER
        // ==========================================
        /**
         * Handles mouse movement for camera control and Podracer steering.
         * This function is complex because it manages multiple control schemes and visual feedback.
         * @param {MouseEvent} event - The browser's mouse event.
         */
        function handleMouseMove(event) {

            // --- 1. GET PLAYER & CHECK STATE ---
            // -------------------------------------
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            // If the game is paused, reset all mouse-related steering variables and do nothing else.
            if (isPaused) {
                mouseScreenOffsetX = 0.0;
                virtualSteeringWheelPosition = 0.0;
                virtualJoystickPitchPosition = 0.0;
                return;
            }

            // Get the horizontal (movementX) and vertical (movementY) mouse delta.
            let movementX = event.movementX || 0;
            let movementY = event.movementY || 0;

            // --- 2. BRANCH LOGIC BY CONTROL MODE ---
            // ---------------------------------------
            
            // --- 🏃‍♂️ FPS MODE LOGIC ---
            if (localPlayer.state.controlMode === ControlMode.FPS) {
                
                // In platformer mode, mouse movement orbits the camera around the player.
                if (localPlayer.state.isPlatformerCameraActive && controls && controls.isLocked) {
                    localPlayer.state.platformerCameraAzimuth -= movementX * FPS_PLATFORMER_MOUSE_SENSITIVITY_X;
                    localPlayer.state.platformerCameraElevation -= movementY * FPS_PLATFORMER_MOUSE_SENSITIVITY_Y;
                    
                    // Clamp the vertical elevation to prevent the camera from going upside down.
                    localPlayer.state.platformerCameraElevation = THREE.MathUtils.clamp(
                        localPlayer.state.platformerCameraElevation,
                        FPS_PLATFORMER_MIN_ELEVATION,
                        FPS_PLATFORMER_MAX_ELEVATION
                    );
                }
            
            // --- 🚀 PODRACER MODE LOGIC ---
            } else if (localPlayer.state.controlMode === ControlMode.PODRACER) {
                
                // Only process movement if the mouse pointer is locked.
                if (controls && controls.isLocked) {
                    const vs = localPlayer.state.vehicleState;
                    const vehicleInFlight = vs.isInFlightMode;

                    const isYawMouseNonSteering = (!vehicleInFlight && currentPodracerMouseSoloMode === PODRACER_MOUSE_SOLO_MODE.NON_STEERING) || (vehicleInFlight && currentPodracerMouseFlightMode === PODRACER_MOUSE_FLIGHT_MODE.NON_STEERING);
                    
                    // --- MOUSE YAW (Turning) LOGIC ---
                    if (isYawMouseNonSteering) {
                        // In "Non-Steering" (Rate) mode, mouse movement directly sets the turning velocity.
                        if (Math.abs(movementX) > PODRACER_MOUSE_NON_STEERING_DEADZONE) {
                            vs.yawVelocity = -movementX * (vehicleInFlight ? PODRACER_MOUSE_FLIGHT_YAW_DIRECT_SENSITIVITY_NON_STEERING : PODRACER_MOUSE_SOLO_YAW_DIRECT_SENSITIVITY_NON_STEERING);
                        }
                        vs.yawVelocity = THREE.MathUtils.clamp(vs.yawVelocity, -PODRACER_MAX_YAW_NON_STEERING_VELOCITY, PODRACER_MAX_YAW_NON_STEERING_VELOCITY);
                        
                        // Reset steering-mode variables.
                        virtualSteeringWheelPosition = 0.0;
                        mouseScreenOffsetX = 0.0;
                    } else { // Steering Mode
                        // In "Steering" mode, mouse movement acts like turning a virtual steering wheel.
                        virtualSteeringWheelPosition += movementX * PODRACER_MOUSE_YAW_MOVEMENT_SENSITIVITY_STEERING; 
                        virtualSteeringWheelPosition = THREE.MathUtils.clamp(virtualSteeringWheelPosition, -1.0, 1.0);
                        mouseScreenOffsetX = (Math.abs(virtualSteeringWheelPosition) > PODRACER_MOUSE_DEADZONE_X) ? virtualSteeringWheelPosition : 0.0;
                    }

                    // --- MOUSE PITCH (Up/Down) LOGIC (Flight Only) ---
                    if (vehicleInFlight) {
                        const isPitchMouseNonSteering = (currentPodracerMouseFlightMode === PODRACER_MOUSE_FLIGHT_MODE.NON_STEERING);
                        if (isPitchMouseNonSteering) {
                            // "Non-Steering" mode directly sets pitch velocity.
                            if (Math.abs(movementY) > PODRACER_MOUSE_NON_STEERING_DEADZONE) {
                                vs.pitchVelocity = -movementY * PODRACER_MOUSE_FLIGHT_PITCH_DIRECT_SENSITIVITY_NON_STEERING;
                            }
                            vs.pitchVelocity = THREE.MathUtils.clamp(vs.pitchVelocity, -PODRACER_MAX_PITCH_NON_STEERING_VELOCITY, PODRACER_MAX_PITCH_NON_STEERING_VELOCITY);
                            
                            // Reset steering-mode variable.
                            virtualJoystickPitchPosition = 0.0;
                        } else { // Steering Mode
                            // "Steering" mode acts like pushing/pulling a virtual joystick.
                            let effectivePitchSteeringInput = movementY;
                            if (Math.abs(movementY) < PODRACER_MOUSE_NON_STEERING_DEADZONE) { effectivePitchSteeringInput = 0; }
                            virtualJoystickPitchPosition -= effectivePitchSteeringInput * PODRACER_MOUSE_PITCH_MOVEMENT_SENSITIVITY_STEERING;
                            virtualJoystickPitchPosition = THREE.MathUtils.clamp(virtualJoystickPitchPosition, -1.0, 1.0);
                        }
                    } else {
                        // No mouse pitch control when on the ground.
                        virtualJoystickPitchPosition = 0.0;
                    }

                    // --- 🎨 VISUAL INDICATOR UPDATE ---
                    // This block updates the animated "V" shapes on screen for steering feedback.
                    // It's a complex piece of UI logic that reacts in real-time to the virtual controls.
                    
                    // --- YAW (Left/Right) INDICATOR ---
                    if (podracerMouseYawIndicatorElement && podracerMouseYawIndicatorElement.style.display === 'block') {
                        
                        // Determine the effective steering input, applying a deadzone.
                        let effectiveYawForVs = 0;
                        if (Math.abs(virtualSteeringWheelPosition) > PODRACER_MOUSE_DEADZONE_X) {
                            effectiveYawForVs = virtualSteeringWheelPosition;
                        }
                        const absYawForVs = Math.abs(effectiveYawForVs);
                        const yawThresholdForEffectVs = 0.005;

                        // Variables to hold the active UI elements.
                        let activeYawEffectContainer = null, activeYawEffectInstance = null, inactiveStaticVYawElement = null;
                        let activeYawColorEnd = '', activeYawGlowColor = '';

                        // First, hide all yaw indicator components.
                        if (staticLeftVElement) staticLeftVElement.style.display = 'none';
                        if (staticRightVElement) staticRightVElement.style.display = 'none';
                        if (leftArrowEffectContainer) leftArrowEffectContainer.style.display = 'none';
                        if (rightArrowEffectContainer) rightArrowEffectContainer.style.display = 'none';

                        // Determine which indicator set to use based on steering direction.
                        if (effectiveYawForVs < -yawThresholdForEffectVs) { // Steering Left
                            activeYawEffectContainer = leftArrowEffectContainer;
                            activeYawEffectInstance = leftArrowEffectInstance;
                            inactiveStaticVYawElement = staticRightVElement;
                            activeYawColorEnd = PODRACER_V_INDICATOR_YAW_LEFT_COLOR;
                            activeYawGlowColor = PODRACER_V_INDICATOR_YAW_LEFT_COLOR;
                        } else if (effectiveYawForVs > yawThresholdForEffectVs) { // Steering Right
                            activeYawEffectContainer = rightArrowEffectContainer;
                            activeYawEffectInstance = rightArrowEffectInstance;
                            inactiveStaticVYawElement = staticLeftVElement;
                            activeYawColorEnd = PODRACER_V_INDICATOR_YAW_RIGHT_COLOR;
                            activeYawGlowColor = PODRACER_V_INDICATOR_YAW_RIGHT_COLOR;
                        } else { // Centered
                            if (staticLeftVElement) staticLeftVElement.style.display = 'block';
                            if (staticRightVElement) staticRightVElement.style.display = 'block';
                            if (staticLeftVShape) staticLeftVShape.style.stroke = PODRACER_V_INDICATOR_DEFAULT_COLOR;
                            if (staticRightVShape) staticRightVShape.style.stroke = PODRACER_V_INDICATOR_DEFAULT_COLOR;
                            if (leftArrowEffectContainer) leftArrowEffectContainer.style.transform = 'translateX(0px) scale(1)';
                            if (rightArrowEffectContainer) rightArrowEffectContainer.style.transform = 'translateX(0px) scale(1)';
                        }

                        // If an indicator is active, update its position, scale, and animation properties.
                        if (activeYawEffectContainer && activeYawEffectInstance) {
                            activeYawEffectContainer.style.display = 'block';
                            const deflectionX = effectiveYawForVs * PODRACER_YAW_V_EFFECT_MAX_DEFLECTION_PX;
                            const containerCurrentScaleYaw = 1.0 + (absYawForVs * PODRACER_V_INDICATOR_MAX_SCALE_FACTOR);
                            activeYawEffectContainer.style.transform = `translateX(${deflectionX}px) scale(${containerCurrentScaleYaw})`;
                            
                            // Update the configuration of the ConveyorArrowEffect instance.
                            activeYawEffectInstance.updateConfig({
                                colorStart: PODRACER_V_INDICATOR_CONVEYOR_START_COLOR,
                                colorEnd: activeYawColorEnd,
                                enableGlow: true,
                                colorGlow: activeYawGlowColor,
                                blurGlow: Math.round(PODRACER_V_INDICATOR_TARGET_GLOW_BLUR),
                                overallOpacityFinal: PODRACER_V_INDICATOR_TARGET_OPACITY,
                                animScaleFinal: PODRACER_V_INDICATOR_TARGET_SCALE,
                            });
                        }
                        
                        // Show the static "V" on the opposite side.
                        if (inactiveStaticVYawElement) inactiveStaticVYawElement.style.display = 'block';
                    }

                    // --- PITCH (Up/Down) INDICATOR ---
                    if (podracerMousePitchIndicatorElement && podracerMousePitchIndicatorElement.style.display === 'block') {
                        
                        const absPitch = Math.abs(virtualJoystickPitchPosition);
                        const pitchThresholdForEffectVs = 0.005;
                        
                        let activePitchEffectContainer = null, activePitchEffectInstance = null, inactiveStaticVPitchElement = null;
                        let activePitchColorEnd = '', activePitchGlowColor = '';
                        
                        // Hide all pitch indicators first.
                        if (staticTopVElement) staticTopVElement.style.display = 'none';
                        if (staticBottomVElement) staticBottomVElement.style.display = 'none';
                        if (topArrowEffectContainer) topArrowEffectContainer.style.display = 'none';
                        if (bottomArrowEffectContainer) bottomArrowEffectContainer.style.display = 'none';
                        
                        // Determine active indicator based on pitch direction.
                        if (virtualJoystickPitchPosition > pitchThresholdForEffectVs) { // Pitching Up
                            activePitchEffectContainer = topArrowEffectContainer;
                            activePitchEffectInstance = topArrowEffectInstance;
                            inactiveStaticVPitchElement = staticBottomVElement;
                            activePitchColorEnd = PODRACER_V_INDICATOR_PITCH_UP_COLOR;
                            activePitchGlowColor = PODRACER_V_INDICATOR_PITCH_UP_COLOR;
                        } else if (virtualJoystickPitchPosition < -pitchThresholdForEffectVs) { // Pitching Down
                            activePitchEffectContainer = bottomArrowEffectContainer;
                            activePitchEffectInstance = bottomArrowEffectInstance;
                            inactiveStaticVPitchElement = staticTopVElement;
                            activePitchColorEnd = PODRACER_V_INDICATOR_PITCH_DOWN_COLOR;
                            activePitchGlowColor = PODRACER_V_INDICATOR_PITCH_DOWN_COLOR;
                        } else { // Centered
                            if (staticTopVElement) staticTopVElement.style.display = 'block';
                            if (staticBottomVElement) staticBottomVElement.style.display = 'block';
                            if (staticTopVShape) staticTopVShape.style.stroke = PODRACER_V_INDICATOR_DEFAULT_COLOR;
                            if (staticBottomVShape) staticBottomVShape.style.stroke = PODRACER_V_INDICATOR_DEFAULT_COLOR;
                            if (topArrowEffectContainer) topArrowEffectContainer.style.transform = 'translateY(0px) scale(1)';
                            if (bottomArrowEffectContainer) bottomArrowEffectContainer.style.transform = 'translateY(0px) scale(1)';
                        }

                        // If a pitch indicator is active, update its properties.
                        if (activePitchEffectContainer && activePitchEffectInstance) {
                            activePitchEffectContainer.style.display = 'block';
                            let deflectionY = 0;
                            if (activePitchEffectContainer === topArrowEffectContainer) {
                                deflectionY = (PODRACER_PITCH_V_TOP_STATIC_OFFSET_PX - PODRACER_PITCH_V_EFFECT_BASE_OFFSET_PX - 9) - (absPitch * PODRACER_PITCH_V_EFFECT_MAX_DEFLECTION_PX);
                            } else {
                                deflectionY = (PODRACER_PITCH_V_BOTTOM_STATIC_OFFSET_PX + PODRACER_PITCH_V_EFFECT_BASE_OFFSET_PX + 9) + (absPitch * PODRACER_PITCH_V_EFFECT_MAX_DEFLECTION_PX);
                            }
                            const containerCurrentScalePitch = 1.0 + (absPitch * PODRACER_V_INDICATOR_MAX_SCALE_FACTOR);
                            activePitchEffectContainer.style.transform = `translateX(-50%) translateY(${deflectionY}px) scale(${containerCurrentScalePitch})`;
                            
                            activePitchEffectInstance.updateConfig({
                                colorStart: PODRACER_V_INDICATOR_CONVEYOR_START_COLOR,
                                colorEnd: activePitchColorEnd,
                                enableGlow: true,
                                colorGlow: activePitchGlowColor,
                                blurGlow: Math.round(PODRACER_V_INDICATOR_TARGET_GLOW_BLUR),
                                overallOpacityFinal: PODRACER_V_INDICATOR_TARGET_OPACITY,
                                animScaleFinal: PODRACER_V_INDICATOR_TARGET_SCALE,
                            });
                        }
                        
                        // Show the opposing static indicator.
                        if (inactiveStaticVPitchElement) inactiveStaticVPitchElement.style.display = 'block';
                    }
                }
            }
        }

        // ==========================================
        // 🖱️ MOUSE WHEEL HANDLER
        // ==========================================
        /**
         * Handles mouse wheel scrolling for Podracer thrust and FPS camera zoom.
         * @param {WheelEvent} event - The browser's wheel event.
         */
        function handleMouseWheel(event) {
            
            if (isPaused) return;
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            // --- 🚀 PODRACER MODE: ADJUST THRUST ---
            if (localPlayer.state.controlMode === ControlMode.PODRACER) {
                const vs = localPlayer.state.vehicleState;
                
                const scrollDirectionPod = Math.sign(event.deltaY); // -1 for scroll up, 1 for scroll down.
                const thrustAdjustmentStep = PODRACER_THRUST_ADJUST_RATE * 0.1;
                
                // Adjust the thrust level based on scroll direction.
                if (scrollDirectionPod < 0) { // Scroll Up
                    vs.thrustLevel = Math.min(PODRACER_MAX_FORWARD_THRUST_NORMALIZED, vs.thrustLevel + thrustAdjustmentStep);
                } else if (scrollDirectionPod > 0) { // Scroll Down
                    vs.thrustLevel = Math.max(PODRACER_MAX_REVERSE_THRUST_NORMALIZED, vs.thrustLevel - thrustAdjustmentStep);
                }
                
                event.preventDefault(); // Stop the page from scrolling.
            
            // --- 🏃‍♂️ FPS MODE: ADJUST CAMERA ZOOM ---
            } else if (localPlayer.state.controlMode === ControlMode.FPS && localPlayer.state.isThirdPersonActive) {
                event.preventDefault();
                localPlayer.state.thirdPersonZoomDistance += Math.sign(event.deltaY) * FPS_THIRD_PERSON_ZOOM_SENSITIVITY;
                localPlayer.state.thirdPersonZoomDistance = THREE.MathUtils.clamp(
                    localPlayer.state.thirdPersonZoomDistance, FPS_THIRD_PERSON_MIN_ZOOM_DISTANCE, FPS_THIRD_PERSON_MAX_ZOOM_DISTANCE
                );
            } else if (localPlayer.state.controlMode === ControlMode.FPS && localPlayer.state.isPlatformerCameraActive) {
                event.preventDefault();
                localPlayer.state.platformerCameraDistance += Math.sign(event.deltaY) * FPS_PLATFORMER_ZOOM_SENSITIVITY;
                localPlayer.state.platformerCameraDistance = THREE.MathUtils.clamp(
                    localPlayer.state.platformerCameraDistance, FPS_PLATFORMER_MIN_DISTANCE, FPS_PLATFORMER_MAX_DISTANCE
                );
            }
        }


        // ===================================================================
        // SECTION 7: MAIN GAME LOGIC
        // ===================================================================
        // This is the core of the game simulation. It includes processing local input,
        // applying physics for movement, updating animations, and handling remote players.

        // ==========================================
        // 🧠 PROCESS LOCAL PLAYER INPUT
        // ==========================================
        /**
         * Translates the raw hardware state (`keyboard` object) into player intentions,
         * which are stored in the `player.state` object. This function is the bridge
         * between what the player *presses* and what the character *intends to do*.
         * It runs once per frame for the local player only.
         * @param {object} player - The local player object.
         * @param {number} deltaTime - The time elapsed since the last frame.
         */
        function processLocalInput(player, deltaTime) {

            // --- 🛑 Safety Check ---
            // If there's no player or player state, we can't do anything.
            if (!player || !player.state) return;

            // Create convenient shortcuts to the player's state.
            const state = player.state;
            const vs = state.vehicleState;

            // --- 🏃‍♂️ FPS MODE ---
            // Logic for when the player is on foot.
            if (state.controlMode === ControlMode.FPS) {
                
                // Read keyboard for forward, backward, and sprinting states.
                state.moveForward = keyboard['KeyW'] || keyboard['ArrowUp'] || false;
                state.moveBackward = keyboard['KeyS'] || keyboard['ArrowDown'] || false;
                state.isSprinting = keyboard['ShiftLeft'] || keyboard['ShiftRight'] || false;
                
                // A/D keys behave differently depending on the camera mode.
                if (state.isPlatformerCameraActive) {
                    // In Platformer mode, A/D are for TURNING the character, not strafing.
                    // We set strafe intentions to false so the animation and movement logic work correctly.
                    state.moveLeft = false;
                    state.moveRight = false;
                } else {
                    // In 1st/3rd Person modes, A/D are for STRAFING (side-stepping).
                    state.moveLeft = keyboard['KeyA'] || keyboard['ArrowLeft'] || false;
                    state.moveRight = keyboard['KeyD'] || keyboard['ArrowRight'] || false;
                }
            }
            // --- 🚀 PODRACER MODE ---
            // Logic for when the player is in the vehicle.
            else if (state.controlMode === ControlMode.PODRACER) {
                
                // --- A. Simple On/Off States ---
                // These are direct boolean flags set from keyboard state.
                vs.isJumping = keyboard['KeyX'] || false;
                vs.isAeroBraking = keyboard['Space'] || false;
                vs.isApplyingDownForce = (vs.isInFlightMode && (keyboard['AltLeft'] || false));

                // --- B. Complex Thrust (Engine Power) Logic ---
                
                // 1. THROTTLE Mode Logic: Gradually adjusts thrust level.
                let throttleAdjustment = 0;
                // W/S keys adjust thrust in SOLO mode if set to THROTTLE.
                if (!vs.isInFlightMode && currentPodracerSoloWSAccelMode === PODRACER_SOLO_WS_ACCEL_MODE.THROTTLE) {
                    if (keyboard['KeyW']) throttleAdjustment += PODRACER_THRUST_ADJUST_RATE * deltaTime;
                    if (keyboard['KeyS']) throttleAdjustment -= PODRACER_THRUST_ADJUST_RATE * deltaTime;
                }
                // Arrow keys adjust thrust in ALL modes if set to THROTTLE.
                if (currentPodracerArrowsAccelMode === PODRACER_ARROWS_ACCEL_MODE.THROTTLE) {
                    if (keyboard['ArrowUp']) throttleAdjustment += PODRACER_THRUST_ADJUST_RATE * deltaTime;
                    if (keyboard['ArrowDown']) throttleAdjustment -= PODRACER_THRUST_ADJUST_RATE * deltaTime;
                }
                // Plus/Minus keys also adjust thrust.
                if (keyboard['Equal']) throttleAdjustment += PODRACER_THRUST_ADJUST_RATE * deltaTime;
                if (keyboard['Minus']) throttleAdjustment -= PODRACER_THRUST_ADJUST_RATE * deltaTime;
                
                // Apply the adjustment and clamp it within valid limits.
                vs.thrustLevel += throttleAdjustment;
                vs.thrustLevel = THREE.MathUtils.clamp(vs.thrustLevel, PODRACER_MAX_REVERSE_THRUST_NORMALIZED, PODRACER_MAX_FORWARD_THRUST_NORMALIZED);

                // 2. RACE Mode Logic: Instantly sets thrust to max forward or reverse.
                vs.isRaceThrusting = false; // Reset to false each frame.
                // W/S keys in SOLO mode if set to RACE.
                if (!vs.isInFlightMode && currentPodracerSoloWSAccelMode === PODRACER_SOLO_WS_ACCEL_MODE.RACE) {
                    if (keyboard['KeyW']) { vs.isRaceThrusting = true; vs.raceThrustDirection = 1; }
                    else if (keyboard['KeyS']) { vs.isRaceThrusting = true; vs.raceThrustDirection = -1; }
                }
                // Arrow keys in ALL modes if set to RACE.
                if (!vs.isRaceThrusting && currentPodracerArrowsAccelMode === PODRACER_ARROWS_ACCEL_MODE.RACE) {
                    if (keyboard['ArrowUp']) { vs.isRaceThrusting = true; vs.raceThrustDirection = 1; }
                    else if (keyboard['ArrowDown']) { vs.isRaceThrusting = true; vs.raceThrustDirection = -1; }
                }

                // 3. Emergency Thrust Cutoff (Key 0).
                if (keyboard['Digit0']) {
                    vs.thrustLevel = 0.0;
                    vs.isRaceThrusting = false;
                    keyboard['Digit0'] = false; // Consume the input so it doesn't repeat.
                }

                // --- C. Rotational & Directional Logic ---
                // Key mappings change depending on whether the Podracer is in flight or on the ground.
                if (vs.isInFlightMode) {
                    // Flight controls: Standard aircraft-style controls.
                    state.moveForward = keyboard['KeyW'] || false;          // Pitch Down
                    state.moveBackward = keyboard['KeyS'] || false;         // Pitch Up
                    state.moveLeft = keyboard['KeyQ'] || keyboard['ArrowLeft'] || false;   // Yaw Left
                    state.moveRight = keyboard['KeyE'] || keyboard['ArrowRight'] || false;  // Yaw Right
                    vs.isRollingLeft = keyboard['KeyA'] || false;           // Roll Left
                    vs.isRollingRight = keyboard['KeyD'] || false;          // Roll Right
                    vs.isStrafingLeftInFlight = keyboard['KeyZ'] || false;  // Strafe Left
                    vs.isStrafingRightInFlight = keyboard['KeyC'] || false; // Strafe Right
                } else { // Solo (Ground) mode
                    // Ground controls depend on the user's selected key layout in the pause menu.
                    if (currentPodracerSoloKeyControlMode === PODRACER_SOLO_KEY_CONTROL_MODE.STRAFE_AD_YAW_QE) {
                        vs.isStrafingLeft = keyboard['KeyA'] || false;
                        vs.isStrafingRight = keyboard['KeyD'] || false;
                        state.moveLeft = keyboard['KeyQ'] || false;     // Yaw Left
                        state.moveRight = keyboard['KeyE'] || false;    // Yaw Right
                    } else { // YAW_AD_STRAFE_QE
                        state.moveLeft = keyboard['KeyA'] || false;     // Yaw Left
                        state.moveRight = keyboard['KeyD'] || false;    // Yaw Right
                        vs.isStrafingLeft = keyboard['KeyQ'] || false;
                        vs.isStrafingRight = keyboard['KeyE'] || false;
                    }
                    // Arrow keys are always for yawing.
                    if (keyboard['ArrowLeft']) state.moveLeft = true;
                    if (keyboard['ArrowRight']) state.moveRight = true;
                }
            }
        }

        // ==========================================
        // 🏃‍♂️ PLAYER FPS MOVEMENT PHYSICS
        // ==========================================
        /**
         * Applies forces and velocities to the player's physics body based on their current state.
         * This function handles movement, jumping, slope calculations, and air control.
         * @param {number} deltaTime - The time since the last frame.
         * @param {object} localPlayer - The local player object.
         */
        function handlePlayerFPSMovement(deltaTime, localPlayer) {

            // --- 🛑 Safety Checks ---
            if (!localPlayer || !localPlayer.body || !controls.isLocked || localPlayer.body.isSleeping()) return;
            const localPlayerBody = localPlayer.body;
            const localPlayerCollider = localPlayerBody.collider(0);
            if (!localPlayerCollider) return;
            
            // --- 🧹 Cleanup & Initialization ---
            clearPlayerAirWallRayHelper(); // Remove debug line from previous frame.
            let groundInfo = { isGrounded: false, isWalkable: false, normal: null };
            const raycastResults = [];
            const playerPos = localPlayerBody.translation();
            const playerRot = localPlayerBody.rotation();
            const playerQuat = new THREE.Quaternion(playerRot.x, playerRot.y, playerRot.z, playerRot.w);

            // --- 🌎 Ground Detection (Multi-Raycast) ---
            // Cast 5 rays downwards from under the player capsule to check for ground contact.
            for (let i = 0; i < 5; i++) {
                // Calculate ray origin (center + 4 points around the edge).
                const angle = (i / 4) * Math.PI * 2;
                const offsetX = i === 0 ? 0 : Math.cos(angle) * PLAYER_RADIUS;
                const offsetZ = i === 0 ? 0 : Math.sin(angle) * PLAYER_RADIUS;
                
                // Set ray properties.
                const rayOrigin = { x: playerPos.x + offsetX, y: playerPos.y - (PLAYER_HEIGHT / 2) + PLAYER_RADIUS + 0.1, z: playerPos.z + offsetZ };
                const rayDir = { x: 0, y: -1, z: 0 };
                const rayLength = PLAYER_RADIUS + 0.3; 
                
                // Cast the ray into the physics world.
                const ray = new RAPIER.Ray(rayOrigin, rayDir);
                const hit = physicsWorld.castRayAndGetNormal(ray, rayLength, true, RAPIER.QueryFilterFlags.EXCLUDE_DYNAMIC, undefined, localPlayerCollider);
                if (hit) { raycastResults.push(hit); } // Store successful hits.

                // Lógica para atualizar o helper visual do raio de detecção de solo.
                if (isDebugVisible && playerGroundRayHelpers[i]) {
                    const helper = playerGroundRayHelpers[i];
                    const startPoint = new THREE.Vector3(rayOrigin.x, rayOrigin.y, rayOrigin.z);
                    const direction = new THREE.Vector3(rayDir.x, rayDir.y, rayDir.z);
                    let endPoint;
                    
                    if (hit) {
                        // Se o raio acertou, o ponto final é o local da colisão.
                        endPoint = startPoint.clone().add(direction.multiplyScalar(hit.timeOfImpact));
                        helper.material.color.setHex(0x00ff00); // Verde para colisão
                    } else {
                        // Se o raio não acertou, o ponto final é o comprimento máximo do raio.
                        endPoint = startPoint.clone().add(direction.multiplyScalar(rayLength));
                        helper.material.color.setHex(0xff0000); // Vermelho para sem colisão
                    }
                    
                    // Atualiza a geometria da linha para conectar os novos pontos.
                    helper.geometry.setFromPoints([startPoint, endPoint]);
                    helper.geometry.computeBoundingSphere(); // Necessário para a visibilidade correta.
                }
            }
            
            // Analyze raycast results to determine ground state.
            if (raycastResults.length > 0) {
                groundInfo.isGrounded = true;
                let bestHit = raycastResults[0]; // Find the "flattest" surface hit.
                for (let i = 1; i < raycastResults.length; i++) { if (raycastResults[i].normal.y > bestHit.normal.y) { bestHit = raycastResults[i]; } }
                groundInfo.normal = new THREE.Vector3(bestHit.normal.x, bestHit.normal.y, bestHit.normal.z);
                // Check if the slope is shallow enough to be "walkable".
                if (UP_VECTOR.dot(groundInfo.normal) > PLAYER_GROUND_CONTROL.MAX_SLOPE_COS_ANGLE) { groundInfo.isWalkable = true; }
            }

            // --- 🤸‍♂️ Jump Logic ---
            localPlayer.state.canJump = groundInfo.isGrounded;
            if (localPlayer.state.canJump) {
                localPlayer.state.jumpFuel = PLAYER_JUMP_FUEL_DURATION; // Refill jump fuel on ground.
            }
            // Apply jump impulse if space is held and there is fuel.
            if (keyboard['Space'] && localPlayer.state.jumpFuel > 0) {
                localPlayerBody.applyImpulse({ y: PLAYER_JUMP_THRUST_FORCE * deltaTime, x: 0, z: 0 }, true);
                localPlayer.state.jumpFuel -= deltaTime;
            }

            // --- 💨 Movement Logic ---
            const currentLinvel = localPlayerBody.linvel();
            const targetSpeed = localPlayer.state.isSprinting ? PLAYER_MOVE_SPEED * SPRINT_MULTIPLIER : PLAYER_MOVE_SPEED;
            let worldMoveDir = new THREE.Vector3(); 
            
            // Calculate desired movement direction based on camera mode.
            if (localPlayer.state.isPlatformerCameraActive) {
                // Platformer mode: A/D rotates the character. W/S moves forward/backward relative to character.
                let yawChange = 0;
                if (keyboard['KeyA']) yawChange = PLAYER_PLATFORMER_YAW_SPEED * deltaTime;
                else if (keyboard['KeyD']) yawChange = -PLAYER_PLATFORMER_YAW_SPEED * deltaTime;
                if (Math.abs(yawChange) > 0.001) {
                    const currentRotationRapier = localPlayerBody.rotation();
                    const currentRotationThree = new THREE.Quaternion(currentRotationRapier.x, currentRotationRapier.y, currentRotationRapier.z, currentRotationRapier.w);
                    const yawDeltaQuaternion = new THREE.Quaternion().setFromAxisAngle(UP_VECTOR, yawChange);
                    currentRotationThree.multiply(yawDeltaQuaternion);
                    localPlayerBody.setRotation(currentRotationThree, true);
                }
                let moveDirectionFactor = 0;
                if (keyboard['KeyW']) moveDirectionFactor = 1.0;
                else if (keyboard['KeyS']) moveDirectionFactor = -1.0;
                if (moveDirectionFactor !== 0) {
                    const playerRotationRapier = localPlayerBody.rotation();
                    const playerQuaternionThree = new THREE.Quaternion(playerRotationRapier.x, playerRotationRapier.y, playerRotationRapier.z, playerRotationRapier.w);
                    worldMoveDir.set(0, 0, -1).applyQuaternion(playerQuaternionThree).multiplyScalar(moveDirectionFactor);
                    worldMoveDir.y = 0;
                    worldMoveDir.normalize();
                }
            } else {
                // 1st/3rd Person mode: Movement is relative to the camera direction.
                const inputDir = new THREE.Vector3(Number(localPlayer.state.moveRight) - Number(localPlayer.state.moveLeft), 0, Number(localPlayer.state.moveBackward) - Number(localPlayer.state.moveForward));
                if (inputDir.lengthSq() > 0.001) {
                    const cameraQuaternion = controls.getObject().quaternion.clone();
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cameraQuaternion);
                    forward.y = 0;
                    forward.normalize();
                    const right = new THREE.Vector3().crossVectors(UP_VECTOR, forward).normalize();
                    worldMoveDir.addScaledVector(forward, -inputDir.z).addScaledVector(right, -inputDir.x).normalize();
                }
            }
            
            // --- 👟 Applying Final Velocity ---
            const finalVelocity = new THREE.Vector3(currentLinvel.x, currentLinvel.y, currentLinvel.z);
            let desiredVelocity = new THREE.Vector3(worldMoveDir.x * targetSpeed, currentLinvel.y, worldMoveDir.z * targetSpeed);
            
            if (groundInfo.isGrounded) {
                // Ground Movement: Adjust direction to follow slopes.
                if (worldMoveDir.lengthSq() > 0.001) {
                    if (groundInfo.isWalkable) {
                        const projection = groundInfo.normal.clone().multiplyScalar(worldMoveDir.dot(groundInfo.normal));
                        worldMoveDir.sub(projection).normalize();
                        desiredVelocity.x = worldMoveDir.x * targetSpeed;
                        desiredVelocity.z = worldMoveDir.z * targetSpeed;
                        desiredVelocity.y = worldMoveDir.y * targetSpeed;
                    } 
                }
                finalVelocity.lerp(desiredVelocity, PLAYER_ACCELERATION * deltaTime);
            } else {
                // Air Movement: Apply air control factor.
                let isWallNearby = false;
                if (worldMoveDir.lengthSq() > 0.001) {
                    // Cast a ray forward to check for walls, reducing air control if near one.
                    const ray = new RAPIER.Ray({x: playerPos.x, y: playerPos.y, z: playerPos.z}, { x: worldMoveDir.x, y: 0, z: worldMoveDir.z });
                    const hit = physicsWorld.castRay(ray, PLAYER_AIR_WALL_DETECT_DISTANCE, true, RAPIER.QueryFilterFlags.EXCLUDE_DYNAMIC, undefined, localPlayerCollider);
                    if (hit) { isWallNearby = true; }

                    // Lógica para desenhar o helper visual do raio de detecção de parede.
                    if (isDebugVisible) {
                        const startPoint = new THREE.Vector3(playerPos.x, playerPos.y, playerPos.z);
                        const endPoint = startPoint.clone().add(worldMoveDir.clone().multiplyScalar(PLAYER_AIR_WALL_DETECT_DISTANCE));
                        const color = hit ? 0x00ff00 : 0x00ffff; // Verde se acertar, ciano se errar
                        const geometry = new THREE.BufferGeometry().setFromPoints([startPoint, endPoint]);
                        const material = new THREE.LineBasicMaterial({ color: color });
                        lastAirWallRayHelper = new THREE.Line(geometry, material);
                        scene.add(lastAirWallRayHelper);
                    }
                }
                const airControlToUse = isWallNearby ? PLAYER_AIR_CONTROL_FACTOR : PLAYER_FULL_AIR_CONTROL_FACTOR;
                const airFactor = PLAYER_ACCELERATION * airControlToUse * deltaTime;
                finalVelocity.x = THREE.MathUtils.lerp(finalVelocity.x, desiredVelocity.x, airFactor);
                finalVelocity.z = THREE.MathUtils.lerp(finalVelocity.z, desiredVelocity.z, airFactor);
            }

            // Set the final calculated velocity on the physics body.
            localPlayerBody.setLinvel({ x: finalVelocity.x, y: finalVelocity.y, z: finalVelocity.z }, true);
        }


        // ========================================================================
        // --- 🚀 PODRACER MOVEMENT & ANTI-GRAVITY LOGIC ---
        // ========================================================================
        /**
         * This function is the core of the Podracer's physics simulation. It handles everything
         * from thrust and rotation to the complex anti-gravity hover, stabilization, and
         * flight mode systems. It reads the local player's state and applies forces and
         * torques to the Podracer's Rapier rigid body.
         * @param {number} deltaTime - The time elapsed since the last frame.
         * @param {object} localPodracer - The vehicle object belonging to the local player.
         */
        function handlePodracerMovement(deltaTime, localPodracer) {

            // --- A. PRE-FLIGHT CHECKS & SETUP ---

            // Define the collision group for the hover system's raycasts.
            // The ray BELONGS to the HOVER_RAY group and will ONLY INTERACT with
            // objects in the GENERAL group (e.g., the terrain).
            const hoverRayGroupBitmask = createInteractionGroups(COLLISION_GROUP_HOVER_RAY, COLLISION_GROUP_GENERAL);

            // Guard clause: Exit if the Podracer object or its physics body is invalid or asleep.
            if (!localPodracer || !localPodracer.body || localPodracer.body.isSleeping()) return;
            
            // Get the local player and a shortcut to the vehicle's state.
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;
            const vs = localPlayer.state.vehicleState; // Vehicle State shortcut

            // Get the physics body and its primary collider.
            const localPodracerBody = localPodracer.body;
            const localPodracerCollider = localPodracerBody.collider(0); 
            if (!localPodracerCollider) return;

            // Gather current physics data from the rigid body.
            const pos = localPodracerBody.translation();
            const rot = localPodracerBody.rotation();
            const linvel = localPodracerBody.linvel();
            const angvel = localPodracerBody.angvel();
            const podracerMass = localPodracerBody.mass();

            // Convert Rapier's data types to Three.js equivalents for easier vector math.
            const threeQuat = new THREE.Quaternion(rot.x, rot.y, rot.z, rot.w);
            const podracerPositionVec3 = new THREE.Vector3(pos.x, pos.y, pos.z);
            const worldVelVec3 = new THREE.Vector3(linvel.x, linvel.y, linvel.z);

            // Clear any debug lines from the previous frame.
            if (isDebugVisible) {
                clearPodracerDebugLines();
            }
                
            // ========================================================================
            // --- 1. THRUST CALCULATION & APPLICATION ---
            // ========================================================================
            // This block determines the final thrust force based on player input
            // (Race mode vs. Throttle mode) and applies a speed-limiting governor.
            // ========================================================================
            {
                let finalThrustNormalized = 0.0;

                // Race mode has absolute priority over throttle mode.
                if (vs.isRaceThrusting) {
                    finalThrustNormalized = vs.raceThrustDirection === 1 
                        ? PODRACER_MAX_FORWARD_THRUST_NORMALIZED 
                        : PODRACER_MAX_REVERSE_THRUST_NORMALIZED;
                } else {
                    finalThrustNormalized = vs.thrustLevel;
                }
                
                // --- Speed Limiter (Governor) Logic ---
                const worldForwardDirThrust = FORWARD_VECTOR.clone().applyQuaternion(threeQuat).normalize();
                const currentForwardSpeedMs = worldVelVec3.dot(worldForwardDirThrust);
                const playerDesiredForceMagnitude = Math.abs(finalThrustNormalized) * PODRACER_MAX_THRUST_FORCE;
                let actualAppliedForceMagnitude = playerDesiredForceMagnitude;

                // Only apply the speed limiter if thrust is active.
                if (Math.abs(finalThrustNormalized) > PODRACER_THRUST_APPLICATION_THRESHOLD) {
                    
                    // Forward speed governor.
                    if (finalThrustNormalized > 0) {
                        const thrustPercentageForward = finalThrustNormalized / PODRACER_MAX_FORWARD_THRUST_NORMALIZED;
                        const dynamicMaxAllowedForwardSpeedMs = thrustPercentageForward * PODRACER_MAX_FORWARD_SPEED_MS;
                        if (currentForwardSpeedMs > dynamicMaxAllowedForwardSpeedMs) {
                            const speedRatio = dynamicMaxAllowedForwardSpeedMs > 0.01 ? (currentForwardSpeedMs / dynamicMaxAllowedForwardSpeedMs) : 1.0;
                            const forceReductionFactor = Math.max(0.0, 1.0 - (speedRatio - 1.0) * PODRACER_SPEED_LIMIT_REDUCTION_FACTOR);
                            actualAppliedForceMagnitude = playerDesiredForceMagnitude * forceReductionFactor;
                        }
                    
                    // Reverse speed governor.
                    } else if (finalThrustNormalized < 0) {
                        const currentReverseSpeedMs = Math.abs(currentForwardSpeedMs);
                        const thrustPercentageReverse = finalThrustNormalized / PODRACER_MAX_REVERSE_THRUST_NORMALIZED;
                        const dynamicMaxAllowedReverseSpeedMs = thrustPercentageReverse * PODRACER_MAX_REVERSE_SPEED_MS;
                        if (currentReverseSpeedMs > dynamicMaxAllowedReverseSpeedMs) {
                            const speedRatioReverse = dynamicMaxAllowedReverseSpeedMs > 0.01 ? (currentReverseSpeedMs / dynamicMaxAllowedReverseSpeedMs) : 1.0;
                            const forceReductionFactorReverse = Math.max(0.0, 1.0 - (speedRatioReverse - 1.0) * PODRACER_SPEED_LIMIT_REDUCTION_FACTOR);
                            actualAppliedForceMagnitude = playerDesiredForceMagnitude * forceReductionFactorReverse;
                        }
                    }
                } else {
                    actualAppliedForceMagnitude = 0;
                }

                // --- Apply Final Thrust Impulse ---
                if (actualAppliedForceMagnitude > PODRACER_THRUST_APPLICATION_THRESHOLD) {
                    let thrustDirectionLocal = FORWARD_VECTOR.clone();
                    if (finalThrustNormalized < 0) {
                        thrustDirectionLocal.negate();
                    }
                    const thrustDirectionWorld = thrustDirectionLocal.applyQuaternion(threeQuat);
                    const thrustImpulse = thrustDirectionWorld.multiplyScalar(actualAppliedForceMagnitude * deltaTime);
                    localPodracerBody.applyImpulse(thrustImpulse, true);
                }
            }
                                                                     
            // ========================================================================
            // --- 2. ROTATIONAL CONTROL (YAW, PITCH, ROLL) ---
            // ========================================================================
            // This block implements a PID-like controller to match the vehicle's
            // angular velocity to the player's desired rotation rates from mouse and keyboard.
            // ========================================================================
            {
                // Get current world angular velocity and local axes.
                const worldAngVelVec3 = new THREE.Vector3(angvel.x, angvel.y, angvel.z);
                const podracerUp = UP_VECTOR.clone().applyQuaternion(threeQuat);
                const podracerRight = new THREE.Vector3(1, 0, 0).applyQuaternion(threeQuat);
                const podracerForward = FORWARD_VECTOR.clone().applyQuaternion(threeQuat);
                
                // Project world angular velocity onto local axes to find current rotation rates.
                const currentActualYawRate = worldAngVelVec3.dot(podracerUp);
                const currentActualPitchRate = worldAngVelVec3.dot(podracerRight);
                const currentActualRollRate = worldAngVelVec3.dot(podracerForward);
                
                let finalTargetYawVelocity;
                let currentYawKpToUse;
                const isYawMouseNonSteering = (!vs.isInFlightMode && currentPodracerMouseSoloMode === PODRACER_MOUSE_SOLO_MODE.NON_STEERING) || (vs.isInFlightMode && currentPodracerMouseFlightMode === PODRACER_MOUSE_FLIGHT_MODE.NON_STEERING);

                // --- Yaw (Turning) Logic ---
                if (isYawMouseNonSteering) {
                    // Non-Steering (Rate) Mode: Mouse directly sets target angular velocity.
                    currentYawKpToUse = PODRACER_YAW_KP_NON_STEERING;
                    let desiredKeyYawRateForNonSteering = 0;
                    if (localPlayer.state.moveLeft) { desiredKeyYawRateForNonSteering = PODRACER_KEY_MAX_YAW_VELOCITY_FOR_NON_STEERING_MOUSE; }
                    else if (localPlayer.state.moveRight) { desiredKeyYawRateForNonSteering = -PODRACER_KEY_MAX_YAW_VELOCITY_FOR_NON_STEERING_MOUSE; }
                    
                    let yawKeyLerpFactor = (desiredKeyYawRateForNonSteering === 0) ? PODRACER_KEY_YAW_DECELERATION_FOR_NON_STEERING_MOUSE * deltaTime : PODRACER_KEY_YAW_ACCELERATION_FOR_NON_STEERING_MOUSE * deltaTime;
                    vs.keyYawRate = THREE.MathUtils.lerp(vs.keyYawRate, desiredKeyYawRateForNonSteering, yawKeyLerpFactor);
                    if (desiredKeyYawRateForNonSteering === 0 && Math.abs(vs.keyYawRate) < PODRACER_YAW_VELOCITY_ZERO_THRESHOLD) { vs.keyYawRate = 0; }
                    
                    if (targetPodracerYawRateFromMouse === 0 && desiredKeyYawRateForNonSteering === 0) { vs.yawVelocity *= (1.0 - PODRACER_YAW_DAMPING_FACTOR_NON_STEERING); }
                    
                    if (desiredKeyYawRateForNonSteering !== 0) {
                        finalTargetYawVelocity = vs.keyYawRate;
                        currentYawKpToUse = PODRACER_KEY_YAW_KP_FOR_NON_STEERING_MOUSE;
                        vs.yawVelocity = vs.keyYawRate;
                    } else {
                        finalTargetYawVelocity = vs.yawVelocity;
                    }
                    
                    if (desiredKeyYawRateForNonSteering === 0 && targetPodracerYawRateFromMouse === 0 && Math.abs(finalTargetYawVelocity) < PODRACER_YAW_VELOCITY_ZERO_THRESHOLD_MOUSE_INPUT) { finalTargetYawVelocity = 0; vs.yawVelocity = 0; vs.keyYawRate = 0; }
                     virtualSteeringWheelPosition = 0.0; mouseScreenOffsetX = 0.0;
                
                } else {
                    // Steering Mode: Mouse and keyboard contribute to a final target rate.
                    currentYawKpToUse = PODRACER_YAW_KP_SHARED;
                    let yawInputFromKeyboard = 0;
                    if (localPlayer.state.moveLeft) { yawInputFromKeyboard = 1; }
                    else if (localPlayer.state.moveRight) { yawInputFromKeyboard = -1; }
                    
                    let targetYawRateFromKeyboard = yawInputFromKeyboard * PODRACER_MAX_YAW_VELOCITY;
                    let keyboardYawLerpFactor = (yawInputFromKeyboard === 0) ? PODRACER_KEY_YAW_DECELERATION_WHEN_MOUSE_STEERING * deltaTime : PODRACER_KEY_YAW_ACCELERATION_WHEN_MOUSE_STEERING * deltaTime;
                    vs.yawVelocity = THREE.MathUtils.lerp(vs.yawVelocity, targetYawRateFromKeyboard, keyboardYawLerpFactor);
                    if (yawInputFromKeyboard === 0 && Math.abs(vs.yawVelocity) < PODRACER_YAW_VELOCITY_ZERO_THRESHOLD_KEYBOARD) { vs.yawVelocity = 0; }
                    
                    let targetYawRateFromMouseSteering = -mouseScreenOffsetX * PODRACER_MOUSE_YAW_SENSITIVITY_STEERING;
                    finalTargetYawVelocity = vs.yawVelocity + targetYawRateFromMouseSteering;
                    finalTargetYawVelocity = THREE.MathUtils.clamp(finalTargetYawVelocity, -PODRACER_MAX_YAW_VELOCITY, PODRACER_MAX_YAW_VELOCITY);
                    vs.keyYawRate = 0;
                    targetPodracerYawRateFromMouse = 0;
                }
                
                // Calculate and apply Yaw torque.
                const yawRateError = finalTargetYawVelocity - currentActualYawRate;
                const yawTorqueMagnitude = yawRateError * currentYawKpToUse;
                const yawTorqueImpulse = podracerUp.clone().multiplyScalar(yawTorqueMagnitude * deltaTime);
                if (!isNaN(yawTorqueImpulse.x) && !isNaN(yawTorqueImpulse.y) && !isNaN(yawTorqueImpulse.z)) { localPodracerBody.applyTorqueImpulse(yawTorqueImpulse, true); }

                // --- Pitch (Nose Up/Down) Logic (Flight Mode Only) ---
                if (vs.isInFlightMode) {
                    let finalTargetPitchVelocity;
                    let currentPitchKpToUse;
                    const isPitchMouseNonSteering = (currentPodracerMouseFlightMode === PODRACER_MOUSE_FLIGHT_MODE.NON_STEERING);

                    if (isPitchMouseNonSteering) {
                        // Non-Steering (Rate) Mode for Pitch.
                        currentPitchKpToUse = PODRACER_PITCH_KP_NON_STEERING;
                        let desiredKeyPitchRateForNonSteering = 0;
                        if (localPlayer.state.moveForward) { desiredKeyPitchRateForNonSteering = -PODRACER_KEY_MAX_PITCH_VELOCITY_FOR_NON_STEERING_MOUSE; }
                        else if (localPlayer.state.moveBackward) { desiredKeyPitchRateForNonSteering = PODRACER_KEY_MAX_PITCH_VELOCITY_FOR_NON_STEERING_MOUSE; }
                        
                        let pitchKeyLerpFactor = (desiredKeyPitchRateForNonSteering === 0) ? PODRACER_KEY_PITCH_DECELERATION_FOR_NON_STEERING_MOUSE * deltaTime : PODRACER_KEY_PITCH_ACCELERATION_FOR_NON_STEERING_MOUSE * deltaTime;
                        vs.keyPitchRate = THREE.MathUtils.lerp(vs.keyPitchRate, desiredKeyPitchRateForNonSteering, pitchKeyLerpFactor);
                        if (desiredKeyPitchRateForNonSteering === 0 && Math.abs(vs.keyPitchRate) < PODRACER_PITCH_VELOCITY_ZERO_THRESHOLD) { vs.keyPitchRate = 0; }
                        
                        if (targetPodracerPitchRateFromMouse === 0 && desiredKeyPitchRateForNonSteering === 0) { vs.pitchVelocity *= (1.0 - PODRACER_PITCH_DAMPING_FACTOR_NON_STEERING); }
                        
                        if (desiredKeyPitchRateForNonSteering !== 0) {
                            finalTargetPitchVelocity = vs.keyPitchRate;
                            currentPitchKpToUse = PODRACER_KEY_PITCH_KP_FOR_NON_STEERING_MOUSE;
                            vs.pitchVelocity = vs.keyPitchRate;
                        } else {
                            finalTargetPitchVelocity = vs.pitchVelocity;
                        }
                        
                        if (desiredKeyPitchRateForNonSteering === 0 && targetPodracerPitchRateFromMouse === 0 && Math.abs(finalTargetPitchVelocity) < PODRACER_PITCH_VELOCITY_ZERO_THRESHOLD) { finalTargetPitchVelocity = 0; vs.pitchVelocity = 0; vs.keyPitchRate = 0; }
                        virtualJoystickPitchPosition = 0.0;
                    
                    } else {
                        // Steering Mode for Pitch.
                        currentPitchKpToUse = PODRACER_PITCH_KP_SHARED;
                        let pitchInputFromKeyboard = 0;
                        if (localPlayer.state.moveForward) { pitchInputFromKeyboard = -1; }
                        else if (localPlayer.state.moveBackward) { pitchInputFromKeyboard = 1; }
                        
                        let targetPitchRateFromKeyboard = pitchInputFromKeyboard * PODRACER_MAX_PITCH_VELOCITY;
                        let keyboardPitchLerpFactor = (pitchInputFromKeyboard === 0) ? PODRACER_KEY_PITCH_DECELERATION_WHEN_MOUSE_STEERING * deltaTime : PODRACER_KEY_PITCH_ACCELERATION_WHEN_MOUSE_STEERING * deltaTime;
                        vs.pitchVelocity = THREE.MathUtils.lerp(vs.pitchVelocity, targetPitchRateFromKeyboard, keyboardPitchLerpFactor);
                        if (pitchInputFromKeyboard === 0 && Math.abs(vs.pitchVelocity) < PODRACER_PITCH_VELOCITY_ZERO_THRESHOLD) { vs.pitchVelocity = 0; }
                        
                        let targetPitchRateFromMouseSteering = virtualJoystickPitchPosition * PODRACER_MOUSE_PITCH_SENSITIVITY_STEERING;
                        finalTargetPitchVelocity = vs.pitchVelocity + targetPitchRateFromMouseSteering;
                        finalTargetPitchVelocity = THREE.MathUtils.clamp(finalTargetPitchVelocity, -PODRACER_MAX_PITCH_VELOCITY, PODRACER_MAX_PITCH_VELOCITY);
                        vs.keyPitchRate = 0; 
                        targetPodracerPitchRateFromMouse = 0;
                    }

                    // Calculate and apply Pitch torque.
                    const pitchRateError = finalTargetPitchVelocity - currentActualPitchRate;
                    const pitchTorqueMagnitude = pitchRateError * currentPitchKpToUse;
                    const pitchTorqueImpulse = podracerRight.clone().multiplyScalar(pitchTorqueMagnitude * deltaTime);
                    if (!isNaN(pitchTorqueImpulse.x) && !isNaN(pitchTorqueImpulse.y) && !isNaN(pitchTorqueImpulse.z)) { localPodracerBody.applyTorqueImpulse(pitchTorqueImpulse, true); }

                    // --- Roll (Banking) Logic (Flight Mode Only) ---
                    let rollInputTeclado = 0;
                    if (vs.isRollingLeft) rollInputTeclado = -1;
                    if (vs.isRollingRight) rollInputTeclado = 1;
                    
                    let desiredRollRate = rollInputTeclado * PODRACER_MAX_ROLL_VELOCITY;
                    let rollLerpFactor = (rollInputTeclado === 0) ? PODRACER_ROLL_DECELERATION * deltaTime : PODRACER_ROLL_ACCELERATION * deltaTime;
                    vs.rollVelocity = THREE.MathUtils.lerp(vs.rollVelocity, desiredRollRate, rollLerpFactor);
                    if (Math.abs(vs.rollVelocity) < PODRACER_ANGULAR_VELOCITY_ZERO_THRESHOLD && rollInputTeclado === 0) { vs.rollVelocity = 0; }
                    
                    // Calculate and apply Roll torque.
                    const rollRateError = vs.rollVelocity - currentActualRollRate;
                    const rollTorqueMagnitude = rollRateError * PODRACER_ROLL_KP;
                    const rollTorqueImpulse = podracerForward.clone().multiplyScalar(rollTorqueMagnitude * deltaTime);
                    if (!isNaN(rollTorqueImpulse.x) && !isNaN(rollTorqueImpulse.y) && !isNaN(rollTorqueImpulse.z)) { localPodracerBody.applyTorqueImpulse(rollTorqueImpulse, true); }
                
                } else {
                    // Reset pitch and roll rates when on the ground.
                    vs.keyPitchRate = 0.0; 
                    vs.pitchVelocity = 0.0; 
                    vs.rollVelocity = 0.0;
                }
                
                // --- Visual Roll Effect (Ground Mode Only) ---
                if (!vs.isInFlightMode) {
                    let normalizedYawRate = 0;
                    if (Math.abs(PODRACER_YAW_RATE_FOR_MAX_VISUAL_ROLL) > 0.001) { normalizedYawRate = finalTargetYawVelocity / PODRACER_YAW_RATE_FOR_MAX_VISUAL_ROLL; }
                    normalizedYawRate = THREE.MathUtils.clamp(normalizedYawRate, -1.0, 1.0);
                    
                    const targetVisualRollAngle = normalizedYawRate * PODRACER_SOLO_VISUAL_ROLL_MAX_ANGLE_RAD;
                    vs.currentVisualRoll = THREE.MathUtils.lerp(vs.currentVisualRoll, targetVisualRollAngle, PODRACER_SOLO_VISUAL_ROLL_LERP_RATE * deltaTime);
                } else { 
                    // Smoothly return to zero roll when in flight.
                    vs.currentVisualRoll = THREE.MathUtils.lerp(vs.currentVisualRoll, 0.0, PODRACER_SOLO_VISUAL_ROLL_LERP_RATE * deltaTime);
                    if (Math.abs(vs.currentVisualRoll) < 0.001) { vs.currentVisualRoll = 0.0; }
                }
            }

            // ========================================================================
            // --- 3. ANTI-DRIFT & VELOCITY ALIGNMENT ---
            // ========================================================================
            // This system actively counteracts sideways sliding (drift) on the ground
            // and aligns the vehicle's velocity with its forward direction in flight.
            // ========================================================================
            if (ENABLE_ACTIVE_DRIFT_CONTROL && !localPodracerBody.isSleeping()) {
                const currentSpeed = worldVelVec3.length();
                if (currentSpeed > MIN_SPEED_FOR_DRIFT_CONTROL) {
                    
                    // Flight Mode: Align velocity vector with forward direction.
                    if (vs.isInFlightMode) {
                        let desiredMoveDirection = FORWARD_VECTOR.clone().applyQuaternion(threeQuat).normalize();
                        if (Math.abs(vs.thrustNormalized) > PODRACER_THRUST_APPLICATION_THRESHOLD && vs.thrustNormalized < 0) { desiredMoveDirection.negate(); }
                        
                        const speedAlongDesiredPath = worldVelVec3.dot(desiredMoveDirection);
                        const velocityComponentDesired = desiredMoveDirection.clone().multiplyScalar(speedAlongDesiredPath);
                        const undesiredVelocityComponent = worldVelVec3.clone().sub(velocityComponentDesired);
                        
                        if (undesiredVelocityComponent.lengthSq() > 0.001) {
                            const correctionImpulseMagnitude = undesiredVelocityComponent.length() * podracerMass * FLIGHT_VELOCITY_ALIGNMENT_FACTOR;
                            const correctionImpulse = undesiredVelocityComponent.clone().normalize().multiplyScalar(-correctionImpulseMagnitude);
                            localPodracerBody.applyImpulse(correctionImpulse, true);
                        }
                    
                    // Ground Mode: Counteract sideways velocity.
                    } else {
                        const worldRightDirAntiDrift = new THREE.Vector3(1, 0, 0).applyQuaternion(threeQuat);
                        const lateralSpeed = worldVelVec3.dot(worldRightDirAntiDrift);
                        const targetLateralImpulseMagnitude = Math.abs(lateralSpeed) * podracerMass * DRIFT_CORRECTION_IMPULSE_FACTOR_SOLO;
                        const correctionImpulseDirection = worldRightDirAntiDrift.clone().multiplyScalar(-Math.sign(lateralSpeed));
                        let correctionImpulse = correctionImpulseDirection.multiplyScalar(targetLateralImpulseMagnitude);
                        if (correctionImpulse.lengthSq() > 0.0001) {
                            localPodracerBody.applyImpulse(correctionImpulse, true);
                        }
                    }
                }
            }

            // ========================================================================
            // --- 4. AERODYNAMIC BRAKING (DAMPING) ---
            // ========================================================================
            {
                let currentLinearDamping = localPodracerBody.linearDamping();
                let currentAngularDamping = localPodracerBody.angularDamping();
                let targetLinearDamping;
                let targetAngularDamping;
                
                if (vs.isAeroBraking) {
                    // When braking, smoothly increase damping to the maximum value.
                    targetLinearDamping = PODRACER_AERO_BRAKE_MAX_LINEAR_DAMPING;
                    targetAngularDamping = PODRACER_AERO_BRAKE_MAX_ANGULAR_DAMPING;
                    currentLinearDamping = Math.min(targetLinearDamping, currentLinearDamping + PODRACER_AERO_BRAKE_RATE * deltaTime);
                    currentAngularDamping = Math.min(targetAngularDamping, currentAngularDamping + PODRACER_AERO_BRAKE_RATE * deltaTime);
                } else {
                    // When not braking, smoothly decrease damping back to the default value.
                    targetLinearDamping = PODRACER_LINEAR_DAMPING;
                    targetAngularDamping = PODRACER_ANGULAR_DAMPING;
                    currentLinearDamping = Math.max(targetLinearDamping, currentLinearDamping - PODRACER_AERO_BRAKE_RATE * deltaTime);
                    currentAngularDamping = Math.max(targetAngularDamping, currentAngularDamping - PODRACER_AERO_BRAKE_RATE * deltaTime);
                }
                
                localPodracerBody.setLinearDamping(currentLinearDamping);
                localPodracerBody.setAngularDamping(currentAngularDamping);
            }

            // ========================================================================
            // --- 5. LATERAL STRAFE IMPULSE ---
            // ========================================================================
            let strafeLeftActive = false;
            let strafeRightActive = false;
            
            if (!vs.isInFlightMode) {
                strafeLeftActive = vs.isStrafingLeft;
                strafeRightActive = vs.isStrafingRight;
            } else {
                strafeLeftActive = vs.isStrafingLeftInFlight;
                strafeRightActive = vs.isStrafingRightInFlight;
            }
            
            if (strafeLeftActive || strafeRightActive) {
                const localRightDirection = new THREE.Vector3(1, 0, 0);
                const worldRightDirection = localRightDirection.applyQuaternion(threeQuat);
                let strafeImpulseDirection = new THREE.Vector3();
                if (strafeLeftActive) {
                    strafeImpulseDirection.copy(worldRightDirection).negate();
                } else if (strafeRightActive) {
                    strafeImpulseDirection.copy(worldRightDirection);
                }
                const strafeImpulseMagnitude = PODRACER_STRAFE_IMPULSE_FORCE * deltaTime;
                const strafeImpulse = strafeImpulseDirection.multiplyScalar(strafeImpulseMagnitude);
                localPodracerBody.applyImpulse(strafeImpulse, true);
            }

            // ========================================================================
            // --- 6. HOVER, FLIGHT MODE DETECTION & STABILIZATION SYSTEM ---
            // ========================================================================
            // This is the most complex part of the physics. It uses multiple raycasts
            // to understand the surrounding terrain and determine whether the craft should
            // be hovering or flying, and how it should orient itself.
            // ========================================================================
            let targetUpForStabilization = UP_VECTOR.clone();
            let applyHoverForceCalculated = false;
            let calculatedMinHitDistance = PODRACER_HOVER_RAY_MAX_LENGTH;
            let forwardHitNormal = null, didForwardRayHit = false;
            let leftHitNormal = null, didLeftRayHit = false;
            let rightHitNormal = null, didRightRayHit = false;
            let velocityHitNormal = null, didVelocityRayHit = false;
            let downwardHitCount = 0;
            let sumDownwardNormal = new THREE.Vector3(0, 0, 0);

            // --- Jump Action (Forces Flight Mode) ---
            if (vs.isJumping) {
                const podracerUpLocal = UP_VECTOR.clone();
                const podracerUpWorld = podracerUpLocal.applyQuaternion(threeQuat);
                const jumpImpulseMagnitude = PODRACER_JUMP_IMPULSE_FORCE * deltaTime;
                const jumpImpulse = podracerUpWorld.multiplyScalar(jumpImpulseMagnitude);
                localPodracerBody.applyImpulse(jumpImpulse, true);
                
                vs.isInFlightMode = true; 
                if (!vs.previouslyInFlightMode) { 
                    console.log("✈️ Podracer jumped into flight mode. Resetting keyboard rotation inputs.");
                    localPlayer.state.moveForward = false;
                    localPlayer.state.moveBackward = false;
                    vs.keyPitchRate = 0.0; vs.rollVelocity = 0.0; vs.keyYawRate = 0.0; 
                }
                
                targetUpForStabilization.copy(podracerUpWorld);
                vs.relativeAltitude = null;
                applyHoverForceCalculated = false; 
            
            } else {
                // --- Ground Detection & Multi-Raycast System ---
                const localDown = UP_VECTOR.clone().negate();
                const worldDownDir = localDown.clone().applyQuaternion(threeQuat);
                const rayDirPhysics = { x: worldDownDir.x, y: worldDownDir.y, z: worldDownDir.z };
                
                // Cast 4 downward "suspension" rays.
                PODRACER_SUSPENSION_POINTS.forEach((localPoint) => {
                    const worldPoint = localPoint.clone().applyQuaternion(threeQuat).add(podracerPositionVec3);
                    const rayOriginPhysics = { x: worldPoint.x, y: worldPoint.y, z: worldPoint.z };
                    const ray = new RAPIER.Ray(rayOriginPhysics, rayDirPhysics);
                    const hit = physicsWorld.castRayAndGetNormal(ray, PODRACER_HOVER_RAY_MAX_LENGTH, true, undefined, hoverRayGroupBitmask, localPodracerCollider);
                    
                    if (hit && hit.collider) {
                        // If a ray hits the ground, gather data.
                        const hitCollider = hit.collider;
                        if (racePortalObject && hitCollider.handle === racePortalObject.userData.colliderHandle) { console.error(`[!!! DEBUG HIT !!!] Suspension ray hit the race portal!`); }
                        
                        downwardHitCount++;
                        const distance = hit.timeOfImpact;
                        calculatedMinHitDistance = Math.min(calculatedMinHitDistance, distance);
                        const normal = new THREE.Vector3(hit.normal.x, hit.normal.y, hit.normal.z);
                        sumDownwardNormal.add(normal);
                        if (isDebugVisible) {
                            const rayStartDebug = worldPoint.clone();
                            const hitPointDebug = rayStartDebug.clone().add(worldDownDir.clone().multiplyScalar(distance));
                            drawDebugLine(rayStartDebug, hitPointDebug, DEBUG_PODRACER_RAY_HIT_COLOR);
                            drawDebugNormal(hitPointDebug, normal, DEBUG_PODRACER_NORMAL_LINE_LENGTH);
                        }
                    } else {
                        // Visualize rays that miss the ground.
                        if (isDebugVisible) {
                            const rayStartDebug = worldPoint.clone();
                            const rayEndDebug = rayStartDebug.clone().add(worldDownDir.clone().multiplyScalar(PODRACER_HOVER_RAY_MAX_LENGTH));
                            drawDebugLine(rayStartDebug, rayEndDebug, DEBUG_PODRACER_RAY_MISS_COLOR);
                        }
                    }
                });

                // --- Flight/Hover Mode Transition Logic ---
                const wasInFlightModePreviously = vs.isInFlightMode;
                if (downwardHitCount > 0) { 
                    // Ground detected: Enter Hover/Ground mode.
                    vs.isInFlightMode = false; 
                    vs.relativeAltitude = calculatedMinHitDistance;
                    applyHoverForceCalculated = true; 
                    if (vs.isApplyingDownForce) { vs.isApplyingDownForce = false; console.log("   -> Down Impulse deactivated upon ground detection."); }
                    
                    // Reset flight controls if just landed.
                    if (wasInFlightModePreviously) {
                        console.log("🛬 Podracer has landed/transitioned to ground mode.");
                        vs.yawVelocity = 0.0; virtualSteeringWheelPosition = 0.0; mouseScreenOffsetX = 0.0;
                        vs.isStrafingLeft = false; vs.isStrafingRight = false;
                        vs.keyPitchRate = 0.0; vs.keyYawRate = 0.0; vs.rollVelocity = 0.0;
                        if (vs.isFlightGravityActive) { vs.isFlightGravityActive = false; console.log("🛬 Landing: Flight Gravity automatically turned OFF."); }
                    }
                } else { 
                    // No ground detected: Enter Flight mode.
                    vs.isInFlightMode = true; 
                    vs.relativeAltitude = null;
                    applyHoverForceCalculated = false; 
                    
                    // Reset ground controls if just took off.
                    if (!wasInFlightModePreviously) {
                        console.log("✈️ Podracer has taken off/transitioned to flight mode (no jump).");
                        localPlayer.state.moveForward = false; localPlayer.state.moveBackward = false;
                        vs.keyPitchRate = 0.0; vs.keyYawRate = 0.0; vs.rollVelocity = 0.0; 
                        keyboard['KeyA'] = false; keyboard['KeyD'] = false;
                        if (vs.isStrafingLeft || vs.isStrafingRight) { vs.isStrafingLeft = false; vs.isStrafingRight = false; }
                    }
                }

                // --- Supplemental Raycasts for Stabilization ---
                const worldForwardDirForRays = FORWARD_VECTOR.clone().applyQuaternion(threeQuat);
                const forwardSpeedMs = worldVelVec3.dot(worldForwardDirForRays);
                
                // Forward Ray (obstacle avoidance).
                if (PODRACER_FORWARD_RAY_ENABLED) {
                    const dynamicForwardRayLength = calculateDynamicRayLength(Math.max(0, forwardSpeedMs), PODRACER_FORWARD_RAY_TARGET_MAX_SPEED_KMH, PODRACER_FORWARD_RAY_MIN_LENGTH, PODRACER_FORWARD_RAY_ABSOLUTE_MAX_LENGTH, PODRACER_FORWARD_RAY_LENGTH_EXPONENT);
                    const worldForwardRayOrigin = PODRACER_FORWARD_RAY_ORIGIN_OFFSET.clone().applyQuaternion(threeQuat).add(podracerPositionVec3);
                    const forwardRayPhysicsDir = { x: worldForwardDirForRays.x, y: worldForwardDirForRays.y, z: worldForwardDirForRays.z };
                    const forwardRay = new RAPIER.Ray({x: worldForwardRayOrigin.x, y: worldForwardRayOrigin.y, z: worldForwardRayOrigin.z}, forwardRayPhysicsDir);
                    const forwardHit = physicsWorld.castRayAndGetNormal(forwardRay, dynamicForwardRayLength, true, undefined, hoverRayGroupBitmask, localPodracerCollider);
                    
                    if (forwardHit && forwardHit.collider) { forwardHitNormal = new THREE.Vector3(forwardHit.normal.x, forwardHit.normal.y, forwardHit.normal.z); didForwardRayHit = true; } 
                    else { forwardHitNormal = null; didForwardRayHit = false; }
                    
                    if (isDebugVisible) {
                        const rayStartDebug = worldForwardRayOrigin.clone();
                        const rayEndDebug = rayStartDebug.clone().add(worldForwardDirForRays.clone().multiplyScalar(dynamicForwardRayLength));
                        const color = didForwardRayHit ? DEBUG_PODRACER_FWD_RAY_HIT_COLOR : DEBUG_PODRACER_FWD_RAY_MISS_COLOR;
                        drawDebugLine(rayStartDebug, rayEndDebug, color, DEBUG_PODRACER_RAY_LINEWIDTH);
                        if (didForwardRayHit) {
                            const hitPointDebug = rayStartDebug.clone().add(worldForwardDirForRays.clone().multiplyScalar(forwardHit.timeOfImpact));
                            drawDebugNormal(hitPointDebug, forwardHitNormal, DEBUG_PODRACER_NORMAL_LINE_LENGTH, DEBUG_PODRACER_FWD_NORMAL_COLOR);
                        }
                    }
                }
                
                // Side Rays (wall avoidance, currently disabled).
                if (PODRACER_SIDE_RAYS_ENABLED) { /* ... side ray logic ... */ }
                
                // Velocity Ray (aligns with direction of travel).
                if (PODRACER_VELOCITY_RAY_ENABLED) {
                    const speed = worldVelVec3.length();
                    if (speed > PODRACER_VELOCITY_RAY_MIN_SPEED_THRESHOLD) {
                        let rayLengthToUse = vs.isVelocityRayFrozen ? vs.frozenVelocityRayLength : calculateDynamicRayLength(speed, PODRACER_VELOCITY_RAY_TARGET_MAX_SPEED_KMH, PODRACER_VELOCITY_RAY_MIN_LENGTH, PODRACER_VELOCITY_RAY_ABSOLUTE_MAX_LENGTH, PODRACER_VELOCITY_RAY_LENGTH_EXPONENT);
                        const velocityDirection = worldVelVec3.clone().normalize();
                        const worldVelocityRayOrigin = PODRACER_VELOCITY_RAY_ORIGIN_OFFSET.clone().applyQuaternion(threeQuat).add(podracerPositionVec3);
                        const velocityRay = new RAPIER.Ray({x: worldVelocityRayOrigin.x, y: worldVelocityRayOrigin.y, z: worldVelocityRayOrigin.z}, {x: velocityDirection.x, y: velocityDirection.y, z: velocityDirection.z});
                        const velocityHit = physicsWorld.castRayAndGetNormal(velocityRay, rayLengthToUse, true, undefined, hoverRayGroupBitmask, localPodracerCollider);
                        
                        if (velocityHit && velocityHit.collider) {
                            velocityHitNormal = new THREE.Vector3(velocityHit.normal.x, velocityHit.normal.y, velocityHit.normal.z);
                            didVelocityRayHit = true;
                            if (!vs.isVelocityRayFrozen) { vs.isVelocityRayFrozen = true; vs.frozenVelocityRayLength = rayLengthToUse; }
                        } else {
                            velocityHitNormal = null; didVelocityRayHit = false;
                            if (vs.isVelocityRayFrozen) { vs.isVelocityRayFrozen = false; }
                        }
                        
                        if (isDebugVisible) {
                            const rayStartDebug = worldVelocityRayOrigin.clone();
                            const rayEndDebug = rayStartDebug.clone().add(velocityDirection.clone().multiplyScalar(rayLengthToUse));
                            const color = didVelocityRayHit ? DEBUG_PODRACER_VEL_RAY_HIT_COLOR : DEBUG_PODRACER_VEL_RAY_MISS_COLOR;
                            drawDebugLine(rayStartDebug, rayEndDebug, color, DEBUG_PODRACER_RAY_LINEWIDTH);
                            if (didVelocityRayHit) {
                                const hitPointDebug = rayStartDebug.clone().add(velocityDirection.clone().multiplyScalar(velocityHit.timeOfImpact));
                                drawDebugNormal(hitPointDebug, velocityHitNormal, DEBUG_PODRACER_NORMAL_LINE_LENGTH, DEBUG_PODRACER_VEL_NORMAL_COLOR);
                            }
                        }

                    } else {
                        if (vs.isVelocityRayFrozen) { vs.isVelocityRayFrozen = false; }
                        didVelocityRayHit = false; velocityHitNormal = null;
                    }
                }
                
                // --- Combine Raycast Normals for Final Target Orientation ---
                const weightedSumNormal = new THREE.Vector3(0, 0, 0);
                let totalWeight = 0.0;
                
                if (downwardHitCount > 0) { const averageDownwardNormal = sumDownwardNormal.divideScalar(downwardHitCount).normalize(); weightedSumNormal.add(averageDownwardNormal.multiplyScalar(PODRACER_DOWNWARD_RAYS_TOTAL_WEIGHT)); totalWeight += PODRACER_DOWNWARD_RAYS_TOTAL_WEIGHT; }
                if (PODRACER_FORWARD_RAY_ENABLED && didForwardRayHit && forwardHitNormal) { weightedSumNormal.add(forwardHitNormal.clone().multiplyScalar(PODRACER_FORWARD_RAY_NORMAL_WEIGHT)); totalWeight += PODRACER_FORWARD_RAY_NORMAL_WEIGHT; }
                if (PODRACER_SIDE_RAYS_ENABLED) { /* ... side ray weight logic ... */ }
                if (PODRACER_VELOCITY_RAY_ENABLED && didVelocityRayHit && velocityHitNormal) { weightedSumNormal.add(velocityHitNormal.clone().multiplyScalar(PODRACER_VELOCITY_RAY_NORMAL_WEIGHT)); totalWeight += PODRACER_VELOCITY_RAY_NORMAL_WEIGHT; }
                
                if (totalWeight > PODRACER_TARGET_UP_WEIGHT_THRESHOLD) {
                    targetUpForStabilization.copy(weightedSumNormal.normalize());
                } else if (vs.isInFlightMode) { 
                    targetUpForStabilization.copy(UP_VECTOR);
                } else { 
                     targetUpForStabilization.copy(UP_VECTOR.clone().applyQuaternion(threeQuat));
                }
                
                // --- Apply Flight Gravity or Hover Force ---
                if (vs.isInFlightMode) {
                    localPodracerBody.setGravityScale(vs.isFlightGravityActive ? PODRACER_FLIGHT_GRAVITY_SCALE_ON : PODRACER_FLIGHT_GRAVITY_SCALE_OFF, true);
                    if (vs.isApplyingDownForce) {
                        const podracerDownLocal = UP_VECTOR.clone().negate();
                        const podracerDownWorld = podracerDownLocal.applyQuaternion(threeQuat);
                        const downImpulseMagnitude = PODRACER_DOWN_IMPULSE_FORCE * deltaTime;
                        const downImpulse = podracerDownWorld.multiplyScalar(downImpulseMagnitude);
                        localPodracerBody.applyImpulse(downImpulse, true);
                    }
                } else {
                    localPodracerBody.setGravityScale(0.0, true); 
                    if (applyHoverForceCalculated) {
                        // Dynamic Hover Height Logic
                        let desiredDynamicHoverHeight = PODRACER_MIN_DYNAMIC_HOVER_HEIGHT;
                        const isObstacleDetectedByForwardRay = PODRACER_FORWARD_RAY_ENABLED && didForwardRayHit;
                        const isObstacleDetectedByVelocityRay = PODRACER_VELOCITY_RAY_ENABLED && didVelocityRayHit;
                        if (isObstacleDetectedByForwardRay || isObstacleDetectedByVelocityRay) {
                            const currentPodracerSpeedMs = worldVelVec3.length();
                            const speedForMaxHeightMs = PODRACER_SPEED_FOR_MAX_HOVER_HEIGHT_KMH / UNITS_PER_SECOND_TO_KM_PER_HOUR;
                            if (speedForMaxHeightMs > 0.01) {
                                const speedRatio = Math.min(1.0, Math.max(0.0, currentPodracerSpeedMs / speedForMaxHeightMs));
                                desiredDynamicHoverHeight = PODRACER_MIN_DYNAMIC_HOVER_HEIGHT + ((PODRACER_MAX_DYNAMIC_HOVER_HEIGHT - PODRACER_MIN_DYNAMIC_HOVER_HEIGHT) * speedRatio);
                            } else {
                                desiredDynamicHoverHeight = PODRACER_MAX_DYNAMIC_HOVER_HEIGHT;
                            }
                        }
                        currentDynamicTargetHoverHeight = THREE.MathUtils.lerp(currentDynamicTargetHoverHeight, desiredDynamicHoverHeight, PODRACER_DYNAMIC_HOVER_HEIGHT_LERP_RATE);
                        
                        // PID-based Hover Force Calculation
                        const heightError = calculatedMinHitDistance - currentDynamicTargetHoverHeight;
                        const velocityAlongNormal = worldVelVec3.dot(targetUpForStabilization); 
                        const KpForce = PODRACER_HOVER_FORCE_KP * -heightError; // Proportional force
                        const KdForce = PODRACER_HOVER_FORCE_KD * -velocityAlongNormal; // Damping force
                        const hoverForceMagnitude = KpForce + KdForce;
                        const hoverImpulse = targetUpForStabilization.clone().multiplyScalar(hoverForceMagnitude * deltaTime);
                        localPodracerBody.applyImpulse(hoverImpulse, true);
                    }
                }
                
                // Visualize the final calculated "up" direction for stabilization.
                if (isDebugVisible) {
                    const center = podracerPositionVec3.clone();
                    const targetEnd = center.clone().add(targetUpForStabilization.clone().multiplyScalar(DEBUG_PODRACER_TARGETUP_LINE_LENGTH));
                    let targetUpColor = vs.isInFlightMode ? (vs.isFlightGravityActive ? DEBUG_PODRACER_TARGETUP_GRAV_COLOR : 0x00FFFF) : DEBUG_PODRACER_TARGETUP_NOGRAV_COLOR;
                    drawDebugLine(center, targetEnd, targetUpColor, DEBUG_PODRACER_TARGETUP_LINEWIDTH);
                }
            }
            
            // --- Final Stabilization Torque (Ground Mode Only) ---
            if (!vs.isInFlightMode && !vs.isJumping) {
                const podracerUpActual = UP_VECTOR.clone().applyQuaternion(threeQuat);
                const rotationAxis = new THREE.Vector3().crossVectors(podracerUpActual, targetUpForStabilization);
                const angleError = podracerUpActual.angleTo(targetUpForStabilization);
                
                if (angleError > PODRACER_STABILIZE_ANGLE_THRESHOLD && rotationAxis.lengthSq() > PODRACER_STABILIZE_AXIS_THRESHOLD_SQ) {
                    rotationAxis.normalize();
                    const angularVelocityWorld = new THREE.Vector3(angvel.x, angvel.y, angvel.z);
                    const angularVelocityAlongAxis = angularVelocityWorld.dot(rotationAxis);
                    const KpTorque = PODRACER_STABILIZE_TORQUE_KP * angleError;
                    const KdTorque = PODRACER_STABILIZE_TORQUE_KD * -angularVelocityAlongAxis;
                    const stabilizeTorqueMagnitude = KpTorque + KdTorque;
                    const stabilizeTorqueImpulse = rotationAxis.clone().multiplyScalar(stabilizeTorqueMagnitude * deltaTime);
                    if (!isNaN(stabilizeTorqueImpulse.x) && !isNaN(stabilizeTorqueImpulse.y) && !isNaN(stabilizeTorqueImpulse.z)) { localPodracerBody.applyTorqueImpulse(stabilizeTorqueImpulse, true); }
                }
            }
            
            // --- Final State Updates ---
            // Update UI if the flight mode changed this frame.
            if (vs.isInFlightMode !== vs.previouslyInFlightMode) {
                updateCursorAndIndicators();
                if (isPaused) {
                    updatePauseMenuOptionsVisibility();
                }
            }
            vs.previouslyInFlightMode = vs.isInFlightMode;
            
        } // End of handlePodracerMovement

        
        // ========================================================================
        // --- 🤸‍♂️⚙️ ANIMATION STATE MACHINE ---
        // ========================================================================
        /**
         * Determines which animation should be playing based on the local player's current state
         * (e.g., moving, jumping, idle) and triggers the transition to that animation.
         * This acts as a priority-based state machine.
         */
        function updateCharacterAnimation() {
            const localPlayer = players.get(localPlayerId);
            // Guard clause: Exit if the local player or essential components don't exist.
            if (!localPlayer || !localPlayer.body || !localPlayer.mixer) return;

            // --- 1. GATHER STATE DATA ---
            // Collect all necessary boolean flags and physics data from the player's state object.
            // This decouples the animation logic from the input handling.
            const onGround = localPlayer.state.canJump;
            const isMovingForward = localPlayer.state.moveForward;
            const isMovingBackward = localPlayer.state.moveBackward;
            const isMovingLeft = localPlayer.state.moveLeft;
            const isMovingRight = localPlayer.state.moveRight;
            
            const velocity = localPlayer.body.linvel();
            // Check if the character has significant horizontal velocity.
            const isCharacterStopped = Math.abs(velocity.x) < 0.1 && Math.abs(velocity.z) < 0.1;

            // --- 2. PRIORITY-BASED STATE LOGIC ---
            // Determine the single 'desiredState' by checking conditions in order of priority.
            // For example, being in the air overrides all ground-based movement animations.
            let desiredState = 'idle'; // Default state if no other conditions are met.

            // HIGHEST PRIORITY: Air state (jumping or falling).
            if (!onGround) {
                // If the jump animation is already playing, let it finish.
                if (localPlayer.state.animationState === 'jump') {
                    desiredState = 'jump';
                } else {
                    // Otherwise, play the falling animation.
                    desiredState = 'fall';
                }
            } 
            // NEXT PRIORITY: Grounded movement.
            else {
                if (isMovingForward) {
                    // Diagonal movement has priority over simple forward movement.
                    if (isMovingLeft) {
                        desiredState = localPlayer.state.isSprinting ? 'run_forward_left' : 'walk_forward_left';
                    } else if (isMovingRight) {
                        desiredState = localPlayer.state.isSprinting ? 'run_forward_right' : 'walk_forward_right';
                    } else {
                        desiredState = localPlayer.state.isSprinting ? 'run' : 'walk';
                    }
                }
                else if (isMovingBackward) {
                    desiredState = localPlayer.state.isSprinting ? 'run_backward' : 'walk_backward';
                }
                // Special case for Platformer mode: turning in place.
                else if (localPlayer.state.isPlatformerCameraActive && isCharacterStopped) {
                    if (keyboard['KeyA']) {
                        desiredState = 'turn_left';
                    } else if (keyboard['KeyD']) {
                        desiredState = 'turn_right';
                    }
                }
                // Sideways movement (strafing).
                else if (isMovingLeft) {
                    desiredState = localPlayer.state.isSprinting ? 'strafe_run_left' : 'strafe_left';
                }
                else if (isMovingRight) {
                    desiredState = localPlayer.state.isSprinting ? 'strafe_run_right' : 'strafe_right';
                }
            }
            
            // --- 3. EXECUTE ANIMATION TRANSITION ---
            // Only trigger a change if the new desired state is different from the current one.
            // This prevents the animation from being reset on every frame.
            if (localPlayer.state.animationState !== desiredState) {
                // Update the player's state to reflect the new animation.
                localPlayer.state.animationState = desiredState;
                // Call the helper function to handle the smooth cross-fade transition.
                playAnimation(desiredState, localPlayer);
            }
        }

        // ============================================================================
        // --- 🎭 REMOTE PLAYER UPDATE WITH TEMPORAL INTERPOLATION ---
        // ============================================================================
        /**
         * Smoothly updates a remote player's position and rotation using temporal interpolation.
         * This technique reads from a buffer of past states to calculate a smooth position
         * at a slightly delayed point in time, masking network jitter and packet loss.
         * @param {object} player - The remote player object to update.
         */
        function updateRemotePlayer(player) {
            const buffer = player.network.stateBuffer;

            // 1. Guard Clause: We need at least two states in the buffer to interpolate between them.
            if (buffer.length < 2) {
                return;
            }

            // 2. Calculate Target Render Time: This is the point in time we want to display the player at.
            // It's the current time minus a small, constant delay (INTERPOLATION_BUFFER_MS).
            // This delay gives network packets a window of time to arrive.
            const renderTime = performance.now() - INTERPOLATION_BUFFER_MS;

            // 3. Find Bracketing States: Search the buffer for two states (stateA and stateB) where
            // stateA.timestamp <= renderTime <= stateB.timestamp.
            let stateA = null;
            let stateB = null;
            let stateA_index = -1; // We'll use this index to clean up the buffer later.

            // We search backwards for efficiency, as the target states are likely near the end of the buffer.
            for (let i = buffer.length - 1; i >= 0; i--) {
                if (buffer[i].timestamp <= renderTime) {
                    stateA = buffer[i];
                    stateA_index = i;
                    if (i < buffer.length - 1) {
                        stateB = buffer[i + 1];
                    }
                    break; // Found our states, no need to search further.
                }
            }

            // 4. Guard Clause: If we couldn't find two bracketing states (e.g., if renderTime is too old
            // or newer than all received states), we can't interpolate, so we exit.
            if (!stateA || !stateB) {
                return;
            }
            
            // 5. Calculate Interpolation Factor (alpha): This is a value between 0 and 1 that represents
            // how far the renderTime is between stateA and stateB's timestamps.
            const timeRange = stateB.timestamp - stateA.timestamp;
            const timeProgress = renderTime - stateA.timestamp;
            const alpha = Math.max(0.0, Math.min(1.0, timeProgress / timeRange)); // Clamp to ensure it's valid.

            // 6. Interpolate Position and Rotation: Use linear interpolation (lerp) for position
            // and spherical linear interpolation (slerp) for rotation (quaternions) to find the
            // intermediate state.
            const interpolatedPosition = new THREE.Vector3().copy(stateA.position).lerp(stateB.position, alpha);
            const interpolatedRotation = new THREE.Quaternion().copy(stateA.rotation).slerp(stateB.rotation, alpha);

            // 7. Apply Interpolated State: Set the kinematic body's next target position and rotation.
            // Rapier will smoothly move the kinematic body to this target in the next physics step.
            const activeBody = player.state.isInVehicle ? player.vehicle.body : player.body;
            if (activeBody) {
                activeBody.setNextKinematicTranslation(interpolatedPosition);
                activeBody.setNextKinematicRotation(interpolatedRotation);

                // Also ensure the correct visual model is visible.
                const characterModel = player.model;
                const vehicleMesh = player.vehicle.mesh;
                if (characterModel) characterModel.visible = !player.state.isInVehicle;
                if (vehicleMesh) vehicleMesh.visible = player.state.isInVehicle;
            }

            // 8. Buffer Cleanup: Remove old states that we no longer need.
            // This is critical to prevent the buffer from growing indefinitely (memory leak).
            if (stateA_index > 0) {
                // Remove all states from the beginning of the buffer up to (but not including) stateA.
                buffer.splice(0, stateA_index);
            }
            
            // 9. Buffer Size Limit: As a final safety measure, ensure the buffer does not
            // exceed a maximum size.
            while (buffer.length > STATE_BUFFER_SIZE) {
                buffer.shift(); // Remove the oldest state.
            }
        }


        // ===================================================================
        // --- 8. MAIN LOOP AND ORCHESTRATION ---
        // ===================================================================
        // This section contains the main game loop (`animate`) which drives the
        // entire application, orchestrating physics updates, rendering, player logic,
        // and UI updates on every frame.

        // ===================================================================
        // --- 🔄 MAIN ANIMATION & PHYSICS LOOP ---
        // ===================================================================
        /**
         * The heart of the application. This function is called recursively on every frame
         * to update and render the game world.
         */
        function animate() {
            // Request the browser to call this function again on the next available frame.
            requestAnimationFrame(animate);

            // --- GAME MODE GATEKEEPER ---
            // This check ensures that the core game logic only runs when the player is
            // actively in a single-player or multiplayer game session.
            if (currentGlobalMode !== GameMode.GAME_SINGLE_PLAYER && currentGlobalMode !== GameMode.GAME_MULTIPLAYER) {
                // If not in a game, we could render animated menus here, but for now, we just stop.
                return; 
            }

            // --- PAUSE CHECK ---
            // If the game is not paused, proceed with the simulation update.
            if (!isPaused) {
                // Calculate the time delta since the last frame, capping it to prevent physics instability.
                const deltaTime = Math.min(clock.getDelta(), MAX_DELTA_TIME);

                // --- PLAYER UPDATE LOOP ---
                // This is the central point of the update logic. We iterate over ALL players
                // (both local and remote) and apply the appropriate update logic to each one.
                for (const player of players.values()) {
                    
                    // Skip any player that doesn't have a valid physics body.
                    if (!player.body) continue;

                    // --- Apply Logic Based on Player Type (Local vs. Remote) ---
                    if (player.isLocal) {
                        // ===============================================
                        //  LOGIC EXCLUSIVE TO THE LOCAL PLAYER
                        // ===============================================
                        // 1. Process Input: Translate raw keyboard/mouse state into player "intentions".
                        processLocalInput(player, deltaTime); 

                        // 2. Apply Physics: Run the physics simulation based on the player's intentions.
                        switch (player.state.controlMode) {
                            case ControlMode.FPS:
                                if (controls.isLocked) {
                                    handlePlayerFPSMovement(deltaTime, player);
                                }
                                break;
                            case ControlMode.PODRACER:
                                handlePodracerMovement(deltaTime, player.vehicle);
                                break;
                        }

                        // 3. Update Animation: Determine and play the correct character animation.
                        if (player.state.controlMode === ControlMode.FPS) {
                            updateCharacterAnimation();
                        }

                    } else {
                        // ===============================================
                        //  LOGIC FOR REMOTE PLAYERS
                        // ===============================================
                        // Apply temporal interpolation to smooth out the remote player's movement.
                        updateRemotePlayer(player);
                    }

                    // ===============================================
                    //  LOGIC COMMON TO ALL PLAYERS
                    // ===============================================
                    // The animation mixer must be updated for every player, every frame.
                    if (player.mixer) {
                        player.mixer.update(deltaTime);
                    }
                } // --- End of Player Update Loop ---

                // --- GLOBAL SYSTEMS UPDATE ---
                // These systems run once per frame, after all individual player updates.
                // They often rely on the state of the local player.

                // Update the race portal placement visual if the player is in that mode.
                if (isInPortalPlacementMode) {
                    updatePortalPlacement();
                }

                // Get the local player for systems that depend on its state.
                const localPlayer = players.get(localPlayerId);

                // Dynamic Field of View (FOV) effect for the Podracer.
                if (localPlayer && localPlayer.state.controlMode === ControlMode.PODRACER && localPlayer.vehicle.body && !localPlayer.vehicle.body.isSleeping()) {
                    const linvel = localPlayer.vehicle.body.linvel();
                    const worldVelVec3 = new THREE.Vector3(linvel.x, linvel.y, linvel.z);
                    const currentSpeedKmh = worldVelVec3.length() * UNITS_PER_SECOND_TO_KM_PER_HOUR;
                    const fovSpeedRatio = Math.min(1.0, currentSpeedKmh / PODRACER_SPEED_FOR_MAX_FOV_EFFECT_KMH);
                    const targetFov = CAMERA_BASE_FOV + (PODRACER_MAX_SPEED_FOV_ADDITION * fovSpeedRatio);
                    camera.fov = THREE.MathUtils.lerp(camera.fov, targetFov, deltaTime * 5.0);
                    camera.updateProjectionMatrix();
                } else {
                    // Smoothly return the FOV to its default value if not in the Podracer.
                    if (camera.fov !== CAMERA_BASE_FOV) {
                        camera.fov = THREE.MathUtils.lerp(camera.fov, CAMERA_BASE_FOV, deltaTime * 5.0);
                        camera.updateProjectionMatrix();
                    }
                }
                
                // Update the SVG-based strafe visualizer for the Podracer.
                if (strafeVisualContainer_strafe && localPlayer) { 
                    const vs = localPlayer.state.vehicleState;
                    const shouldShowStrafeVisuals = 
                        vs && localPlayer.state.controlMode === ControlMode.PODRACER && 
                        !isPaused &&
                        (
                            (!vs.isInFlightMode && (vs.isStrafingLeft || vs.isStrafingRight)) ||
                            (vs.isInFlightMode && (vs.isStrafingLeftInFlight || vs.isStrafingRightInFlight))
                        );

                    if (shouldShowStrafeVisuals) {
                        if (strafeVisualContainer_strafe.style.display === 'none') {
                            // Reset visuals when they first appear.
                            params_strafe.currentLeftWidth = 0;
                            params_strafe.currentRightWidth = 0;
                            updateArrowSVG_strafe(leftStrafeArrowSVG_strafe, leftArrowWrapperEl_strafe, leftGradientId_strafe, leftShimmerGradientId_strafe, 0, true, params_strafe.baseColor, params_strafe.leftBarTipColor, params_strafe.leftGlowColor);
                            updateArrowSVG_strafe(rightStrafeArrowSVG_strafe, rightArrowWrapperEl_strafe, rightGradientId_strafe, rightShimmerGradientId_strafe, 0, false, params_strafe.baseColor, params_strafe.rightBarTipColor, params_strafe.rightGlowColor);
                        }
                        strafeVisualContainer_strafe.style.display = 'block';
                        updateStrafeVisuals_mainGameLoop(deltaTime);
                    } else {
                        // Hide visuals if not strafing.
                        if (strafeVisualContainer_strafe.style.display === 'block') {
                            params_strafe.currentLeftWidth = 0;
                            params_strafe.currentRightWidth = 0;
                            updateArrowSVG_strafe(leftStrafeArrowSVG_strafe, leftArrowWrapperEl_strafe, leftGradientId_strafe, leftShimmerGradientId_strafe, 0, true, params_strafe.baseColor, params_strafe.leftBarTipColor, params_strafe.leftGlowColor);
                            updateArrowSVG_strafe(rightStrafeArrowSVG_strafe, rightArrowWrapperEl_strafe, rightGradientId_strafe, rightShimmerGradientId_strafe, 0, false, params_strafe.baseColor, params_strafe.rightBarTipColor, params_strafe.rightGlowColor);
                        }
                        strafeVisualContainer_strafe.style.display = 'none';
                    }
                }
                
                // --- CORE UPDATE ORCHESTRATION ---
                stepPhysics(deltaTime);             // Advance the physics simulation.
                syncVisuals();                      // Match 3D models to their physics bodies.
                updateCamera();                     // Position the camera based on the local player.
                checkCameraObstruction();           // Check if the camera is inside a wall.

                // --- GOD RAYS: SUN POSITION UPDATE ---
                // This logic ensures the visual sun object always appears infinitely far away
                // by parenting it to the camera's position.
                if (godRaySun) {
                    const cameraPosition = camera.position;
                    // Start at the camera's position and add the sun's direction vector.
                    const sunNewPosition = cameraPosition.clone().add(
                        SUN_DIRECTION.clone().multiplyScalar(DIRECTIONAL_LIGHT_DISTANCE)
                    );
                    godRaySun.position.copy(sunNewPosition);
                }
                
                // Animate shader materials by updating their time uniform.
                const elapsedTime = clock.getElapsedTime();
                if (causticsMaterialSet1) { causticsMaterialSet1.uniforms.time.value = elapsedTime; }
                if (causticsMaterialSet2) { causticsMaterialSet2.uniforms.time.value = elapsedTime; }
                if (causticsMaterialSet3) { causticsMaterialSet3.uniforms.time.value = elapsedTime; }
                if (causticsMaterialSet4) { causticsMaterialSet4.uniforms.time.value = elapsedTime; }
                
                // Update on-screen UI elements.
                updateHUD();
                updateRaceTimer();
                updateNameTags(); 
            } // --- End of if(!isPaused) block ---

            // ======================================================================
            // --- 3-PASS MANUAL RENDERING LOGIC FOR GOD RAYS ---
            // ======================================================================
            if (!isPaused && godRaySun && terrainMesh) {

                // Hide all debug helpers before rendering the occlusion mask.
                if (playerCapsuleHelper) playerCapsuleHelper.visible = false;
                playerGroundRayHelpers.forEach(ray => ray.visible = false);
                physicsDebugMeshes.forEach(mesh => mesh.visible = false);
                podracerDebugLines.forEach(line => line.visible = false); 
                if (lastAirWallRayHelper) lastAirWallRayHelper.visible = false;
                const localPlayerForRender = players.get(localPlayerId);
                if (localPlayerForRender && localPlayerForRender.vehicle && localPlayerForRender.vehicle.colliderMeshHelper) {
                    localPlayerForRender.vehicle.colliderMeshHelper.visible = false;
                }

                // --- PASS 1: RENDER OCCLUSION MASK ---
                // In this pass, the sun is rendered white and all light-blocking objects are black.
                const originalSceneBackground = scene.background;
                scene.background = new THREE.Color(0x000000);
                godRaySun.material = occlusionMaterialWhite;

                // Temporarily swap the materials of all occluders to black.
                terrainMesh.traverse(child => { if (child.isMesh) { child.userData.originalMaterial = child.material; child.material = occlusionMaterialBlack; } });
                for (const player of players.values()) {
                    const activeModel = player.state.isInVehicle ? player.vehicle.mesh : player.model;
                    if (activeModel) { activeModel.traverse(child => { if (child.isMesh) { child.userData.originalMaterial = child.material; child.material = occlusionMaterialBlack; } }); }
                }
                if (racePortalObject && racePortalObject.visible) { racePortalObject.userData.originalMaterial = racePortalObject.material; racePortalObject.material = occlusionMaterialBlack; }

                // Render this black-and-white scene to our off-screen occlusion buffer.
                renderer.setRenderTarget(occlusionRenderTarget);
                renderer.render(scene, camera);

                // --- Restore all original materials ---
                godRaySun.material = sunMaterial; 
                scene.background = originalSceneBackground;
                terrainMesh.traverse(child => { if (child.isMesh && child.userData.originalMaterial) { child.material = child.userData.originalMaterial; } });
                for (const player of players.values()) {
                    const activeModel = player.state.isInVehicle ? player.vehicle.mesh : player.model;
                    if (activeModel) { activeModel.traverse(child => { if (child.isMesh && child.userData.originalMaterial) { child.material = child.userData.originalMaterial; } }); }
                }
                if (racePortalObject && racePortalObject.userData.originalMaterial) { racePortalObject.material = racePortalObject.userData.originalMaterial; }
                
                // Restore debug helper visibility if debug mode is active.
                if (isDebugVisible && localPlayerForRender) {
                    if (localPlayerForRender.state.controlMode === ControlMode.FPS) {
                        if (playerCapsuleHelper) playerCapsuleHelper.visible = true;
                        playerGroundRayHelpers.forEach(ray => ray.visible = true);
                        if (lastAirWallRayHelper) lastAirWallRayHelper.visible = true;
                    } else if (localPlayerForRender.state.controlMode === ControlMode.PODRACER) {
                        if (localPlayerForRender.vehicle.colliderMeshHelper) { localPlayerForRender.vehicle.colliderMeshHelper.visible = true; }
                        podracerDebugLines.forEach(line => line.visible = true);
                    }
                    physicsDebugMeshes.forEach(mesh => mesh.visible = true);
                }

                // --- PASS 2: GENERATE GOD RAYS ---
                // Run the god rays shader, using the occlusion mask as input, to generate the rays texture.
                const sunScreenPos = new THREE.Vector3().copy(godRaySun.position).project(camera);
                godraysMaterial.uniforms.lightPosition.value.set(sunScreenPos.x, sunScreenPos.y);
                post_quad.material = godraysMaterial;
                renderer.setRenderTarget(godraysRenderTarget);
                renderer.render(post_scene, post_camera);

                // --- PASS 3: FINAL COMPOSITION ---
                renderer.setRenderTarget(null);
                renderer.clear();
                // 3a. Render the main scene normally (with AA, etc.) via the EffectComposer.
                composer.render();
                // 3b. Render the god rays texture on top using additive blending.
                post_quad.material = finalCompositeMaterial;
                renderer.autoClear = false; // IMPORTANT: Do not clear the scene we just rendered.
                renderer.render(post_scene, post_camera); 
                renderer.autoClear = true; // Re-enable auto-clearing for the next frame.

            } else {
                // If paused or if god rays aren't ready, just render the scene normally.
                if (composer) {
                    composer.render();
                } else {
                    renderer.render(scene, camera);
                }
            }
            // Increment the frame counter for the FPS monitor.
            frameCount++;
        } // --- End of animate() function ---

        // ===================================================================
        // --- ⚙️ PHYSICS SIMULATION STEP ---
        // ===================================================================
        /**
         * Advances the Rapier physics world by one fixed timestep and processes
         * any collision events that occurred, such as crossing a race portal.
         * @param {number} deltaTime - Unused in this function, as Rapier uses its internal fixed timestep.
         */
        function stepPhysics(deltaTime) {
             if (physicsWorld) {
                 try {
                    // Advance the physics simulation.
                    physicsWorld.step(eventQueue);

                    // --- RACE PORTAL COLLISION EVENT HANDLING ---
                    eventQueue.drainCollisionEvents((handle1, handle2, started) => {
                        // We only care about when the collision *starts*.
                        if (!started) return;

                        // Check if the race is in the 'racing' state.
                        const isRaceReady = raceState.status === 'racing' && racePortalObject;
                        if (!isRaceReady) return;

                        console.log(`💥 [Collision Event] Fired! Handles: ${handle1}, ${handle2}.`);

                        // Identify which handle belongs to the portal and which belongs to the player.
                        let playerColliderHandle = -1;
                        if (handle1 === racePortalObject.userData.colliderHandle) {
                            playerColliderHandle = handle2;
                        } else if (handle2 === racePortalObject.userData.colliderHandle) {
                            playerColliderHandle = handle1;
                        }

                        // If the collision involved our race portal...
                        if (playerColliderHandle !== -1) {
                            const localPlayer = players.get(localPlayerId);
                            const podracerCollider = localPlayer ? localPlayer.vehicle.body.collider(0) : null;
                            if (podracerCollider) {
                                console.log(`🤔 [Collision Check] Comparing Event Handle (${playerColliderHandle}) with Podracer Handle (${podracerCollider.handle}).`);
                                
                                // ...and the other object was the local player's Podracer...
                                if (podracerCollider.handle === playerColliderHandle) {
                                    console.log("✅ MATCH! Colliding object is the Podracer. Checking direction...");

                                    // ...then check the direction of passage.
                                    const podracerBody = localPlayer.vehicle.body;
                                    const podracerVelocity = new THREE.Vector3().copy(podracerBody.linvel());
                                    const portalForward = racePortalObject.userData.forward;

                                    const dotProduct = podracerVelocity.dot(portalForward);
                                    console.log(`➡️  [Direction Check] Dot Product: ${dotProduct.toFixed(3)}. (Must be > 0 to count)`);

                                    // A positive dot product means the velocity and portal's forward vectors are aligned.
                                    if (dotProduct > 0) {
                                        handleLapCompletion(localPlayerId);
                                    }
                                } else {
                                    console.error("❌ NO MATCH! Object that hit the portal was NOT the Podracer!");
                                }
                            }
                        }
                    });

                 } catch(e) {
                    console.error("💥 Error during physicsWorld.step:", e);
                 }
             }
        }

        // ===================================================================
        // --- ✨ VISUALS-TO-PHYSICS SYNC ---
        // ===================================================================
        /**
         * Copies the position and rotation from every physics body (Rapier) to its
         * corresponding visual 3D model (Three.js). This is done for all players
         * every frame to keep the visuals perfectly in sync with the simulation.
         */
        function syncVisuals() {
            for (const player of players.values()) {
                if (!player || !player.body || player.body.isSleeping()) {
                    continue;
                }

                if (player.state.isInVehicle) {
                    // --- Sync logic for the Podracer ---
                    const podracer = player.vehicle;
                    if (podracer && podracer.body && podracer.mesh) {
                        const pos = podracer.body.translation();
                        const physRot = podracer.body.rotation(); 
                        const physicsQuaternion = new THREE.Quaternion(physRot.x, physRot.y, physRot.z, physRot.w);

                        podracer.mesh.position.set(pos.x, pos.y, pos.z);

                        // Apply the additional visual roll effect for ground turning.
                        if (isPodracerSoloCameraRollEnabled && Math.abs(player.state.vehicleState.currentVisualRoll) > 0.0001) {
                            const visualRollAxis = new THREE.Vector3(0, 0, 1);
                            const visualRollQuaternion = new THREE.Quaternion().setFromAxisAngle(visualRollAxis, player.state.vehicleState.currentVisualRoll);
                            podracer.mesh.quaternion.copy(physicsQuaternion).multiply(visualRollQuaternion);
                        } else {
                            podracer.mesh.quaternion.copy(physicsQuaternion);
                        }
                    }
                } else { 
                    // --- Sync logic for the FPS character ---
                    const playerBody = player.body;
                    const ajaxsonModel = player.model;

                    if (ajaxsonModel && playerBody) {
                        // For the local player, we first sync the physics body's rotation to the camera's yaw.
                        // This ensures the correct orientation is sent over the network.
                        if (player.isLocal) {
                            if (!player.state.isPlatformerCameraActive) {
                                const cameraEuler = new THREE.Euler(0, 0, 0, 'YXZ');
                                cameraEuler.setFromQuaternion(camera.quaternion, 'YXZ');
                                cameraEuler.x = 0; // Ignore camera pitch
                                cameraEuler.z = 0; // Ignore camera roll
                                const bodyTargetRotation = new THREE.Quaternion().setFromEuler(cameraEuler);
                                playerBody.setRotation(bodyTargetRotation, true);
                            }
                        }

                        // Now, sync the visual model to the (now correct) physics body for all players.
                        const playerPosRapier = playerBody.translation();
                        ajaxsonModel.position.set(playerPosRapier.x, playerPosRapier.y - PLAYER_HEIGHT / 2, playerPosRapier.z);

                        const playerRotationRapier = playerBody.rotation();
                        ajaxsonModel.quaternion.set(playerRotationRapier.x, playerRotationRapier.y, playerRotationRapier.z, playerRotationRapier.w);
                        
                        // Set visibility based on camera mode for local player.
                         if (player.isLocal) {
                            ajaxsonModel.visible = player.state.isThirdPersonActive || player.state.isPlatformerCameraActive;
                            
                            if (playerCapsuleHelper) {
                                playerCapsuleHelper.position.set(playerPosRapier.x, playerPosRapier.y, playerPosRapier.z);
                                playerCapsuleHelper.quaternion.copy(ajaxsonModel.quaternion);
                            }

                        } else {
                            ajaxsonModel.visible = true; // Remote players are always visible when on foot.
                        }
                    }
                }
            }
        }

        // ===================================================================
        // --- 🎥 CAMERA UPDATE FUNCTIONS ---
        // ===================================================================
        /**
         * Main camera update orchestrator. Calls the appropriate specific camera
         * function based on the local player's current control mode.
         */
        function updateCamera() {
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            switch (localPlayer.state.controlMode) {
                case ControlMode.FPS:
                    updatePlayerFPSCamera(localPlayer.body);
                    break;
                case ControlMode.PODRACER:
                    updatePodracerCamera(localPlayer.vehicle);
                    break;
            }
        }

        /**
         * Handles all camera logic for the First-Person Shooter mode, including
         * first-person, third-person, and 3D platformer views.
         */
        function updatePlayerFPSCamera(localPlayerBody) {
            if (!localPlayerBody || !camera || localPlayerBody.isSleeping()) return;
            
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            const playerPositionRapier = localPlayerBody.translation();
            const playerPositionThree = new THREE.Vector3(playerPositionRapier.x, playerPositionRapier.y, playerPositionRapier.z);

            // --- Third-Person Follow Camera ---
            if (localPlayer.state.isThirdPersonActive) {
                const dynamicOffset = new THREE.Vector3(FPS_THIRD_PERSON_OFFSET.x, FPS_THIRD_PERSON_OFFSET.y, localPlayer.state.thirdPersonZoomDistance);
                dynamicOffset.applyQuaternion(camera.quaternion);
                const desiredCamPos = playerPositionThree.clone().add(dynamicOffset);
                camera.position.lerp(desiredCamPos, FPS_THIRD_PERSON_CAM_LERP_FACTOR);

            // --- 3D Platformer Orbital Camera ---
            } else if (localPlayer.state.isPlatformerCameraActive) {
                const lookAtTargetPoint = playerPositionThree.clone().add(new THREE.Vector3(0, PLAYER_PLATFORMER_LOOKAT_Y_OFFSET, 0));
                let cameraPosition = new THREE.Vector3(0, 0, localPlayer.state.platformerCameraDistance);

                // Apply vertical rotation (elevation).
                const elevationQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), localPlayer.state.platformerCameraElevation);
                cameraPosition.applyQuaternion(elevationQuaternion);

                // Apply horizontal rotation (azimuth).
                const azimuthQuaternion = new THREE.Quaternion().setFromAxisAngle(UP_VECTOR, localPlayer.state.platformerCameraAzimuth);
                cameraPosition.applyQuaternion(azimuthQuaternion);

                camera.position.copy(lookAtTargetPoint).add(cameraPosition);
                camera.lookAt(lookAtTargetPoint);

            // --- First-Person Camera ---
            } else { 
                camera.position.set(
                    playerPositionThree.x,
                    playerPositionThree.y + PLAYER_EYE_HEIGHT - PLAYER_HEIGHT / 2,
                    playerPositionThree.z
                );
            }
            camera.updateMatrixWorld(true);
        }

        /**
         * Handles all camera logic for the Podracer, including first-person
         * and multiple third-person attached views with dynamic aiming tilt.
         */
        function updatePodracerCamera(localPodracer) {
            if (!localPodracer || !localPodracer.body || !localPodracer.mesh || localPodracer.body.isSleeping()) return;
            
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;
            const vs = localPlayer.state.vehicleState; 

            const currentPodracerTranslation = localPodracer.body.translation();
            const currentPodracerRotation = localPodracer.body.rotation();
            const physicsBasedQuaternion = new THREE.Quaternion(currentPodracerRotation.x, currentPodracerRotation.y, currentPodracerRotation.z, currentPodracerRotation.w);
            const podracerPositionVec3 = new THREE.Vector3(currentPodracerTranslation.x, currentPodracerTranslation.y, currentPodracerTranslation.z);

            // --- Dynamic Camera Tilt Calculation for Aiming ---
            let tiltQuaternion = new THREE.Quaternion();
            if (vs.currentCameraMode === PODRACER_CAM_MODE.ATTACHED || vs.currentCameraMode === PODRACER_CAM_MODE.ATTACHED_FAR) {
                const cameraOffset = (vs.currentCameraMode === PODRACER_CAM_MODE.ATTACHED) ? PODRACER_ATTACHED_CAM_OFFSET : PODRACER_ATTACHED_FAR_CAM_OFFSET;
                const opposite = cameraOffset.y;
                const adjacent = PODRACER_TARGET_AIM_DISTANCE + cameraOffset.z;
                if (adjacent > 0.01) {
                    const tiltAngleRad = -Math.atan(opposite / adjacent);
                    const tiltAxis = new THREE.Vector3(1, 0, 0); // Camera's local X-axis
                    tiltQuaternion.setFromAxisAngle(tiltAxis, tiltAngleRad);
                }
            }
            
            // Apply position and rotation based on the current camera mode.
            switch (vs.currentCameraMode) {
                case PODRACER_CAM_MODE.ATTACHED: {
                    if (localPodracer.mesh) localPodracer.mesh.visible = true;
                    const worldOffset = PODRACER_ATTACHED_CAM_OFFSET.clone().applyQuaternion(physicsBasedQuaternion);
                    const targetCamPos = podracerPositionVec3.clone().add(worldOffset);
                    camera.position.lerp(targetCamPos, PODRACER_ATTACHED_CAM_LERP_FACTOR);

                    // Combine the physics rotation, aiming tilt, and visual roll for the final camera orientation.
                    let targetCameraQuaternion = physicsBasedQuaternion.clone();
                    targetCameraQuaternion.multiply(tiltQuaternion);
                    if (isPodracerSoloCameraRollEnabled && Math.abs(vs.currentVisualRoll) > 0.0001) {
                        const cameraVisualRollAxis = new THREE.Vector3(0, 0, 1);
                        const cameraVisualRollQuaternion = new THREE.Quaternion().setFromAxisAngle(cameraVisualRollAxis, vs.currentVisualRoll);
                        targetCameraQuaternion.multiply(cameraVisualRollQuaternion);
                    }
                    camera.quaternion.slerp(targetCameraQuaternion, PODRACER_ATTACHED_CAM_LERP_FACTOR);
                    break;
                }
                case PODRACER_CAM_MODE.FIRST_PERSON: {
                    if (localPodracer.mesh) localPodracer.mesh.visible = false;
                    const worldOffsetFPV = PODRACER_FIRST_PERSON_CAM_OFFSET.clone().applyQuaternion(physicsBasedQuaternion);
                    const targetCamPosFPV = podracerPositionVec3.clone().add(worldOffsetFPV);
                    camera.position.lerp(targetCamPosFPV, PODRACER_FIRST_PERSON_CAM_LERP_FACTOR);
                    
                    let targetCameraQuaternionFPV = physicsBasedQuaternion.clone();
                    if (isPodracerSoloCameraRollEnabled && Math.abs(vs.currentVisualRoll) > 0.0001) {
                        const cameraVisualRollAxisFPV = new THREE.Vector3(0, 0, 1);
                        const cameraVisualRollQuaternionFPV = new THREE.Quaternion().setFromAxisAngle(cameraVisualRollAxisFPV, vs.currentVisualRoll);
                        targetCameraQuaternionFPV.multiply(cameraVisualRollQuaternionFPV);
                    }
                    camera.quaternion.slerp(targetCameraQuaternionFPV, PODRACER_FIRST_PERSON_CAM_LERP_FACTOR);
                    break;
                }
                case PODRACER_CAM_MODE.ATTACHED_FAR: {
                    if (localPodracer.mesh) localPodracer.mesh.visible = true;
                    const worldOffsetFar = PODRACER_ATTACHED_FAR_CAM_OFFSET.clone().applyQuaternion(physicsBasedQuaternion);
                    const targetCamPosFar = podracerPositionVec3.clone().add(worldOffsetFar);
                    camera.position.lerp(targetCamPosFar, PODRACER_ATTACHED_FAR_CAM_LERP_FACTOR);

                    let targetCameraQuaternionFar = physicsBasedQuaternion.clone();
                    targetCameraQuaternionFar.multiply(tiltQuaternion);
                    if (isPodracerSoloCameraRollEnabled && Math.abs(vs.currentVisualRoll) > 0.0001) {
                        const cameraVisualRollAxisFar = new THREE.Vector3(0, 0, 1);
                        const cameraVisualRollQuaternionFar = new THREE.Quaternion().setFromAxisAngle(cameraVisualRollAxisFar, vs.currentVisualRoll);
                        targetCameraQuaternionFar.multiply(cameraVisualRollQuaternionFar);
                    }
                    camera.quaternion.slerp(targetCameraQuaternionFar, PODRACER_ATTACHED_FAR_CAM_LERP_FACTOR);
                    break;
                }
                default:
                    if (localPodracer.mesh) localPodracer.mesh.visible = true;
                    console.warn("⚠️ Unknown or unsupported Podracer camera mode:", vs.currentCameraMode, ". Defaulting to ATTACHED.");
                    vs.currentCameraMode = PODRACER_CAM_MODE.ATTACHED;
                    break;
            }
            camera.updateMatrixWorld(true);
        }

        // ===================================================================
        // --- 🎥 CAMERA OBSTRUCTION CHECK ---
        // ===================================================================
        /**
         * Casts rays from the player/vehicle towards the camera to detect if terrain
         * is blocking the view. If obstructed, it can make the terrain transparent.
         */
        function checkCameraObstruction() {
            if (!physicsWorld) { return; }

            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            const isThirdPersonView =
                (localPlayer.state.controlMode === ControlMode.FPS && (localPlayer.state.isThirdPersonActive || localPlayer.state.isPlatformerCameraActive)) ||
                (localPlayer.state.controlMode === ControlMode.PODRACER);

            if (!isThirdPersonView) {
                // If switching to first-person, ensure the terrain is fully opaque again.
                if (isCameraCurrentlyObstructed) {
                    isCameraCurrentlyObstructed = false;
                    terrainOutlineMaterials.forEach(mat => { mat.transparent = false; mat.opacity = 1.0; mat.needsUpdate = true; });
                    console.log("%c🎥 View Cleared (Switched to 1st Person)", "color: green; font-weight: bold;");
                }
                return;
            }

            // Determine the raycast's starting point (the player or vehicle center).
            let targetPosition = new THREE.Vector3();
            let raycastSourceBody = null;
            let targetFound = false;
            
            if (localPlayer.state.controlMode === ControlMode.FPS && localPlayer.body) {
                const playerPos = localPlayer.body.translation();
                targetPosition.set(playerPos.x, playerPos.y + PLAYER_PLATFORMER_LOOKAT_Y_OFFSET, playerPos.z);
                raycastSourceBody = localPlayer.body;
                targetFound = true;
            } else if (localPlayer.state.controlMode === ControlMode.PODRACER && localPlayer.vehicle.body) {
                const podracerPos = localPlayer.vehicle.body.translation();
                targetPosition.set(podracerPos.x, podracerPos.y, podracerPos.z);
                raycastSourceBody = localPlayer.vehicle.body;
                targetFound = true;
            }
            if (!targetFound) { return; }

            // Use multiple rays for more robust detection.
            const direction = new THREE.Vector3().subVectors(camera.position, targetPosition);
            const distance = direction.length();
            let obstructionDetectedThisFrame = false;
            
            // Main ray from player to camera.
            if (distance > 0.2) {
                direction.normalize();
                const rayMain = new RAPIER.Ray({ x: targetPosition.x, y: targetPosition.y, z: targetPosition.z }, { x: direction.x, y: direction.y, z: direction.z });
                const filterCollider = raycastSourceBody ? raycastSourceBody.collider(0) : null;
                const hitMain = physicsWorld.castRay(rayMain, distance - 0.2, true, RAPIER.QueryFilterFlags.EXCLUDE_DYNAMIC, undefined, filterCollider);
                if (hitMain) obstructionDetectedThisFrame = true;
            }
            
            // Supplemental rays from the camera outwards to detect clipping.
            if (!obstructionDetectedThisFrame) {
                const cameraLeftDir = new THREE.Vector3(-1, 0, 0).applyQuaternion(camera.quaternion);
                const rayLeft = new RAPIER.Ray(camera.position, cameraLeftDir);
                if (physicsWorld.castRay(rayLeft, 1.0, true, RAPIER.QueryFilterFlags.EXCLUDE_DYNAMIC, undefined, undefined)) obstructionDetectedThisFrame = true;
            }
            if (!obstructionDetectedThisFrame) {
                const cameraRightDir = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                const rayRight = new RAPIER.Ray(camera.position, cameraRightDir);
                if (physicsWorld.castRay(rayRight, 1.0, true, RAPIER.QueryFilterFlags.EXCLUDE_DYNAMIC, undefined, undefined)) obstructionDetectedThisFrame = true;
            }
            if (!obstructionDetectedThisFrame) {
                const cameraBackDir = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);
                const rayBack = new RAPIER.Ray(camera.position, cameraBackDir);
                if (physicsWorld.castRay(rayBack, 2.0, true, RAPIER.QueryFilterFlags.EXCLUDE_DYNAMIC, undefined, undefined)) obstructionDetectedThisFrame = true;
            }

            // Update material transparency only when the obstruction state *changes*.
            if (obstructionDetectedThisFrame && !isCameraCurrentlyObstructed) {
                terrainOutlineMaterials.forEach(mat => { mat.transparent = true; mat.opacity = 0.4; mat.needsUpdate = true; });
                console.log(`%c🎥 Camera OBSTRUCTED (Rapier detected hit)`, "color: red; font-weight: bold;");
            }
            else if (!obstructionDetectedThisFrame && isCameraCurrentlyObstructed) {
                terrainOutlineMaterials.forEach(mat => { mat.transparent = false; mat.opacity = 1.0; mat.needsUpdate = true; });
                console.log("%c🎥 View Cleared (Rapier detected no hit)", "color: green; font-weight: bold;");
            }

            isCameraCurrentlyObstructed = obstructionDetectedThisFrame;
        }


        // ===================================================================
        // --- 9. UI (USER INTERFACE) LOGIC ---
        // ===================================================================
        // This section manages all user interface elements, including the pause menu,
        // HUD, on-screen instructions, and visual indicators.

        // --- Pause Menu Functions ---
        
        // ===================================================================
        // --- ⏸️ PAUSE/RESUME GAME FUNCTION ---
        // ===================================================================
        /**
         * Toggles the game's paused state. This function handles showing/hiding menus,
         * unlocking the mouse pointer, and re-locking it upon resuming.
         * @param {boolean} [forcePauseState] - Optional. If true, forces the game to pause. If false, forces it to resume.
         */
        function togglePause(forcePauseState) {
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            // Determine the new pause state. If `forcePauseState` is provided, use it. Otherwise, invert the current state.
            const newPauseState = (forcePauseState === undefined) ? !isPaused : forcePauseState;
            
            // If the state is not changing, do nothing.
            if (newPauseState === isPaused) return;

            isPaused = newPauseState;

            if (isPaused) {
                // --- Actions to perform when PAUSING the game ---
                console.log(`togglePause: Game PAUSED.`);
                
                // Show the main pause menu.
                if (pauseMenuElement) pauseMenuElement.style.display = "block";
                
                // Unlock the mouse pointer so the user can interact with the menu.
                if (controls && controls.isLocked) { 
                    controls.unlock(); 
                }
                
                // Update the visibility of menu options based on the current game context (e.g., show Podracer options).
                updatePauseMenuOptionsVisibility();

            } else {
                // --- Actions to perform when RESUMING the game ---
                console.log(`togglePause: Game RESUMED.`);
                
                // Hide ALL menus to ensure a clean return to gameplay.
                if (pauseMenuElement) pauseMenuElement.style.display = "none";
                if (playgroundMenu) playgroundMenu.style.display = 'none';
                if (raceSetupMenu) raceSetupMenu.style.display = 'none';
                if (soloRaceConfigMenu) soloRaceConfigMenu.style.display = 'none';
                
                // Automatically re-lock the mouse pointer for gameplay.
                const mode = localPlayer.state.controlMode;
                if ((mode === ControlMode.FPS || mode === ControlMode.PODRACER)) {
                    // Use a short timeout to ensure the browser has processed the menu-closing events.
                    setTimeout(() => {
                        const currentLocalPlayer = players.get(localPlayerId);
                        if (!isPaused && currentLocalPlayer && (currentLocalPlayer.state.controlMode === ControlMode.FPS || currentLocalPlayer.state.controlMode === ControlMode.PODRACER) && controls && !controls.isLocked) {
                           controls.lock();
                        }
                    }, 75);
                }
            }
            
            // Update UI elements that depend on the pause state.
            updateCursorAndIndicators();
            updateInstructions();
        }

        // ===================================================================
        // --- ⚙️ UPDATE PAUSE MENU OPTIONS VISIBILITY ---
        // ===================================================================
        /**
         * Shows or hides specific options in the pause menu based on the current
         * control mode (e.g., only show Podracer settings when in the Podracer).
         */
        function updatePauseMenuOptionsVisibility() {
            if (!isPaused || !pauseMenuElement) {
                // If not paused, ensure all contextual options are hidden.
                if (podracerMouseFlightModeOptionElement) podracerMouseFlightModeOptionElement.style.display = 'none';
                if (podracerMouseSoloModeOptionElement) podracerMouseSoloModeOptionElement.style.display = 'none';
                const podracerSoloCameraRollOptionElement = document.getElementById('podracerSoloCameraRollOption');
                if (podracerSoloCameraRollOptionElement) podracerSoloCameraRollOptionElement.style.display = 'none';
                if (podracerSoloWSAccelModeOptionElement) podracerSoloWSAccelModeOptionElement.style.display = 'none';
                return;
            }

            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            const isPodracerMode = localPlayer.state.controlMode === ControlMode.PODRACER;
            const isPodracerSoloMode = isPodracerMode && !localPlayer.state.vehicleState.isInFlightMode; // Solo = on the ground.

            // Toggle visibility for each contextual option.
            if (podracerMouseFlightModeOptionElement) {
                podracerMouseFlightModeOptionElement.style.display = isPodracerMode ? 'flex' : 'none';
            }
            if (podracerMouseSoloModeOptionElement) {
                podracerMouseSoloModeOptionElement.style.display = isPodracerMode ? 'flex' : 'none';
            }
            const podracerSoloCameraRollOptionElement = document.getElementById('podracerSoloCameraRollOption');
            if (podracerSoloCameraRollOptionElement) {
                podracerSoloCameraRollOptionElement.style.display = isPodracerSoloMode ? 'flex' : 'none';
            }
            if (podracerSoloWSAccelModeOptionElement) {
                podracerSoloWSAccelModeOptionElement.style.display = isPodracerSoloMode ? 'flex' : 'none';
            }
            if (podracerSoloKeyControlModeOptionElement) {
                podracerSoloKeyControlModeOptionElement.style.display = isPodracerSoloMode ? 'flex' : 'none';
            }
            if (podracerArrowsAccelModeOptionElement) {
                podracerArrowsAccelModeOptionElement.style.display = isPodracerMode ? 'flex' : 'none';
            }
            if (podracerMaxSpeedOptionElement) {
                podracerMaxSpeedOptionElement.style.display = isPodracerMode ? 'flex' : 'none';
            }
            
            console.log(`Pause menu visibility updated. Podracer Mode: ${isPodracerMode}, Ground Mode: ${isPodracerSoloMode}`);
        }

        // ===================================================================
        // --- 🎨 APPLY RENDER STYLE (NORMAL / PIXELATED) ---
        // ===================================================================
        /**
         * Applies the selected texture filtering style to all relevant objects in the scene.
         * 'NORMAL' uses linear filtering for a smooth look.
         * 'NEAREST' uses nearest-neighbor filtering for a sharp, retro look.
         * @param {string} style - The desired style ('NORMAL' or 'NEAREST').
         */
        function applyRenderStyle(style) {
            console.log(`🎨 Applying render style: ${style}`);
            currentRenderStyle = style;

            let magFilter, minFilter;
            let applyAnisotropy = false;

            if (style === 'NEAREST') {
                magFilter = THREE.NearestFilter;
                minFilter = THREE.NearestFilter;
            } else { // 'NORMAL'
                magFilter = THREE.LinearFilter;
                minFilter = THREE.LinearMipmapLinearFilter; // High-quality filtering with mipmaps.
                applyAnisotropy = true; // Enable anisotropic filtering for better texture quality at sharp angles.
            }

            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();

            // Iterate over every object we've flagged as "texturable".
            allTexturedObjects.forEach(object => {
                if (!object) return;
                
                object.traverse((child) => {
                    if (child.isMesh) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(material => {
                            if (material && material.map) { // Check if the material has a texture.
                                let needsUpdate = false;

                                if (material.map.magFilter !== magFilter) {
                                    material.map.magFilter = magFilter;
                                    needsUpdate = true;
                                }
                                if (material.map.minFilter !== minFilter) {
                                    material.map.minFilter = minFilter;
                                    needsUpdate = true;
                                }

                                // Apply or reset anisotropic filtering.
                                if (applyAnisotropy && maxAnisotropy > 0) {
                                    if (material.map.anisotropy !== maxAnisotropy) {
                                        material.map.anisotropy = maxAnisotropy;
                                        needsUpdate = true;
                                    }
                                } else if (material.map.anisotropy !== 1) { // Reset to default if not applying.
                                    material.map.anisotropy = 1;
                                    needsUpdate = true;
                                }

                                // This flag is crucial to tell Three.js to apply the texture changes.
                                if (needsUpdate) {
                                    material.map.needsUpdate = true;
                                }
                            }
                        });
                    }
                });
            });

            // Update the text in the pause menu.
            if (renderStyleValueElement) {
                renderStyleValueElement.textContent = style;
            }
            console.log(`🎨 Render style ${style} applied successfully.`);
        }

        // ===================================================================
        // --- 🎞️ APPLY ANTIALIASING LEVEL ---
        // ===================================================================
        /**
         * Sets the active antialiasing (AA) method for the post-processing pipeline.
         * @param {string} level - The desired AA level ('Off', 'FXAA', or 'SMAA').
         */
        function applyAALevel(level) {
            console.log(`🎨 Applying Antialiasing level: ${level}`);
            currentAALevel = level;

            if (pixelationOptionElement) {
                // If AA is turned off, the dynamic pixelation option becomes available.
                if (level === 'Off') {
                    pixelationOptionElement.style.display = 'flex';
                } 
                // If any AA method is active, hide the pixelation option and disable the effect.
                else {
                    pixelationOptionElement.style.display = 'none';
                    applyPixelationMode(false);
                }
            }

            // Enable the selected post-processing pass and disable the others.
            if (fxaaPass) {
                fxaaPass.enabled = (level === 'FXAA');
            }
            if (smaaPass) {
                smaaPass.enabled = (level === 'SMAA');
            }

            // Update the text in the pause menu.
            if (aaValueElement) {
                aaValueElement.textContent = level;
            }
        }

        // ===================================================================
        // --- 👾 APPLY DYNAMIC PIXELATION MODE ---
        // ===================================================================
        /**
         * Toggles the custom dynamic pixelation post-processing effect.
         * @param {boolean} enabled - True to enable the effect, false to disable.
         */
        function applyPixelationMode(enabled) {
            console.log(`🎨 Applying Dynamic Pixelation mode: ${enabled ? 'ON' : 'OFF'}`);
            isPixelationActive = enabled;

            if (pixelPass && renderPass && fxaaPass && smaaPass) {
                // The pixelation pass replaces the standard render pass. Only one can be active.
                pixelPass.enabled = enabled;
                renderPass.enabled = !enabled;

                // If pixelation is enabled, we must disable other AA methods to preserve the sharp pixels.
                if (enabled) {
                    fxaaPass.enabled = false;
                    smaaPass.enabled = false;
                }
            }

            // Update the text in the pause menu.
            if (pixelationValueElement) {
                pixelationValueElement.textContent = enabled ? 'On' : 'Off';
            }
        }

        // ===================================================================
        // --- ✒️ OUTLINE EFFECT CONTROL FUNCTIONS ---
        // ===================================================================
        /**
         * Toggles the visibility of all outline meshes in the scene.
         * @param {boolean} enabled - True to show outlines, false to hide.
         */
        function applyOutlineEnabled(enabled) {
            console.log(`🎨 Applying outline visibility: ${enabled ? 'Enabled' : 'Disabled'}`);
            isOutlineEnabled = enabled;

            // Iterate through our stored list of all outline meshes and set their visibility.
            allOutlineMeshes.forEach(mesh => {
                mesh.visible = enabled;
            });

            // Update the text in the pause menu.
            const outlineEnabledValueElement = document.getElementById('outlineEnabledValue');
            if (outlineEnabledValueElement) {
                outlineEnabledValueElement.textContent = enabled ? 'Enabled' : 'Disabled';
            }
        }

        /**
         * Applies a new color to all outline materials in the scene.
         * This uses an "inverted" logic where the selected color is the inner glow,
         * and the outer edge is always black for a consistent silhouette effect.
         * @param {string} colorName - The name of the color to apply (e.g., 'Magenta').
         */
        function applyOutlineColor(colorName) {
            if (!OUTLINE_COLORS_MAP[colorName]) {
                console.warn(`Outline color "${colorName}" not found. Defaulting to Black.`);
                colorName = 'Preto';
            }
            
            console.log(`🎨 Applying outline color (Inverted Logic): ${colorName}`);
            currentOutlineColorName = colorName;

            // The selected color becomes the inner part of the Fresnel gradient.
            const innerColorHex = OUTLINE_COLORS_MAP[colorName];
            
            // The outer edge of the Fresnel gradient is hardcoded to black for the silhouette.
            const outerColorHex = '#000000'; 
            
            const newInnerColor = new THREE.Color(innerColorHex);
            const newOuterColor = new THREE.Color(outerColorHex);

            // Iterate through our stored list of all outline materials and update their shader uniforms.
            allOutlineMaterials.forEach(material => {
                if (material.isCustomOutlineMaterial && material.uniforms) {
                    material.uniforms.uInnerColor.value.copy(newInnerColor);
                    material.uniforms.uOuterColor.value.copy(newOuterColor);
                }
            });

            // Update the text in the pause menu.
            const outlineColorValueElement = document.getElementById('outlineColorValue');
            if (outlineColorValueElement) {
                outlineColorValueElement.textContent = colorName;
            }
        }
  

        // ===================================================================
        // --- 🚀 PODRACER CONTROL MODE SETTERS ---
        // ===================================================================
        // These functions are called from the pause menu to apply changes to the
        // Podracer's control scheme. They update the global state and reset any
        // relevant player state variables to prevent unexpected behavior.

        /**
         * Applies the selected mouse control mode for the Podracer while in flight.
         * 'STEERING': Mouse acts like a virtual joystick (positional control).
         * 'NON_STEERING': Mouse movement directly controls the rate of rotation (rate control).
         * @param {string} mode - The desired mode ('STEERING' or 'NON_STEERING').
         */
        function applyPodracerMouseFlightMode(mode) {
            console.log(`🖱️✈️ Applying Podracer flight mouse mode: ${mode}`);
            currentPodracerMouseFlightMode = mode;

            // Update the text display in the pause menu.
            if (podracerMouseFlightModeValueElement) {
                podracerMouseFlightModeValueElement.textContent = mode.charAt(0).toUpperCase() + mode.slice(1).toLowerCase();
            }
            
            // Reset player state to prevent carry-over velocity from the old mode.
            const localPlayer = players.get(localPlayerId);
            if (localPlayer) {
                const vs = localPlayer.state.vehicleState;
                vs.yawVelocity = 0.0;
                vs.pitchVelocity = 0.0;
                vs.keyYawRate = 0.0;
                vs.keyPitchRate = 0.0;
            }

            // Reset UI and mouse input variables.
            virtualSteeringWheelPosition = 0.0; 
            virtualJoystickPitchPosition = 0.0;
            mouseScreenOffsetX = 0.0;
            targetPodracerYawRateFromMouse = 0.0;
            targetPodracerPitchRateFromMouse = 0.0;

            // Refresh UI elements to reflect the new control scheme.
            updateCursorAndIndicators();
            updateInstructions();
        }

        /**
         * Applies the selected mouse control mode for the Podracer while on the ground.
         * @param {string} mode - The desired mode ('STEERING' or 'NON_STEERING').
         */
        function applyPodracerMouseSoloMode(mode) {
            console.log(`🖱️🛸 Applying Podracer ground mouse mode: ${mode}`);
            currentPodracerMouseSoloMode = mode;

            if (podracerMouseSoloModeValueElement) {
                podracerMouseSoloModeValueElement.textContent = mode.charAt(0).toUpperCase() + mode.slice(1).toLowerCase();
            }

            const localPlayer = players.get(localPlayerId);
            if (localPlayer) {
                const vs = localPlayer.state.vehicleState;
                vs.yawVelocity = 0.0;
                vs.keyYawRate = 0.0;
            }

            virtualSteeringWheelPosition = 0.0;
            mouseScreenOffsetX = 0.0;
            targetPodracerYawRateFromMouse = 0.0;

            updateCursorAndIndicators();
            updateInstructions();
        }

        /**
         * Toggles the visual camera roll effect when turning the Podracer on the ground.
         * @param {boolean} enabled - True to enable the effect, false to disable.
         */
        function applyPodracerSoloCameraRollMode(enabled) {
            console.log(`📷🎥 Applying Podracer ground camera roll: ${enabled ? "Enabled" : "Disabled"}`);
            isPodracerSoloCameraRollEnabled = enabled;

            const podracerSoloCameraRollValueElement = document.getElementById('podracerSoloCameraRollValue');
            if (podracerSoloCameraRollValueElement) {
                podracerSoloCameraRollValueElement.textContent = enabled ? "Enabled" : "Disabled";
            }
        }

        /**
         * Sets the acceleration behavior for the W/S keys while the Podracer is on the ground.
         * 'RACE': W/S keys provide instant max forward/reverse thrust.
         * 'THROTTLE': W/S keys gradually increase/decrease the thrust level.
         * @param {string} mode - The desired mode ('RACE' or 'THROTTLE').
         */
        function applyPodracerSoloWSAccelMode(mode) {
            console.log(`⚙️🏎️ Applying W/S acceleration mode (Pod Ground): ${mode}`);
            currentPodracerSoloWSAccelMode = mode;

            if (podracerSoloWSAccelModeValueElement) {
                podracerSoloWSAccelModeValueElement.textContent = mode.charAt(0).toUpperCase() + mode.slice(1).toLowerCase();
            }

            updateInstructions();
        }

        /**
         * Sets the acceleration behavior for the Arrow keys for the Podracer in all modes.
         * @param {string} mode - The desired mode ('RACE' or 'THROTTLE').
         */
        function applyPodracerArrowsAccelMode(mode) {
            console.log(`⚙️↕️ Applying Arrow Keys acceleration mode (Pod): ${mode}`);
            currentPodracerArrowsAccelMode = mode;

            if (podracerArrowsAccelModeValueElement) {
                podracerArrowsAccelModeValueElement.textContent = mode.charAt(0).toUpperCase() + mode.slice(1).toLowerCase();
            }

            updateInstructions();
        }

        /**
         * Sets the key binding layout for A/D and Q/E keys while the Podracer is on the ground.
         * @param {string} mode - The desired key layout.
         */
        function applyPodracerSoloKeyControlMode(mode) {
            console.log(`⚙️⌨️ Applying ground key control mode (Pod Ground): ${mode}`);
            currentPodracerSoloKeyControlMode = mode;

            if (podracerSoloKeyControlModeValueElement) {
                if (mode === PODRACER_SOLO_KEY_CONTROL_MODE.STRAFE_AD_YAW_QE) {
                    podracerSoloKeyControlModeValueElement.textContent = "A/D:Strafe, Q/E:Yaw";
                } else { // YAW_AD_STRAFE_QE
                    podracerSoloKeyControlModeValueElement.textContent = "A/D:Yaw, Q/E:Strafe";
                }
            }

            updateInstructions();
        }

        /**
         * Sets the adjustable maximum forward speed for the Podracer.
         * @param {number} newSpeedKmh - The new maximum speed in kilometers per hour.
         */
        function applyPodracerMaxSpeed(newSpeedKmh) {
            console.log(`🏎️💨 Applying Podracer max speed adjustment: ${newSpeedKmh} km/h`);
            currentPodracerAdjustableMaxSpeedKmh = newSpeedKmh;

            // Recalculate the max speed in meters per second, which is used by the physics logic.
            PODRACER_MAX_FORWARD_SPEED_MS = currentPodracerAdjustableMaxSpeedKmh / UNITS_PER_SECOND_TO_KM_PER_HOUR;

            if (podracerMaxSpeedValueElement) {
                podracerMaxSpeedValueElement.textContent = currentPodracerAdjustableMaxSpeedKmh.toFixed(0);
            }
            
            console.log(`   -> New PODRACER_MAX_FORWARD_SPEED_MS: ${PODRACER_MAX_FORWARD_SPEED_MS.toFixed(2)} m/s`);
        }

        // ===================================================================
        // --- 🏷️ UPDATE PLAYER NAMETAGS ---
        // ===================================================================
        /**
         * Renders the nametags for all remote players onto the 2D UI canvas.
         * This function converts 3D world positions to 2D screen coordinates.
         */
        function updateNameTags() {
            const localPlayer = players.get(localPlayerId);

            // Gatekeeper check: Only run if in multiplayer, nametags are enabled, and the local player exists.
            if (currentGlobalMode !== GameMode.GAME_MULTIPLAYER || !areNameTagsVisible || !localPlayer || !localPlayer.body) {
                if (uiContext && uiCanvas.width > 0) uiContext.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
                return;
            }

            // Clear the canvas from the previous frame.
            uiContext.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
            
            // Reusable vector for calculations.
            const tempVector = new THREE.Vector3();

            // Determine the local player's current position for distance calculations.
            const localPlayerActiveBody = localPlayer.state.isInVehicle ? localPlayer.vehicle.body : localPlayer.body;
            if (!localPlayerActiveBody) return;
            const localPlayerPos3D = new THREE.Vector3().copy(localPlayerActiveBody.translation());

            // Iterate through all players to draw nametags for remote ones.
            for (const remotePlayer of players.values()) {
                if (remotePlayer.isLocal) {
                    continue; // Skip the local player.
                }

                const remotePlayerActiveBody = remotePlayer.state.isInVehicle ? remotePlayer.vehicle.body : remotePlayer.body;
                if (!remotePlayerActiveBody) {
                    continue; 
                }

                // --- Position Calculation ---
                // 1. Get the remote player's 3D world position.
                const remotePlayerBodyPos3D = new THREE.Vector3().copy(remotePlayerActiveBody.translation());
                
                // 2. Add a vertical offset to position the tag above the player/vehicle.
                const tagVerticalOffset = remotePlayer.state.isInVehicle ? 2.5 : PLAYER_HEIGHT;
                tempVector.copy(remotePlayerBodyPos3D);
                tempVector.y += tagVerticalOffset;

                // 3. Project the 3D point into 2D screen space coordinates (from -1 to +1).
                tempVector.project(camera);

                // 4. If the tag is behind the camera (z > 1), don't draw it.
                if (tempVector.z > 1) {
                    continue;
                }

                // 5. Convert the normalized screen coordinates to actual canvas pixel coordinates.
                const x = (tempVector.x * 0.5 + 0.5) * uiCanvas.width;
                const y = (tempVector.y * -0.5 + 0.5) * uiCanvas.height;

                // --- Text and Measurement ---
                const distanceToRemote = localPlayerPos3D.distanceTo(remotePlayerBodyPos3D);
                const displayName = remotePlayer.displayName || 'Rider';
                const distanceText = `${distanceToRemote.toFixed(0)}m`;

                // --- Drawing Logic (using NAMETAG_PARAMS for styling) ---
                uiContext.font = `${NAMETAG_PARAMS.fontWeight} ${NAMETAG_PARAMS.fontSize}px ${NAMETAG_PARAMS.fontFamily}`;
                uiContext.textAlign = 'center';
                
                // Measure text widths to dynamically size the background.
                const nameWidth = uiContext.measureText(displayName).width;
                const distWidth = uiContext.measureText(distanceText).width;
                const backgroundWidth = Math.max(nameWidth, distWidth) + (NAMETAG_PARAMS.padding * 2);
                const backgroundHeight = (NAMETAG_PARAMS.padding * 2) + (NAMETAG_PARAMS.fontSize * 2) + (NAMETAG_PARAMS.padding / 2);

                // Draw the semi-transparent background box.
                uiContext.fillStyle = NAMETAG_PARAMS.backgroundColor;
                uiContext.globalAlpha = NAMETAG_PARAMS.backgroundOpacity;
                uiContext.fillRect(x - backgroundWidth / 2, y - backgroundHeight, backgroundWidth, backgroundHeight);

                // IMPORTANT: Reset alpha to 1.0 before drawing text.
                uiContext.globalAlpha = 1.0;

                // Draw the text on top of the background.
                uiContext.fillStyle = NAMETAG_PARAMS.textColor;
                const textLine1_Y = y - backgroundHeight + NAMETAG_PARAMS.padding + NAMETAG_PARAMS.fontSize;
                const textLine2_Y = textLine1_Y + NAMETAG_PARAMS.fontSize + (NAMETAG_PARAMS.padding / 2);
                uiContext.fillText(displayName, x, textLine1_Y);
                uiContext.fillText(distanceText, x, textLine2_Y);
            }
        }

        // ===================================================================
        // --- 📊 UPDATE HUD (HEAD-UP DISPLAY) ---
        // ===================================================================
        /**
         * Updates the main in-game HUD with real-time information like speed,
         * altitude, and thrust, based on the local player's state.
         */
        function updateHUD() {
            if (!hudInfoElement) return;
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            // Initialize variables.
            let totalSpeedKmh = 0.0, forwardSpeedKmh = 0.0, altitude = 0.0, thrustPercent = 0.0;
            let currentSpeedUnit = "km/h", modeString = "", brakeStatus = "", altPodString = "-- m";
            let jumpStatus = "", downForceStatus = "", flightGravityHUDString = "";

            // Gather and format data based on the current control mode.
            switch (localPlayer.state.controlMode) {
                case ControlMode.PODRACER:
                    modeString = "Podracer";
                    const vs = localPlayer.state.vehicleState;

                    if (localPlayer.vehicle.body && !localPlayer.vehicle.body.isSleeping()) {
                        const currentPosition = localPlayer.vehicle.body.translation();
                        const currentVelocity = localPlayer.vehicle.body.linvel();
                        const podracerRot = localPlayer.vehicle.body.rotation();
                        altitude = currentPosition.y;
                        
                        // Display the correct thrust value, prioritizing Race mode over Throttle mode.
                        if (vs.isRaceThrusting) {
                            thrustPercent = (vs.raceThrustDirection > 0) 
                                ? PODRACER_MAX_FORWARD_THRUST_NORMALIZED * 100.0
                                : PODRACER_MAX_REVERSE_THRUST_NORMALIZED * 100.0;
                        } else {
                            thrustPercent = vs.thrustLevel * 100.0;
                        }
                        
                        // Calculate total speed and speed along the vehicle's forward axis.
                        const worldVel = new THREE.Vector3(currentVelocity.x, currentVelocity.y, currentVelocity.z);
                        totalSpeedKmh = worldVel.length() * UNITS_PER_SECOND_TO_KM_PER_HOUR;
                        const worldQuat = new THREE.Quaternion(podracerRot.x, podracerRot.y, podracerRot.z, podracerRot.w);
                        const worldForward = FORWARD_VECTOR.clone().applyQuaternion(worldQuat);
                        const forwardSpeedMs = worldVel.dot(worldForward);
                        forwardSpeedKmh = forwardSpeedMs * UNITS_PER_SECOND_TO_KM_PER_HOUR;
                        
                        // Build status strings for various vehicle states.
                        if (vs.isInFlightMode) {
                            flightGravityHUDString = `<br>Flight Grav: <span style='color: ${vs.isFlightGravityActive ? "orange" : "cyan"};'>${vs.isFlightGravityActive ? "ON" : "OFF"}</span>`;
                        }
                        if (vs.relativeAltitude !== null) {
                            altPodString = `${vs.relativeAltitude.toFixed(1)} m`;
                        }
                        if (vs.isAeroBraking) { brakeStatus = "<br><span style='color: red;'>AERO BRAKE</span>"; }
                        if (vs.isJumping) { jumpStatus = "<br><span style='color: cyan;'>JUMP IMPULSE</span>"; }
                        if (vs.isApplyingDownForce) { downForceStatus = "<br><span style='color: magenta;'>DOWN IMPULSE</span>"; }

                    } else if (localPlayer.vehicle.body) {
                        altitude = localPlayer.vehicle.body.translation().y;
                    }
                    break;

                case ControlMode.FPS:
                default:
                    modeString = "FPS";
                    if (localPlayer.body && !localPlayer.body.isSleeping()) {
                        const currentPosition = localPlayer.body.translation();
                        const currentVelocity = localPlayer.body.linvel();
                        altitude = currentPosition.y;
                        const worldVelPlayer = new THREE.Vector3(currentVelocity.x, currentVelocity.y, currentVelocity.z);
                        totalSpeedKmh = worldVelPlayer.length() * UNITS_PER_SECOND_TO_KM_PER_HOUR;
                    } else if(localPlayer.body) {
                        altitude = localPlayer.body.translation().y;
                    }
                    break;
            }

            // Assemble the final HTML string and update the HUD element.
            hudInfoElement.innerHTML = `Speed: ${totalSpeedKmh.toFixed(1)} ${currentSpeedUnit}<br>` +
                                       `Forward Vel: ${forwardSpeedKmh.toFixed(1)} ${currentSpeedUnit}<br>` +
                                       `Altitude: ${altitude.toFixed(1)} m<br>` +
                                       (localPlayer.state.controlMode === ControlMode.PODRACER && localPlayer.state.vehicleState.relativeAltitude !== null ? `Rel. Alt: ${altPodString}<br>` : '') +
                                       (localPlayer.state.controlMode === ControlMode.PODRACER ? `Thrust: ${thrustPercent.toFixed(0)}%<br>` : '') +
                                       `Mode: ${modeString}${jumpStatus}${downForceStatus}${brakeStatus}${flightGravityHUDString}`;
        }
       
        // ===================================================================
        // --- 🏁 RACE MENU SETUP & EVENT LISTENERS ---
        // ===================================================================
        /**
         * Attaches all the necessary event listeners for the race setup UI,
         * handling navigation between the different race menu screens.
         */
        function setupRaceMenuListeners() {
            // Get references to all menu buttons.
            const createRaceBtn = document.getElementById('createRaceBtn');
            const closePlaygroundMenuBtn = document.getElementById('closePlaygroundMenuBtn');
            const soloRaceBtn = document.getElementById('soloRaceBtn');
            const backToPlaygroundMenuBtn = document.getElementById('backToPlaygroundMenuBtn');
            const lapsPrev = document.getElementById('lapsPrev');
            const lapsNext = document.getElementById('lapsNext');
            const lapsValue = document.getElementById('lapsValue');
            const positionPortalBtn = document.getElementById('positionPortalBtn');
            const backToRaceSetupMenuBtn = document.getElementById('backToRaceSetupMenuBtn');
            const cleanupPortalsBtn = document.getElementById('cleanupPortalsBtn');

            // --- Menu Navigation Logic ---
            createRaceBtn.addEventListener('click', () => {
                playgroundMenu.style.display = 'none';
                raceSetupMenu.style.display = 'flex';
            });

            closePlaygroundMenuBtn.addEventListener('click', () => {
                playgroundMenu.style.display = 'none';
                togglePause(false); // Resume the game.
            });

            soloRaceBtn.addEventListener('click', () => {
                // IMPORTANT: Before setting up a new race, clean up any previous race data or objects.
                console.log("🤖 Starting solo race setup, performing pre-cleanup...");
                cleanupRace();
                
                raceSetupMenu.style.display = 'none';
                soloRaceConfigMenu.style.display = 'flex';
                
                // Initialize the state for the new race.
                raceState.config.mode = 'solo';
                raceState.config.laps = 1;
                lapsValue.textContent = '1';
            });
            
            backToPlaygroundMenuBtn.addEventListener('click', () => {
                raceSetupMenu.style.display = 'none';
                playgroundMenu.style.display = 'flex';
            });
            
            backToRaceSetupMenuBtn.addEventListener('click', () => {
                soloRaceConfigMenu.style.display = 'none';
                raceSetupMenu.style.display = 'flex';
            });

            cleanupPortalsBtn.addEventListener('click', () => {
                console.log("🖱️ 'Clean Up Portals' button clicked. Triggering cleanup...");
                cleanupRace();
            });

            // --- Lap Counter Logic ---
            lapsPrev.addEventListener('click', () => {
                if (raceState.config.laps > 1) {
                    raceState.config.laps--;
                    lapsValue.textContent = raceState.config.laps;
                }
            });

            lapsNext.addEventListener('click', () => {
                if (raceState.config.laps < 99) {
                    raceState.config.laps++;
                    lapsValue.textContent = raceState.config.laps;
                }
            });

            // --- Initiate Portal Placement ---
            positionPortalBtn.addEventListener('click', () => {
                soloRaceConfigMenu.style.display = 'none';
                togglePause(false); // Exit menus and return to the game.
                startPortalPlacement(); // Enter portal placement mode.
            });
        }

        // ===================================================================
        // --- 📊 UPDATE ON-SCREEN INSTRUCTIONS ---
        // ===================================================================
        /**
         * Updates the on-screen text instructions based on the current control mode,
         * camera view, and selected gameplay options. Also manages its own visibility.
         */
        function updateInstructions() {
            const instructions = document.getElementById('instructions');
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            let pauseHint = " | P: Pause Menu", debugHint = " | I: Toggle Debug";
            let mouseFlightModeHint = "", mouseSoloModeHint = "", soloWSAccelModeHint = "", arrowsAccelModeHint = "";

            switch(localPlayer.state.controlMode) {
                case ControlMode.PODRACER:
                    let podracerControlsText = "";
                    arrowsAccelModeHint = ` (Arrows: ${currentPodracerArrowsAccelMode.charAt(0).toUpperCase() + currentPodracerArrowsAccelMode.slice(1).toLowerCase()})`;
                    if (localPlayer.state.vehicleState.isInFlightMode) {
                        mouseFlightModeHint = ` (Mouse Flight: ${currentPodracerMouseFlightMode.charAt(0).toUpperCase() + currentPodracerMouseFlightMode.slice(1).toLowerCase()})`;
                        if (currentPodracerMouseFlightMode === PODRACER_MOUSE_FLIGHT_MODE.STEERING) {
                            podracerControlsText += `MOUSE: Yaw/Pitch (Steering)${mouseFlightModeHint} | Q/E: Yaw | W/S: Pitch | A/D: Roll | Z/C: Strafe<br/>`;
                        } else {
                            podracerControlsText += `MOUSE: Yaw/Pitch (Rate)${mouseFlightModeHint} | Q/E: Yaw | W/S: Pitch | A/D: Roll | Z/C: Strafe<br/>`;
                        }
                        podracerControlsText += `Scroll: Thrust (0-100%) | Up/Down Arrows: Thrust${arrowsAccelModeHint} | G: Flight Grav<br/>`;
                    } else {
                        mouseSoloModeHint = ` (Mouse Ground: ${currentPodracerMouseSoloMode.charAt(0).toUpperCase() + currentPodracerMouseSoloMode.slice(1).toLowerCase()})`;
                        soloWSAccelModeHint = ` (W/S Accel: ${currentPodracerSoloWSAccelMode.charAt(0).toUpperCase() + currentPodracerSoloWSAccelMode.slice(1).toLowerCase()})`;
                        let adqeSoloHint = (currentPodracerSoloKeyControlMode === PODRACER_SOLO_KEY_CONTROL_MODE.STRAFE_AD_YAW_QE) ? "A/D: Strafe | Q/E: Yaw" : "A/D: Yaw | Q/E: Strafe";
                        let keyControlModeVisualHint = (currentPodracerSoloKeyControlMode !== PODRACER_SOLO_KEY_CONTROL_MODE.STRAFE_AD_YAW_QE) ? ` (Keys: Alt.)` : "";
                        if (currentPodracerMouseSoloMode === PODRACER_MOUSE_SOLO_MODE.STEERING) {
                            podracerControlsText += `MOUSE: Yaw (Steering)${mouseSoloModeHint} | W/S: Thrust${soloWSAccelModeHint} | ${adqeSoloHint}${keyControlModeVisualHint}<br/>`;
                        } else {
                            podracerControlsText += `MOUSE: Yaw (Rate)${mouseSoloModeHint} | W/S: Thrust${soloWSAccelModeHint} | ${adqeSoloHint}${keyControlModeVisualHint}<br/>`;
                        }
                        podracerControlsText += `Scroll: Thrust (0-100%) | Up/Down Arrows: Thrust${arrowsAccelModeHint}<br/>`;
                    }
                    podracerControlsText += `SPACE: Aero Brake | X: Jump | ALT: Down Impulse | 0: Cut Thrust<br/>1: FPV | 2: Attached | 3: Far Cam${debugHint}${pauseHint}`;
                    instructions.innerHTML = `Podracer Mode ${localPlayer.state.vehicleState.isInFlightMode ? "(FLIGHT)" : "(GROUND)"}<br/>${podracerControlsText}`;
                    break;

                case ControlMode.FPS:
                default:
                    let fpsCamModeText = "", fpsControlsLine1 = "";
                    if (localPlayer.state.isPlatformerCameraActive) {
                        fpsCamModeText = " (3D Platformer)";
                        fpsControlsLine1 = `W/S: Move | A/D: Turn | MOUSE: Orbit Camera | Scroll: Zoom`;
                    } else if (localPlayer.state.isThirdPersonActive) {
                        fpsCamModeText = " (3rd Person)";
                        fpsControlsLine1 = `WASD: Move | SPACE: Jump | SHIFT: Sprint | MOUSE: Look | Scroll: Zoom`;
                    } else {
                        fpsCamModeText = " (1st Person)";
                        fpsControlsLine1 = `WASD: Move | SPACE: Jump | SHIFT: Sprint | MOUSE: Look`;
                    }
                    instructions.innerHTML = `FPS Mode${fpsCamModeText} - Click to play<br/>` +
                                             `${fpsControlsLine1}<br/>` +
                                             `H: Enter Podracer | R: Respawn | 1: 1st-P Cam | 2: 3rd-P Cam | 3: Platformer Cam${debugHint}<br/>` +
                                             `P: Pause Menu`;
                    break;
            }

            // Manage visibility: Instructions are always shown if paused.
            // Otherwise, they are only shown if the mouse pointer is not locked.
            if (isPaused) {
                instructions.style.display = 'block';
                return;
            }
            if (localPlayer.state.controlMode === ControlMode.FPS || localPlayer.state.controlMode === ControlMode.PODRACER) {
                instructions.style.display = controls.isLocked ? 'none' : 'block';
            } else {
                instructions.style.display = 'none';
            }
        }


        // ===================================================================
        // --- 👁️ UPDATE CURSOR AND VISUAL INDICATORS ---
        // ===================================================================
        /**
         * Manages the visibility of the system cursor, the FPS crosshair, and the
         * Podracer's Yaw/Pitch "V" indicators. This function acts as a central
         * controller for on-screen aiming and feedback elements.
         */
        function updateCursorAndIndicators() {
            const fpsCrosshair = document.getElementById('crosshair');
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            // --- 1. Manage System Cursor Visibility ---
            // If the game is paused or the pointer is unlocked, show the default system cursor.
            // Otherwise, hide it for an immersive gameplay experience.
            if (isPaused || (controls && !controls.isLocked)) {
                document.body.style.cursor = 'default';
            } else {
                document.body.style.cursor = 'none';
            }

            // --- 2. Reset All Indicators to a Hidden State ---
            // This ensures a clean slate before deciding which indicators to show.
            if (fpsCrosshair) fpsCrosshair.style.display = 'none';
            if (podracerMouseYawIndicatorElement) podracerMouseYawIndicatorElement.style.display = 'none';
            if (staticLeftVElement) staticLeftVElement.style.display = 'none';
            if (staticRightVElement) staticRightVElement.style.display = 'none';
            if (leftArrowEffectContainer) leftArrowEffectContainer.style.display = 'none';
            if (rightArrowEffectContainer) rightArrowEffectContainer.style.display = 'none';
            if (podracerMousePitchIndicatorElement) podracerMousePitchIndicatorElement.style.display = 'none';
            if (staticTopVElement) staticTopVElement.style.display = 'none';
            if (staticBottomVElement) staticBottomVElement.style.display = 'none';
            if (topArrowEffectContainer) topArrowEffectContainer.style.display = 'none';
            if (bottomArrowEffectContainer) bottomArrowEffectContainer.style.display = 'none';

            // --- 3. Conditionally Show Indicators Based on Current Game State ---
            if (!isPaused) {
                switch (localPlayer.state.controlMode) {
                    
                    case ControlMode.FPS:
                        // In FPS mode, show the crosshair if the pointer is locked.
                        if (controls && controls.isLocked) {
                            if (fpsCrosshair) fpsCrosshair.style.display = 'block';
                        }
                        break;
                        
                    case ControlMode.PODRACER:
                        if (controls && controls.isLocked) {
                            // The crosshair is also used as a central aiming point in Podracer mode.
                            if (fpsCrosshair) fpsCrosshair.style.display = 'block';
                            
                            const vehicleInFlight = localPlayer.state.vehicleState.isInFlightMode;
                            
                            // Determine if the Yaw "V" indicators should be visible.
                            // This depends on being in "Steering" mode for either ground or flight.
                            let showYawVIndicators = false;
                            if (!vehicleInFlight) { // Ground mode
                                if (currentPodracerMouseSoloMode === PODRACER_MOUSE_SOLO_MODE.STEERING) {
                                    showYawVIndicators = true;
                                }
                            } else { // Flight mode
                                if (currentPodracerMouseFlightMode === PODRACER_MOUSE_FLIGHT_MODE.STEERING) {
                                    showYawVIndicators = true;
                                }
                            }
                            
                            if (showYawVIndicators) {
                                if (podracerMouseYawIndicatorElement) {
                                    podracerMouseYawIndicatorElement.style.display = 'block';
                                    if (staticLeftVElement) staticLeftVElement.style.display = 'block';
                                    if (staticRightVElement) staticRightVElement.style.display = 'block';
                                }
                            }
                            
                            // The Pitch "V" indicators are only shown during flight and in "Steering" mode.
                            if (vehicleInFlight && currentPodracerMouseFlightMode === PODRACER_MOUSE_FLIGHT_MODE.STEERING) {
                                if (podracerMousePitchIndicatorElement) {
                                    podracerMousePitchIndicatorElement.style.display = 'block';
                                    if (staticTopVElement) staticTopVElement.style.display = 'block';
                                    if (staticBottomVElement) staticBottomVElement.style.display = 'block';
                                }
                            }
                        }
                        break;
                }
            }
        }

        // ===================================================================
        // --- ↔️ STRAFE VISUALIZER (SVG) HELPER FUNCTIONS ---
        // ===================================================================
        /**
         * A utility function to create an SVG element with the correct namespace.
         * @param {string} tag - The type of SVG element to create (e.g., 'svg', 'polygon').
         * @returns {SVGElement} The newly created SVG element.
         */
        function createSVGElement_strafe(tag) { 
            return document.createElementNS(SVG_NS_STRAFE, tag); 
        }

        /**
         * Updates the vertical position of the strafe indicator container based on viewport height.
         */
        function updateVerticalPosition_strafe() {
            if (strafeVisualContainer_strafe) {
                strafeVisualContainer_strafe.style.bottom = `${params_strafe.verticalOffsetVhFromBottom}vh`;
            }
        }

        /**
         * Initializes the DOM structure and SVG elements for the strafe visualizer.
         * This should be called once when the game scene is prepared.
         */
        function initStrafeVisuals_mainGame() {
            strafeVisualContainer_strafe = document.getElementById('strafe-visual-container');
            leftArrowAnchor_strafe = document.getElementById('left-arrow-anchor-strafe');
            rightArrowAnchor_strafe = document.getElementById('right-arrow-anchor-strafe');
            
            if (!strafeVisualContainer_strafe || !leftArrowAnchor_strafe || !rightArrowAnchor_strafe) {
                console.error("❌ Error: Strafe visualizer HTML elements not found!"); 
                return;
            }

            // Create a single, hidden SVG element to store shared definitions like gradients.
            let defs = document.getElementById('svg-arrow-defs-strafe');
            if (!defs) {
                defs = createSVGElement_strafe('defs'); 
                defs.id = 'svg-arrow-defs-strafe';
                const globalSvgForDefs = createSVGElement_strafe('svg');
                globalSvgForDefs.style.cssText = 'position:absolute;width:0;height:0;overflow:hidden;';
                globalSvgForDefs.appendChild(defs); 
                document.body.appendChild(globalSvgForDefs);
            }

            // Create and append the left arrow SVG and its wrapper.
            leftGradientId_strafe = 'leftArrowGradientStrafeUnique'; 
            leftShimmerGradientId_strafe = 'leftShimmerGradientStrafeUnique';
            leftArrowWrapperEl_strafe = document.createElement('div'); 
            leftArrowWrapperEl_strafe.className = 'arrow-wrapper-strafe';
            leftStrafeArrowSVG_strafe = createSVGElement_strafe('svg'); 
            leftStrafeArrowSVG_strafe.classList.add('strafe-arrow-svg', 'left');
            leftArrowWrapperEl_strafe.appendChild(leftStrafeArrowSVG_strafe); 
            leftArrowAnchor_strafe.appendChild(leftArrowWrapperEl_strafe);

            // Create and append the right arrow SVG and its wrapper.
            rightGradientId_strafe = 'rightArrowGradientStrafeUnique'; 
            rightShimmerGradientId_strafe = 'rightShimmerGradientStrafeUnique';
            rightArrowWrapperEl_strafe = document.createElement('div'); 
            rightArrowWrapperEl_strafe.className = 'arrow-wrapper-strafe';
            rightStrafeArrowSVG_strafe = createSVGElement_strafe('svg'); 
            rightStrafeArrowSVG_strafe.classList.add('strafe-arrow-svg', 'right');
            rightArrowWrapperEl_strafe.appendChild(rightStrafeArrowSVG_strafe); 
            rightArrowAnchor_strafe.appendChild(rightArrowWrapperEl_strafe);
            
            // Initialize the arrows with zero width.
            params_strafe.currentLeftWidth = 0; 
            params_strafe.currentRightWidth = 0;
            updateArrowSVG_strafe(leftStrafeArrowSVG_strafe, leftArrowWrapperEl_strafe, leftGradientId_strafe, leftShimmerGradientId_strafe, 0, true, params_strafe.baseColor, params_strafe.leftBarTipColor, params_strafe.leftGlowColor);
            updateArrowSVG_strafe(rightStrafeArrowSVG_strafe, rightArrowWrapperEl_strafe, rightGradientId_strafe, rightShimmerGradientId_strafe, 0, false, params_strafe.baseColor, params_strafe.rightBarTipColor, params_strafe.rightGlowColor);
            
            updateVerticalPosition_strafe(); 
            console.log("✅ Strafe visualizer initialized.");
        }

        /**
         * Updates a single SVG arrow's shape, size, and style based on the target width.
         * This function is the core renderer for the strafe indicators.
         */
        function updateArrowSVG_strafe(svgElement, wrapperElement, mainGradientId, shimmerGradId, targetWidth, isLeftBar, baseColorStr, tipColorStr, specificGlowColor) {
            if (!svgElement || !wrapperElement) return;

            // Hide the SVG if the target width is negligible.
            const shouldBeHidden = targetWidth < 0.1;
            if (shouldBeHidden) {
                if (svgElement.style.display !== 'none') svgElement.style.display = 'none';
                return;
            }
            if (svgElement.style.display === 'none') svgElement.style.display = 'block';

            // Calculate geometry points for the arrow polygon.
            const { barHeight: height, arrowTipLength: tipLengthRelative, arrowStemHeightRatio: stemHeightRatio, enableGlow, glowBlur } = params_strafe;
            const paddingForGlow = enableGlow ? Math.max(glowBlur * 2.5, 10) : 2;
            const actualTipLength = Math.min(tipLengthRelative, targetWidth);
            let stemLength = Math.max(0, targetWidth - actualTipLength);
            const halfTotalHeight = height / 2;
            const halfStemHeight = (height * stemHeightRatio) / 2;
            let pointsStr = "";

            if (isLeftBar) {
                pointsStr = `${targetWidth},${halfTotalHeight - halfStemHeight} ${targetWidth},${halfTotalHeight + halfStemHeight} `;
                pointsStr += (stemLength > 0) ? `${actualTipLength},${halfTotalHeight + halfStemHeight} ${actualTipLength},${height} ` : `${targetWidth},${height} `;
                pointsStr += `0,${halfTotalHeight} `;
                pointsStr += (stemLength > 0) ? `${actualTipLength},0 ${actualTipLength},${halfTotalHeight - halfStemHeight} ` : `${targetWidth},0 `;
            } else {
                pointsStr = `0,${halfTotalHeight - halfStemHeight} 0,${halfTotalHeight + halfStemHeight} `;
                pointsStr += (stemLength > 0) ? `${stemLength},${halfTotalHeight + halfStemHeight} ${stemLength},${height} ` : `0,${height} `;
                pointsStr += `${targetWidth},${halfTotalHeight} `;
                pointsStr += (stemLength > 0) ? `${stemLength},0 ${stemLength},${halfTotalHeight - halfStemHeight} ` : `0,0 `;
            }

            // Update SVG attributes and polygon points.
            svgElement.setAttribute('width', (targetWidth + paddingForGlow).toString());
            svgElement.setAttribute('height', (height + paddingForGlow).toString());
            svgElement.setAttribute('viewBox', `${-paddingForGlow/2} ${-paddingForGlow/2} ${targetWidth + paddingForGlow} ${height + paddingForGlow}`);
            
            let mainPolygon = svgElement.querySelector('.main-arrow-polygon-strafe');
            if (!mainPolygon) { mainPolygon = createSVGElement_strafe('polygon'); mainPolygon.classList.add('main-arrow-polygon-strafe'); svgElement.appendChild(mainPolygon); }
            mainPolygon.setAttribute('points', pointsStr.trim());

            // Update the main color gradient.
            const defs = document.getElementById('svg-arrow-defs-strafe');
            let mainGradient = defs.querySelector(`#${mainGradientId}`);
            if (!mainGradient) { mainGradient = createSVGElement_strafe('linearGradient'); mainGradient.id = mainGradientId; defs.appendChild(mainGradient); }
            mainGradient.setAttribute('x1', isLeftBar ? '100%' : '0%');
            mainGradient.setAttribute('x2', isLeftBar ? '0%' : '100%');
            mainGradient.innerHTML = `<stop offset="0%" style="stop-color:${baseColorStr}; stop-opacity:0" /><stop offset="100%" style="stop-color:${tipColorStr}; stop-opacity:1" />`;
            mainPolygon.setAttribute('fill', `url(#${mainGradientId})`);

            // Manage the shimmer effect visibility.
            let shimmerPolygon = svgElement.querySelector('.shimmer-arrow-polygon-strafe');
            const isAtMaxWidth = (isLeftBar ? params_strafe.currentLeftWidth : params_strafe.currentRightWidth) >= params_strafe.maxBarWidth - 0.1;
            if (params_strafe.enableShimmer && targetWidth > 0.1 && isAtMaxWidth) {
                if (!shimmerPolygon) { shimmerPolygon = createSVGElement_strafe('polygon'); shimmerPolygon.classList.add('shimmer-arrow-polygon-strafe'); svgElement.appendChild(shimmerPolygon); }
                shimmerPolygon.setAttribute('points', pointsStr.trim()); 
                shimmerPolygon.setAttribute('fill', `url(#${shimmerGradId})`); 
                shimmerPolygon.style.display = 'block';
            } else if (shimmerPolygon) {
                shimmerPolygon.style.display = 'none';
            }
            
            // Apply final styles to the wrapper element.
            wrapperElement.style.opacity = params_strafe.globalOpacity.toString();
            wrapperElement.style.filter = enableGlow ? `drop-shadow(0px 0px ${glowBlur}px ${specificGlowColor})` : 'none';
            wrapperElement.style.transform = isLeftBar ? `translateX(-${targetWidth + paddingForGlow}px)` : `translateX(0px)`;
        }

        /**
         * Updates the SVG gradient definition for the animated shimmer effect.
         */
        function updateShimmerGradient_strafe(gradientId, isLeftBar, currentProgress) {
            const defs = document.getElementById('svg-arrow-defs-strafe');
            if (!defs) return;

            let shimmerGradient = defs.querySelector(`#${gradientId}`);
            if (!shimmerGradient) {
                shimmerGradient = createSVGElement_strafe('linearGradient'); 
                shimmerGradient.id = gradientId;
                shimmerGradient.setAttribute('x1', isLeftBar ? '100%' : '0%'); 
                shimmerGradient.setAttribute('x2', isLeftBar ? '0%' : '100%');
                defs.appendChild(shimmerGradient);
            }

            const { shimmerColor, shimmerOpacity, shimmerWidthPercent: bandWidth } = params_strafe;
            let posStart = currentProgress * (1.0 + bandWidth) - bandWidth;
            const offsets = [ Math.max(0, Math.min(1, posStart)), Math.max(0, Math.min(1, posStart + bandWidth / 2)), Math.max(0, Math.min(1, posStart + bandWidth)) ];
            
            // Define the gradient stops for the moving shimmer band.
            shimmerGradient.innerHTML = `
                <stop offset="${offsets[0]}" style="stop-color:${shimmerColor}; stop-opacity:0" />
                <stop offset="${offsets[1]}" style="stop-color:${shimmerColor}; stop-opacity:${shimmerOpacity}" />
                <stop offset="${offsets[2]}" style="stop-color:${shimmerColor}; stop-opacity:0" />`;
        }

        /**
         * Animates the width of the strafe indicators and the shimmer effect over time.
         * This function is called within the main game loop (`animate`).
         */
        function updateStrafeVisuals_mainGameLoop(deltaTime) {
            if (!leftStrafeArrowSVG_strafe || !rightStrafeArrowSVG_strafe) return;
            
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;
            const vs = localPlayer.state.vehicleState;

            // Animate the width of the left arrow.
            const widthChange = params_strafe.animationSpeed * deltaTime;
            const strafingLeftGlobally = (!vs.isInFlightMode && vs.isStrafingLeft) || (vs.isInFlightMode && vs.isStrafingLeftInFlight);
            if (strafingLeftGlobally) {
                params_strafe.currentLeftWidth = Math.min(params_strafe.maxBarWidth, params_strafe.currentLeftWidth + widthChange);
            } else {
                params_strafe.currentLeftWidth = Math.max(0, params_strafe.currentLeftWidth - widthChange);
            }

            // Animate the width of the right arrow.
            const strafingRightGlobally = (!vs.isInFlightMode && vs.isStrafingRight) || (vs.isInFlightMode && vs.isStrafingRightInFlight);
            if (strafingRightGlobally) {
                params_strafe.currentRightWidth = Math.min(params_strafe.maxBarWidth, params_strafe.currentRightWidth + widthChange);
            } else {
                params_strafe.currentRightWidth = Math.max(0, params_strafe.currentRightWidth - widthChange);
            }
            
            // Animate the shimmer effect progress.
            if (params_strafe.enableShimmer) {
                shimmerAnimationProgress_strafe = (shimmerAnimationProgress_strafe + params_strafe.shimmerSpeed * deltaTime) % 1;
            }

            // Re-render the SVGs with the new widths.
            updateArrowSVG_strafe(leftStrafeArrowSVG_strafe, leftArrowWrapperEl_strafe, leftGradientId_strafe, leftShimmerGradientId_strafe, params_strafe.currentLeftWidth, true, params_strafe.baseColor, params_strafe.leftBarTipColor, params_strafe.leftGlowColor);
            updateArrowSVG_strafe(rightStrafeArrowSVG_strafe, rightArrowWrapperEl_strafe, rightGradientId_strafe, rightShimmerGradientId_strafe, params_strafe.currentRightWidth, false, params_strafe.baseColor, params_strafe.rightBarTipColor, params_strafe.rightGlowColor);
            
            // Update shimmer gradients if the arrows are at full width.
            const leftBarAtMax = params_strafe.currentLeftWidth >= params_strafe.maxBarWidth - 0.1;
            if (params_strafe.enableShimmer && leftBarAtMax) {
                updateShimmerGradient_strafe(leftShimmerGradientId_strafe, true, shimmerAnimationProgress_strafe);
            }
            const rightBarAtMax = params_strafe.currentRightWidth >= params_strafe.maxBarWidth - 0.1;
            if (params_strafe.enableShimmer && rightBarAtMax) {
                updateShimmerGradient_strafe(rightShimmerGradientId_strafe, false, shimmerAnimationProgress_strafe);
            }
        }


        // ===================================================================
        // --- 10. UTILITY & HELPER FUNCTIONS ---
        // ===================================================================
        // This section contains various helper functions that support the main
        // game logic, including physics helpers, memory management, animation
        // control, and debugging tools.
       
        /**
         * Creates a 32-bit bitmask for Rapier's collision interaction groups.
         * This manual approach is used for compatibility.
         * The first 16 bits define which groups the object belongs to (memberships).
         * The last 16 bits define which groups the object can interact with (filter).
         * @param {number} memberships - A bitmask of groups this collider is a member of.
         * @param {number} filter - A bitmask of groups this collider will test against.
         * @returns {number} The combined 32-bit interaction group bitmask.
         */
        function createInteractionGroups(memberships, filter) {
            // Bitwise shift the filter 16 bits to the left and then use a
            // bitwise OR to combine it with the memberships.
            return (filter << 16) | memberships;
        }

        /**
         * Safely disposes of a Three.js Object3D and its children, freeing up
         * GPU memory allocated for geometries and materials. Essential for
         * preventing memory leaks when removing objects from the scene.
         * @param {THREE.Object3D} object - The object to dispose of.
         */
        function disposeObject3D(object) {
            if (!object) return;
            
            // Traverse the object's entire hierarchy.
            object.traverse(child => {
                if (child.isMesh) {
                    // Dispose of the geometry.
                    if (child.geometry) {
                        child.geometry.dispose();
                    }
                    // Dispose of the material(s).
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
            
            // Remove the object from its parent in the scene graph.
            if (object.parent) {
                object.parent.remove(object);
            }
        }

        /**
         * Completely removes a player and all their associated resources (physics bodies,
         * visual models, data) from the game. This is critical for handling disconnections
         * in multiplayer to prevent performance degradation and crashes.
         * @param {string} playerId - The ID of the player to destroy.
         */
        function destroyPlayer(playerId) {
            console.log(`💥 Destroying player and all resources: ${playerId}`);
            const player = players.get(playerId);

            if (!player) {
                console.warn(`   -> Attempted to destroy a non-existent player: ${playerId}`);
                return;
            }

            // --- 1. Physics Cleanup (Rapier) ---
            // This is the most critical step to prevent physics-related lag or crashes.
            if (player.body) {
                physicsWorld.removeRigidBody(player.body);
                console.log(`   -> Character physics body (ID: ${playerId}) removed from Rapier.`);
            }
            if (player.vehicle && player.vehicle.body) {
                physicsWorld.removeRigidBody(player.vehicle.body);
                console.log(`   -> Vehicle physics body (ID: ${playerId}) removed from Rapier.`);
            }

            // --- 2. Visuals Cleanup (Three.js) ---
            // Use our helper to ensure GPU memory is properly released.
            if (player.model) {
                disposeObject3D(player.model);
                console.log(`   -> Character visual model (ID: ${playerId}) removed and disposed.`);
            }
            if (player.vehicle && player.vehicle.mesh) {
                disposeObject3D(player.vehicle.mesh);
                console.log(`   -> Vehicle visual model (ID: ${playerId}) removed and disposed.`);
            }

            // --- 3. Data and UI Cleanup ---
            // Remove the player from the global player map.
            players.delete(playerId);

            // Remove the player from the Host's UI list, if it exists.
            const playerListItem = document.getElementById(`player-${playerId}`);
            if (playerListItem) {
                playerListItem.remove();
            }

            console.log(`✅ Player ${playerId} completely destroyed.`);
        }

        // ===================================================================
        // --- 🎭 SMOOTH ANIMATION SWITCHING ---
        // ===================================================================
        /**
         * Handles smooth transitions between character animations using cross-fading.
         * @param {string} name - The name of the animation to play (e.g., 'walk', 'jump').
         * @param {object} player - The player object whose animation needs to be updated.
         */
        function playAnimation(name, player) {
            if (!player || !player.actions) {
                console.warn(`Attempted to play animation '${name}' on an invalid player object.`);
                return;
            }

            const newAction = player.actions[name];
            const oldAction = player.currentAction;

            // Do nothing if the requested animation is already playing or doesn't exist.
            if (oldAction === newAction || !newAction) {
                return;
            }

            // Prepare the new animation action.
            newAction.reset();
            newAction.timeScale = animationSpeedFactors[name] || 1.0;
            newAction.setLoop(name === 'jump' ? THREE.LoopOnce : THREE.LoopRepeat);
            if (name === 'jump') {
                newAction.clampWhenFinished = true;
            }
            newAction.play();

            // If there was a previous animation playing, fade it out while fading the new one in.
            if (oldAction) {
                // The jump animation is an exception; it stops abruptly. The 'finished' event handles the transition to 'fall'.
                if (oldAction.getClip().name.includes("jump")) {
                    oldAction.stop();
                } else {
                    oldAction.crossFadeTo(newAction, 0.3, false);
                }
            }

            // IMPORTANT: Update the player's current action state for the next transition.
            player.currentAction = newAction;
        }

        // ===================================================================
        // --- 🎯 GET PODRACER AIM POINT ---
        // ===================================================================
        /**
         * Calculates the 3D world point where the camera's forward vector intersects
         * with the Podracer's horizontal plane. This is useful for aiming logic.
         * @param {THREE.Camera} camera - The game camera.
         * @param {RAPIER.RigidBody} podracerBody - The Podracer's physics body.
         * @returns {THREE.Vector3 | null} The intersection point in world space, or null if there is no intersection.
         */
        function getPodracerAimPoint(camera, podracerBody) {
            if (!camera || !podracerBody) return null;

            // 1. Define the Podracer's horizontal plane.
            const podracerPos = podracerBody.translation();
            const podracerRot = podracerBody.rotation();
            const podracerUp = new THREE.Vector3(0, 1, 0).applyQuaternion(new THREE.Quaternion(podracerRot.x, podracerRot.y, podracerRot.z, podracerRot.w));
            const podracerPlane = new THREE.Plane(podracerUp, -podracerUp.dot(podracerPos));

            // 2. Define the aiming ray from the camera.
            const cameraPosition = camera.position.clone();
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const aimRay = new THREE.Ray(cameraPosition, cameraDirection);

            // 3. Find the intersection.
            const intersectionPoint = new THREE.Vector3();
            const result = aimRay.intersectPlane(podracerPlane, intersectionPoint);
            
            return result ? intersectionPoint : null;
        }

        // ===================================================================
        // --- 🎨 UNIFIED OUTLINE CREATION FUNCTION ---
        // ===================================================================
        /**
         * Creates an efficient, single-pass, dual-color outline effect for a given 3D object.
         * The outline's thickness can be dynamic based on camera distance.
         * This works by creating a slightly larger, inverted-face clone of the object
         * and applying a custom shader material to it.
         * @param {THREE.Object3D} objectToOutline - The object that will receive the outline.
         * @param {object} options - Configuration options for the outline.
         * @param {Array} materialStorageArray - An array to store the created outline materials.
         * @param {Array} meshStorageArray - An array to store the created outline meshes.
         */
        function createUnifiedIlluminatedOutline(objectToOutline, options = {}, materialStorageArray = null, meshStorageArray = null) {
            if (!objectToOutline) {
                console.warn("createUnifiedIlluminatedOutline: Provided object is null.");
                return;
            }

            // Gather all meshes from the object that should be outlined.
            const meshesToProcess = [];
            objectToOutline.traverse(node => {
                if (node.isMesh && (!options.exclude || !options.exclude.includes(node.name))) {
                    meshesToProcess.push(node);
                }
            });

            meshesToProcess.forEach(originalMesh => {
                const outlineMesh = originalMesh.clone();
                outlineMesh.name = 'outline_mesh';

                const outlineMaterial = new THREE.MeshStandardMaterial({
                    side: THREE.BackSide, // Render the back faces, making the inside visible.
                    skinning: options.isSkinned || false, // Important for animated characters.
                    transparent: false,
                    opacity: 1.0,
                });

                // Custom flag to identify our outline materials later.
                outlineMaterial.isCustomOutlineMaterial = true;

                // Hijack the material's shader compilation process to inject custom GLSL code.
                outlineMaterial.onBeforeCompile = (shader) => {
                    // --- 1. Define Uniforms (JS variables passed to the shader) ---
                    shader.uniforms.uThickness = { value: options.thickness || 0.03 };
                    const initialOuterColor = OUTLINE_COLORS_MAP[currentOutlineColorName] || '#000000';
                    shader.uniforms.uOuterColor = { value: new THREE.Color(initialOuterColor) };
                    shader.uniforms.uInnerColor = { value: new THREE.Color('#000000') }; 
                    shader.uniforms.uMinThickness = { value: options.minThickness || 0.05 };
                    shader.uniforms.uMaxThickness = { value: options.maxThickness || 0.4 };
                    shader.uniforms.uMinDistance = { value: options.minDistance || 50.0 };
                    shader.uniforms.uMaxDistance = { value: options.maxDistance || 800.0 };
                    
                    outlineMaterial.uniforms = shader.uniforms; // Store a reference for easy access.
                    const isDynamic = options.minThickness !== undefined;

                    // --- 2. Inject Uniform Declarations and Varyings into GLSL ---
                    const glslDeclarations = `
                        uniform float uThickness;
                        uniform vec3 uOuterColor;
                        uniform vec3 uInnerColor;
                        uniform float uMinThickness;
                        uniform float uMaxThickness;
                        uniform float uMinDistance;
                        uniform float uMaxDistance;
                        varying float vExtrudeFactor; // Passes the Fresnel factor from vertex to fragment shader.
                    `;

                    // --- 3. Modify the Vertex Shader ---
                    // This code extrudes each vertex along its normal to create the larger outline shape.
                    const vertexHelperFunctions = `
                        float getFinalThickness() {
                            if (${isDynamic}) {
                                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                                float distanceToCamera = distance(worldPosition.xyz, cameraPosition);
                                float distanceFactor = smoothstep(uMinDistance, uMaxDistance, distanceToCamera);
                                return mix(uMinThickness, uMaxThickness, distanceFactor);
                            } else {
                                return uThickness;
                            }
                        }
                    `;
                    const vertexModifications = `
                        vec4 viewPosition = viewMatrix * modelMatrix * vec4(position, 1.0);
                        vec3 viewNormal = normalize(transpose(inverse(mat3(viewMatrix * modelMatrix))) * objectNormal);
                        vec3 viewDirection = normalize(-viewPosition.xyz);
                        vExtrudeFactor = 1.0 - abs(dot(viewNormal, viewDirection)); // Fresnel calculation.
                        float finalThickness = getFinalThickness();
                        vec3 transformed = vec3( position ) + normalize(objectNormal) * finalThickness;
                    `;
                    shader.vertexShader = glslDeclarations + "\n" + vertexHelperFunctions + shader.vertexShader;
                    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', vertexModifications);

                    // --- 4. Modify the Fragment Shader ---
                    // This code colors the outline using the calculated Fresnel factor to create a gradient.
                    const fragmentModifications = `
                        // Apply a power function to the Fresnel factor to control the gradient's sharpness.
                        float finalFresnel = pow(vExtrudeFactor, 3.0); 
                        // Mix between the inner and outer colors based on the Fresnel factor.
                        vec3 finalColor = mix(uOuterColor, uInnerColor, finalFresnel);
                        gl_FragColor = vec4(finalColor, opacity);
                    `;
                    shader.fragmentShader = shader.fragmentShader.replace('#include <common>', '#include <common>\n' + glslDeclarations);
                    shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', '#include <dithering_fragment>\n' + fragmentModifications);
                };

                outlineMesh.material = outlineMaterial;
                outlineMesh.visible = isOutlineEnabled; // Set initial visibility.
                
                // Add the outline mesh as a child of the original mesh's parent.
                if (originalMesh.parent) {
                    originalMesh.parent.add(outlineMesh);
                }

                // Store references for global control.
                if (materialStorageArray) materialStorageArray.push(outlineMaterial);
                if (meshStorageArray) meshStorageArray.push(outlineMesh);
            });
        }
        
        // ===================================================================
        // --- 🐛 DEBUGGING HELPERS ---
        // ===================================================================

        /**
         * Creates a wireframe mesh that visually represents a physics collider.
         * @param {Float32Array} vertices - The vertices of the collider.
         * @param {Uint32Array} indices - The indices of the collider.
         * @param {RAPIER.RigidBody} body - The physics body the collider is attached to.
         */
        function createPhysicsDebugMesh(vertices, indices, body) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));

            const material = new THREE.MeshBasicMaterial({
                color: DEBUG_MESH_COLOR,
                wireframe: true,
                transparent: true,
                opacity: DEBUG_MESH_OPACITY,
                depthWrite: false
            });

            const debugMesh = new THREE.Mesh(geometry, material);
            const bodyPos = body.translation();
            const bodyRot = body.rotation();
            debugMesh.position.set(bodyPos.x, bodyPos.y, bodyPos.z);
            debugMesh.quaternion.set(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
            debugMesh.visible = isDebugVisible;

            scene.add(debugMesh);
            physicsDebugMeshes.push(debugMesh); // Store reference to toggle visibility.
        }

        /**
         * Draws a single line in the scene for debugging purposes.
         */
        function drawDebugLine(startVec3, endVec3, color = 0xffffff, linewidth = 1) {
             if (!isDebugVisible) return;
             const geometry = new THREE.BufferGeometry().setFromPoints([startVec3, endVec3]);
             const material = new THREE.LineBasicMaterial({ color: color, linewidth: linewidth });
             const line = new THREE.Line(geometry, material);
             podracerDebugLines.push(line);
             scene.add(line);
        }

        /**
         * Draws a line representing a surface normal vector for debugging.
         */
        function drawDebugNormal(originVec3, normalVec3, length = 1.0, color = null) {
             if (!isDebugVisible) return;
             const endVec3 = originVec3.clone().add(normalVec3.clone().multiplyScalar(length));
             let finalColor = color !== null ? color : (normalVec3.y < PODRACER_TETO_NORMAL_THRESHOLD_Y ? DEBUG_PODRACER_NORMAL_DOWN_COLOR : DEBUG_PODRACER_NORMAL_UP_COLOR);
             drawDebugLine(originVec3, endVec3, finalColor);
        }

        /**
         * Removes all Podracer-related debug lines from the scene.
         */
        function clearPodracerDebugLines() {
            podracerDebugLines.forEach(line => {
                if (line.parent) line.parent.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            podracerDebugLines = [];
        }

        /**
         * Removes the temporary debug ray for player air-wall detection.
         */
        function clearPlayerAirWallRayHelper() {
            if (lastAirWallRayHelper) {
                scene.remove(lastAirWallRayHelper);
                lastAirWallRayHelper.geometry.dispose();
                lastAirWallRayHelper.material.dispose();
                lastAirWallRayHelper = null;
            }
        }

        /**
         * Disables a player's physics simulation by setting gravity to zero and putting the body to sleep.
         */
        function disablePlayerPhysics(player) {
            if (!player || !player.body) return;
            
            player.body.setGravityScale(0.0, true);
            player.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
            player.body.sleep();
            console.log(`   -> Player physics disabled for ${player.id}. IsSleeping=${player.body.isSleeping()}`);
        }

        /**
         * Enables a player's physics, placing them next to a vehicle upon exit.
         */
        function enablePlayerPhysicsNearPosition(player, vehicleBody, vehicleWidth, vehicleRotation) {
            console.log(`   -> Enabling player physics for ${player.id}...`);
            if (!player || !player.body) return;

            const vehiclePos = vehicleBody.translation();
            const vehicleYawOnlyQuat = new THREE.Quaternion(0, vehicleRotation.y, 0, vehicleRotation.w).normalize();
            const localExitOffset = new THREE.Vector3(vehicleWidth / 2 + PLAYER_RADIUS + PLAYER_EXIT_SIDE_OFFSET, 0, 0);
            const worldExitOffset = localExitOffset.applyQuaternion(vehicleYawOnlyQuat);
            const playerSpawnPos = {
                x: vehiclePos.x + worldExitOffset.x,
                y: vehiclePos.y + PLAYER_HEIGHT / 2 + PLAYER_EXIT_HEIGHT_OFFSET,
                z: vehiclePos.z + worldExitOffset.z
            };

            // Wake the body up and reset its state.
            player.body.wakeUp();
            player.body.setTranslation(playerSpawnPos, true);
            player.body.setRotation({ x: 0, y: 0, z: 0, w: 1 }, true);
            player.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
            player.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
            player.body.setGravityScale(1.0, true);

            // Re-orient the camera to face away from the vehicle.
            const lookDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(vehicleYawOnlyQuat);
            const cameraPos = new THREE.Vector3(playerSpawnPos.x, playerSpawnPos.y + PLAYER_EYE_HEIGHT - PLAYER_HEIGHT / 2, playerSpawnPos.z);
            const lookAtPoint = cameraPos.clone().add(lookDirection);
            camera.position.copy(cameraPos);
            camera.lookAt(lookAtPoint);
            camera.updateMatrixWorld(true);

            console.log(`   -> Player physics enabled. GravityScale=${player.body.gravityScale()}, IsSleeping=${player.body.isSleeping()}`);
        }

        /**
         * Resets all vehicle-related input states for the local player.
         * This is called when exiting the vehicle to ensure no inputs are "stuck" on.
         */
        function resetVehicleInputs() {
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            // Reset generic movement intentions.
            localPlayer.state.moveForward = false;
            localPlayer.state.moveBackward = false;
            localPlayer.state.moveLeft = false;
            localPlayer.state.moveRight = false;

            // Reset all specific vehicle states within the player's state object.
            const vs = localPlayer.state.vehicleState;
            Object.assign(vs, {
                isStrafingLeft: false,
                isStrafingRight: false,
                isStrafingLeftInFlight: false,
                isStrafingRightInFlight: false,
                keyYawRate: 0.0,
                keyPitchRate: 0.0,
                rollVelocity: 0.0,
                yawVelocity: 0.0,
                pitchVelocity: 0.0,
                thrustLevel: 0.0,
                isRaceThrusting: false,
                currentVisualRoll: 0.0,
                isVelocityRayFrozen: false,
                isFlightGravityActive: false,
                relativeAltitude: null
            });

            console.log("🔄 Vehicle inputs and state reset.");
        }

        
        // ===================================================================
        // --- 🔄 CONTROL MODE SWITCHING LOGIC ---
        // ===================================================================

        /**
         * Manages the transition between different player control modes (e.g., FPS to Podracer).
         * This function orchestrates the cleanup of the previous mode and the setup of the new one.
         * @param {string} targetMode - The control mode to switch to (e.g., ControlMode.PODRACER).
         */
        function switchControlMode(targetMode) {
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer || !localPlayer.body || !localPlayer.vehicle || !localPlayer.vehicle.body) {
                console.warn("⚠️ Attempted to switch control mode before player and vehicle were fully initialized.");
                return;
            }

            const previousMode = localPlayer.state.controlMode;
            console.log(`🔄 Attempting to switch from ${previousMode} to ${targetMode}...`);

            if (targetMode === previousMode) {
                console.log(`   -> Already in ${targetMode}. No change needed.`);
                return;
            }

            // --- 1. Exit the Current Mode ---
            // Perform cleanup actions specific to the mode we are leaving.
            switch (previousMode) {
                case ControlMode.FPS:
                    if (controls.isLocked) controls.unlock();
                    if (localPlayer.model) localPlayer.model.visible = false; 
                    
                    // Reset camera state within the player object.
                    localPlayer.state.isThirdPersonActive = false;
                    localPlayer.state.isPlatformerCameraActive = false;
                    localPlayer.state.thirdPersonZoomDistance = FPS_THIRD_PERSON_OFFSET.z;

                    // Hide FPS-specific debug visuals.
                    if (playerCapsuleHelper) playerCapsuleHelper.visible = false;
                    playerGroundRayHelpers.forEach(ray => ray.visible = false);
                    clearPlayerAirWallRayHelper(); 
                    console.log("🐛 Player debug visuals cleaned up on exiting FPS mode.");
                    break;
                case ControlMode.PODRACER:
                    exitPodracer();
                    break;
            }

            // --- 2. Enter the New Mode ---
            // Perform setup actions for the new mode.
            switch (targetMode) {
                case ControlMode.FPS:
                    enterFPS(); 
                    break;
                case ControlMode.PODRACER:
                    enterPodracer();
                    break;
            }

            // --- 3. Finalize State and Update UI ---
            // CRITICAL: Update the authoritative state within the player object.
            localPlayer.state.controlMode = targetMode;
            localPlayer.state.isInVehicle = (targetMode === ControlMode.PODRACER);

            updateInstructions();
            console.log(`✅ Player '${localPlayer.id}' control mode switched to: ${localPlayer.state.controlMode}`);

            // If the game is paused, update the pause menu to show/hide relevant options.
            if (isPaused) {
                updatePauseMenuOptionsVisibility();
            }
        }

        /**
         * Sets up the game state for FPS (on-foot) control.
         * This is called when exiting a vehicle.
         */
        function enterFPS() {
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;
            
            console.log("🔄 Entering FPS mode...");
            if (controls) {
                controls.enablePitchControl = true;
                controls.enableYawControl = true;
                console.log("   -> PointerLockControls: Pitch and Yaw re-enabled for FPS mode.");
            }
            
            // Hide vehicle-specific indicators and restore default cursor behavior.
            document.body.style.cursor = 'none';
            if (podracerMouseIndicatorElementGlobalRef) podracerMouseIndicatorElementGlobalRef.style.display = 'none';
            
            // Wake up the player's physics body if it was sleeping.
            if (localPlayer.body && localPlayer.body.isSleeping()) {
                localPlayer.body.wakeUp();
                localPlayer.body.setGravityScale(1.0, true);
                console.log(`   -> Player physics body awakened. GravityScale=${localPlayer.body.gravityScale()}`);
            }

            // Reset camera FOV and make the player model visible.
            if (camera.fov !== CAMERA_BASE_FOV) {
                camera.fov = CAMERA_BASE_FOV;
                camera.updateProjectionMatrix();
            }
            if (localPlayer.model) localPlayer.model.visible = true;
            
            // Reset the camera state to default third-person view.
            localPlayer.state.isThirdPersonActive = true;
            localPlayer.state.isPlatformerCameraActive = false;
            localPlayer.state.thirdPersonZoomDistance = FPS_THIRD_PERSON_OFFSET.z;
            
            // Update camera position and UI elements.
            updatePlayerFPSCamera(localPlayer.body);
            updateCursorAndIndicators();
            
            // Attempt to re-lock the mouse pointer.
            if (controls && !isPaused) {
                if (controls.isLocked) controls.unlock();
                setTimeout(() => {
                    const currentLocalPlayer = players.get(localPlayerId);
                    if (currentLocalPlayer && currentLocalPlayer.state.controlMode === ControlMode.FPS && !isPaused && controls && !controls.isLocked) {
                        controls.lock();
                    }
                }, 75); 
            }
        }

        /**
         * Sets up the game state for Podracer control.
         * This involves spawning the vehicle, disabling player physics, and changing controls.
         */
        function enterPodracer() {
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer || !localPlayer.body || !localPlayer.vehicle) return;

            console.log("🚀 Entering Podracer mode...");

            // Reset mouse and UI variables.
            mouseScreenOffsetX = 0.0;
            virtualSteeringWheelPosition = 0.0;
            virtualJoystickPitchPosition = 0.0;
            
            // Disable FPS camera controls, as the mouse now directly steers the vehicle.
            if (controls) {
                controls.enablePitchControl = false; 
                controls.enableYawControl = false;   
                console.log("   -> PointerLockControls: Pitch and Yaw disabled for Podracer mode.");
                if (controls.isLocked) controls.unlock();
            }

            // Attempt to lock the mouse pointer for vehicle control.
            if (!isPaused && controls) {
                setTimeout(() => {
                    const currentLocalPlayer = players.get(localPlayerId);
                    if (!isPaused && currentLocalPlayer && currentLocalPlayer.state.controlMode === ControlMode.PODRACER && controls && !controls.isLocked) {
                        controls.lock();
                    }
                }, 100);
            }
            
            // --- Spawn the Podracer in front of the player ---
            const playerPos = localPlayer.body.translation();
            const cameraWorldDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraWorldDirection);
            const playerForwardXZ = cameraWorldDirection.clone();
            playerForwardXZ.y = 0; // Flatten the direction to the horizontal plane.
            if (playerForwardXZ.lengthSq() < 0.0001) playerForwardXZ.set(0, 0, -1);
            playerForwardXZ.normalize();
            
            // Align the Podracer to face the same direction as the player.
            const podracerTargetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), playerForwardXZ);
            
            // Raycast downwards to find the ground and spawn the Podracer safely above it.
            const testSpawnOrigin = { x: playerPos.x, y: playerPos.y + 10, z: playerPos.z };
            const ray = new RAPIER.Ray(testSpawnOrigin, { x: 0, y: -1, z: 0 });
            const hit = physicsWorld.castRay(ray, 20.0, true, RAPIER.QueryFilterFlags.EXCLUDE_DYNAMIC, undefined, localPlayer.body.collider(0));
            let spawnY = playerPos.y + PODRACER_MIN_DYNAMIC_HOVER_HEIGHT + PODRACER_INITIAL_SPAWN_HOVER_OFFSET;
            if (hit) {
                const groundY = testSpawnOrigin.y - hit.timeOfImpact;
                spawnY = groundY + PODRACER_MIN_DYNAMIC_HOVER_HEIGHT + PODRACER_INITIAL_SPAWN_HOVER_OFFSET;
            }
            const podracerSpawnPos = { x: testSpawnOrigin.x, y: spawnY, z: testSpawnOrigin.z };
            
            // --- Swap Physics Bodies ---
            disablePlayerPhysics(localPlayer);
            localPlayer.vehicle.body.wakeUp();
            localPlayer.vehicle.body.setTranslation(podracerSpawnPos, true);
            localPlayer.vehicle.body.setRotation(podracerTargetQuaternion, true);
            localPlayer.vehicle.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
            localPlayer.vehicle.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
            localPlayer.vehicle.body.setGravityScale(0.0, true);
            localPlayer.vehicle.body.setLinearDamping(PODRACER_LINEAR_DAMPING);
            localPlayer.vehicle.body.setAngularDamping(PODRACER_ANGULAR_DAMPING);
            currentDynamicTargetHoverHeight = PODRACER_MIN_DYNAMIC_HOVER_HEIGHT;
            localPlayer.vehicle.mesh.visible = true;
            if (localPlayer.vehicle.colliderMeshHelper) localPlayer.vehicle.colliderMeshHelper.visible = isDebugVisible;
            
            // Reset all vehicle inputs and visual indicators to their default state.
            resetVehicleInputs(); 
            if (strafeVisualContainer_strafe) {
                params_strafe.currentLeftWidth = 0; 
                params_strafe.currentRightWidth = 0;
                updateArrowSVG_strafe(leftStrafeArrowSVG_strafe, leftArrowWrapperEl_strafe, leftGradientId_strafe, leftShimmerGradientId_strafe, 0, true, params_strafe.baseColor, params_strafe.leftBarTipColor, params_strafe.leftGlowColor);
                updateArrowSVG_strafe(rightStrafeArrowSVG_strafe, rightArrowWrapperEl_strafe, rightGradientId_strafe, rightShimmerGradientId_strafe, 0, false, params_strafe.baseColor, params_strafe.rightBarTipColor, params_strafe.rightGlowColor);
            }
            
            updateCursorAndIndicators();
            console.log("✅ Podracer mode ACTIVATED.");

            // If a race was being prepared, entering the Podracer starts the countdown.
            if (raceState.isActive && raceState.status === 'preparing') {
                console.log("🏁 Player entered Podracer. Starting race countdown...");
                startRaceCountdown();
            }
        }

        /**
         * Cleans up the Podracer state and re-enables FPS control.
         */
        function exitPodracer() {
            console.log("🚀 Exiting Podracer mode...");
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer || !localPlayer.vehicle) return;

            // Reset UI and mouse input variables.
            virtualSteeringWheelPosition = 0.0;
            mouseScreenOffsetX = 0.0;
            virtualJoystickPitchPosition = 0.0;

            // Re-enable standard camera controls.
             if (controls) {
                controls.enablePitchControl = true;
                controls.enableYawControl = true;
                if (controls.isLocked) controls.unlock();
            }

            // Reset the vehicle's state within the player object.
            const vs = localPlayer.state.vehicleState;
            Object.assign(vs, {
                isAeroBraking: false,
                isInFlightMode: false,
                previouslyInFlightMode: false,
                isJumping: false,
                isApplyingDownForce: false,
                rollVelocity: 0.0
            });
            
            // Put the vehicle's physics body to sleep to save performance.
            localPlayer.vehicle.body.setGravityScale(0.0, true);
            localPlayer.vehicle.body.sleep();
            console.log(`   -> Podracer put to sleep. IsSleeping=${localPlayer.vehicle.body.isSleeping()}`);

            // Hide the vehicle's visual model.
            if (localPlayer.vehicle.mesh) localPlayer.vehicle.mesh.visible = false;
            if (localPlayer.vehicle.colliderMeshHelper) localPlayer.vehicle.colliderMeshHelper.visible = false;
            
            // Re-enable the player's physics body, spawning them next to the vehicle.
            enablePlayerPhysicsNearPosition(localPlayer, localPlayer.vehicle.body, PODRACER_DIMENSIONS.x, localPlayer.vehicle.body.rotation());
            
            // Reset all remaining vehicle inputs.
            resetVehicleInputs();
            console.log("✅ Podracer mode DEACTIVATED. Returning to FPS mode.");
        }

        /**
         * Respawns the player at the initial starting position in FPS mode.
         */
        function respawnPlayer() {
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer || !localPlayer.body || localPlayer.state.controlMode !== ControlMode.FPS) return;

            console.log("🔄 Respawning player...");
            
            // Reset physics state.
            localPlayer.body.setTranslation(INITIAL_PLAYER_POS, true);
            localPlayer.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
            localPlayer.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
            localPlayer.body.wakeUp();
            localPlayer.state.canJump = false;

            // Reset camera state to default third-person.
            localPlayer.state.isThirdPersonActive = true;
            localPlayer.state.isPlatformerCameraActive = false;
            localPlayer.state.platformerCameraDistance = FPS_PLATFORMER_INITIAL_DISTANCE;
            localPlayer.state.platformerCameraAzimuth = 0;
            localPlayer.state.platformerCameraElevation = FPS_PLATFORMER_INITIAL_ELEVATION;
            if (localPlayer.model) localPlayer.model.visible = true; 
            
            // Update camera and UI.
            updatePlayerFPSCamera(localPlayer.body);
            updateInstructions();
        }

        // ===================================================================
        // --- 🏁 RACE SYSTEM FUNCTIONS ---
        // ===================================================================

        /**
         * Enters portal placement mode, creating a temporary visual object for the portal.
         */
        function startPortalPlacement() {
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer || localPlayer.state.controlMode !== ControlMode.FPS) {
                console.warn("Portal can only be placed while in FPS mode.");
                return;
            }

            console.log("🏁 Entering portal placement mode.");
            isInPortalPlacementMode = true;
            portalPlacementHint.style.display = 'block';

            // Create the visual mesh for the portal.
            const portalGeometry = new THREE.CircleGeometry(50, 64);
            const portalMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00, // Yellow
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            racePortalObject = new THREE.Mesh(portalGeometry, portalMaterial);
            scene.add(racePortalObject);

            updatePortalPlacement(); 
        }

        /**
         * Updates the position of the temporary portal object to stay in front of the camera.
         */
        function updatePortalPlacement() {
            if (!isInPortalPlacementMode || !racePortalObject) return;
            
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.y = 0; // Keep the portal upright.
            cameraDirection.normalize();

            // Position the portal 50 units in front of the camera.
            const portalPosition = camera.position.clone().add(cameraDirection.multiplyScalar(50));
            racePortalObject.position.copy(portalPosition);
            racePortalObject.lookAt(camera.position); // Make it face the camera.
        }

        /**
         * Finalizes the portal's position, creates its physics sensor, and prepares the race.
         */
        function finalizePortalPlacement() {
            if (!isInPortalPlacementMode || !racePortalObject) return;
            console.log("✅ Portal placed. Creating physics sensor and preparing race...");

            isInPortalPlacementMode = false;
            portalPlacementHint.style.display = 'none';

            // 1. Store the portal's forward direction for lap detection.
            const portalForward = new THREE.Vector3();
            racePortalObject.getWorldDirection(portalForward);
            portalForward.negate(); // The direction points "out of the face" of the geometry.
            racePortalObject.userData.forward = portalForward;

            // 2. Create a static, non-colliding physics sensor for the portal.
            const portalPosition = racePortalObject.position;
            const portalQuaternion = racePortalObject.quaternion;
            const portalBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(portalPosition.x, portalPosition.y, portalPosition.z).setRotation(portalQuaternion);
            const portalBody = physicsWorld.createRigidBody(portalBodyDesc);
            
            // The collider is a thin box that detects intersections.
            const portalColliderDesc = RAPIER.ColliderDesc.cuboid(50, 50, 0.1)
                .setSensor(true) // ESSENTIAL: Detects but does not physically block objects.
                .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS)
                .setCollisionGroups(createInteractionGroups(COLLISION_GROUP_PORTAL, COLLISION_GROUP_GENERAL));
            
            const portalCollider = physicsWorld.createCollider(portalColliderDesc, portalBody);
            
            console.log(`[DEBUG PORTAL] Portal collider created. Handle: ${portalCollider.handle}, Groups: ${portalCollider.collisionGroups()}`);
            
            // Store the collider's handle for easy identification in collision events.
            racePortalObject.userData.colliderHandle = portalCollider.handle;

            // 3. Update the race state to 'preparing'.
            raceState.isActive = true;
            raceState.status = 'preparing';

            // 4. Display the "PREPARE" message to the player.
            raceStatusMessage.textContent = "PREPARE";
            raceStatusMessage.style.display = 'block';
        }

        /**
         * Cancels portal placement mode and cleans up the temporary portal object.
         */
        function cancelPortalPlacement() {
            if (!isInPortalPlacementMode) return;
            console.log("❌ Portal placement cancelled.");
            
            isInPortalPlacementMode = false;
            portalPlacementHint.style.display = 'none';

            if (racePortalObject) {
                disposeObject3D(racePortalObject);
                racePortalObject = null;
            }

            raceState.isActive = false;
        }

        /**
         * Starts the visual countdown on the screen before the race begins.
         */
        function startRaceCountdown() {
            raceState.status = 'countdown';
            raceStatusMessage.style.fontSize = "150px";

            let count = 3;
            raceStatusMessage.textContent = count;
            raceStatusMessage.style.display = 'block';

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    raceStatusMessage.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    raceStatusMessage.textContent = "GO!";
                    beginRace(); // Start the race logic.
                    
                    // Hide the "GO!" message after a short delay.
                    setTimeout(() => {
                        raceStatusMessage.style.display = 'none';
                        raceStatusMessage.style.fontSize = "80px";
                    }, 1500);
                }
            }, 1000);
        }

        /**
         * Officially begins the race after the countdown.
         */
        function beginRace() {
            console.log("🟢 Race started! Portal is now active.");
            raceState.status = 'racing';

            // Change portal color to green to indicate it's active.
            if (racePortalObject) {
                racePortalObject.material.color.set(0x00ff00);
            }

            // Initialize data for the local racer.
            raceState.racersData.clear();
            const localPlayer = players.get(localPlayerId);
            if (localPlayer) {
                raceState.racersData.set(localPlayerId, {
                    currentLap: 0,
                    lapTimes: [],
                    finished: false
                });
            }
        }

        /**
         * Handles the logic for a player crossing the start/finish line.
         * @param {string} playerId - The ID of the player who triggered the event.
         */
        function handleLapCompletion(playerId) {
            console.log(`🏆 [Lap Completion] Event triggered for player: ${playerId}`);
            const now = Date.now();
            const racerData = raceState.racersData.get(playerId);
            if (!racerData || racerData.finished) return;

            // Case 1: First crossing, starting the timer.
            if (racerData.currentLap === 0) {
                raceState.startTime = now;
                raceState.lapStartTime = now;
                racerData.currentLap = 1;
                console.log(`🏁 ${playerId} has started the race!`);

                const lapMessage = (raceState.config.laps === 1) ? "FINAL LAP" : `LAP 1 / ${raceState.config.laps}`;
                raceStatusMessage.textContent = lapMessage;

            // Case 2: Completing a subsequent lap.
            } else {
                const lapTime = (now - raceState.lapStartTime) / 1000.0;
                racerData.lapTimes.push(lapTime);
                raceState.lapStartTime = now;
                racerData.currentLap++;
                console.log(`🏁 ${playerId} completed lap ${racerData.currentLap - 1} in ${lapTime.toFixed(2)}s.`);

                // Check if the race is finished for this player.
                if (racerData.currentLap > raceState.config.laps) {
                    racerData.finished = true;
                    const totalTime = (now - raceState.startTime) / 1000.0;
                    console.log(`🏆 ${playerId} FINISHED THE RACE in ${totalTime.toFixed(2)}s!`);
                    raceStatusMessage.textContent = "FINISH!";
                    cleanupRace();
                } else {
                    const lapMessage = (racerData.currentLap === raceState.config.laps) ? "FINAL LAP" : `LAP ${racerData.currentLap} / ${raceState.config.laps}`;
                    raceStatusMessage.textContent = lapMessage;
                }
            }
            
            // Display the lap message temporarily.
            raceStatusMessage.style.display = 'block';
            setTimeout(() => { raceStatusMessage.style.display = 'none'; }, 2000);
        }

        /**
         * Updates the on-screen race timer display.
         */
        function updateRaceTimer() {
            const timerDisplay = document.getElementById('raceTimerDisplay');
            
            if (!timerDisplay || raceState.status !== 'racing' || raceState.startTime === 0) {
                if (timerDisplay && timerDisplay.style.display !== 'none') {
                    timerDisplay.style.display = 'none';
                }
                return;
            }

            if (timerDisplay.style.display === 'none') {
                timerDisplay.style.display = 'block';
            }

            // Calculate and format the elapsed time.
            const elapsedTimeMs = Date.now() - raceState.startTime;
            const totalSeconds = Math.floor(elapsedTimeMs / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = elapsedTimeMs % 1000;
            const formattedTime = String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0') + '.' + String(milliseconds).padStart(3, '0');

            timerDisplay.textContent = formattedTime;
        }

        /**
         * Cleans up all race-related objects and resets the race state.
         */
        function cleanupRace() {
            console.log("🧹 Cleaning up race resources...");
            
            const timerDisplay = document.getElementById('raceTimerDisplay');
            if (timerDisplay) timerDisplay.style.display = 'none';
            
            if (racePortalObject) {
                // Remove the portal's physics body from the world.
                if (racePortalObject.userData.colliderHandle !== undefined) {
                    const collider = physicsWorld.getCollider(racePortalObject.userData.colliderHandle);
                    if (collider) {
                        const body = collider.parent();
                        if (body) physicsWorld.removeRigidBody(body);
                    }
                }
                // Remove the visual object from the scene and dispose of it.
                disposeObject3D(racePortalObject);
                racePortalObject = null;
            }

            // Reset the race state to its default values.
            raceState = {
                isActive: false, 
                status: 'idle',
                config: { laps: 1, mode: 'none' },
                startTime: 0, 
                lapStartTime: 0,
                racersData: new Map()
            };
        }

        // ===================================================================
        // --- 🖥️ WINDOW & DEBUGGING ---
        // ===================================================================

        /**
         * Handles the browser window resize event.
         * It updates the camera, renderer, UI canvas, and post-processing passes
         * to match the new dimensions, ensuring the scene doesn't get distorted.
         */
        function onWindowResize() {
            if (!camera || !renderer) return;

            const width = window.innerWidth;
            const height = window.innerHeight;

            // Update the 2D UI canvas (for nametags) to match the new window size.
            if(uiCanvas) {
                uiCanvas.width = width;
                uiCanvas.height = height;
            }

            // Update the 3D camera's aspect ratio.
            camera.aspect = width / height;
            camera.updateProjectionMatrix(); 
            
            // Update the renderer and post-processing composer size.
            renderer.setSize(width, height);
            if (composer) composer.setSize(width, height);
            
            // --- Resize God Rays Render Targets ---
            // The off-screen buffers for the god rays effect must also be resized.
            if (occlusionRenderTarget) {
                occlusionRenderTarget.setSize(width, height);
            }
            if (godraysRenderTarget) {
                godraysRenderTarget.setSize(width, height);
            }
            
            // Update resolution-dependent uniforms for antialiasing passes.
            const pixelRatio = renderer.getPixelRatio();
            if (fxaaPass) {
                fxaaPass.material.uniforms['resolution'].value.x = 1 / (width * pixelRatio);
                fxaaPass.material.uniforms['resolution'].value.y = 1 / (height * pixelRatio);
            }
            if (smaaPass) {
                smaaPass.setSize(width * pixelRatio, height * pixelRatio);
            }
        }

        /**
         * Toggles the visibility of all debugging visuals in the scene, such as
         * physics colliders and raycast helpers.
         */
        function toggleDebugVisuals() {
            isDebugVisible = !isDebugVisible;
            console.log(`🐛 Debug visuals ${isDebugVisible ? 'ENABLED' : 'DISABLED'}`);
            
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer) return;

            // Toggle visibility of all static physics debug meshes (e.g., terrain).
            physicsDebugMeshes.forEach(mesh => { 
                mesh.visible = isDebugVisible; 
            });

            // Contextually show/hide player-specific debug helpers based on control mode.
            const isPlayerDebugVisible = isDebugVisible && localPlayer.state.controlMode === ControlMode.FPS;
            if (playerCapsuleHelper) {
                playerCapsuleHelper.visible = isPlayerDebugVisible;
            }
            playerGroundRayHelpers.forEach(ray => {
                ray.visible = isPlayerDebugVisible;
            });
            
            const isPodracerDebugVisible = isDebugVisible && localPlayer.state.controlMode === ControlMode.PODRACER;
            if (localPlayer.vehicle && localPlayer.vehicle.colliderMeshHelper) {
                localPlayer.vehicle.colliderMeshHelper.visible = isPodracerDebugVisible;
            }

            // If debugging is turned off, immediately clear any temporary debug lines.
            if (!isDebugVisible) {
                clearPlayerAirWallRayHelper();
                clearPodracerDebugLines();
            }
        }

        /**
         * Calculates a non-linear, dynamic length for a raycast based on speed.
         * The length increases more rapidly at higher speeds, controlled by an exponent.
         * @param {number} currentSpeedMs - The current speed in meters per second.
         * @param {number} targetMaxSpeedKmh - The speed (in km/h) at which the ray should reach its maximum length.
         * @param {number} minLength - The ray's length at zero speed.
         * @param {number} maxLength - The ray's maximum possible length.
         * @param {number} exponent - The exponent for the non-linear curve (e.g., 2 for quadratic).
         * @returns {number} The calculated dynamic ray length.
         */
        function calculateDynamicRayLength(currentSpeedMs, targetMaxSpeedKmh, minLength, maxLength, exponent) {
            const targetMaxSpeedMs = targetMaxSpeedKmh / UNITS_PER_SECOND_TO_KM_PER_HOUR;
            if (targetMaxSpeedMs <= 0) return minLength;

            // Calculate a 0-1 ratio of current speed to target speed.
            const linearRatio = currentSpeedMs / targetMaxSpeedMs;
            const clampedRatio = Math.min(1.0, Math.max(0.0, linearRatio));
            
            // Apply the exponent to create the non-linear curve.
            const t_nonLinear = Math.pow(clampedRatio, exponent);
            
            // Linearly interpolate between min and max length using the non-linear factor.
            return minLength + t_nonLinear * (maxLength - minLength);
        }


        // ===================================================================
        // --- 📦 NETWORK PACKET CREATION (CONTEXT-AWARE) ---
        // ===================================================================

        /**
         * Creates a highly optimized network packet containing the local player's state.
         * It uses delta compression (sending only what changed) and contextual optimization
         * (e.g., not sending vehicle data if the player is on foot).
         * @param {object} player - The local player object.
         * @returns {object | null} The network packet object, or null if invalid.
         */
        function createOptimizedNetworkPacket(player) {
            if (!player || !player.body) return null;

            const activeBody = player.state.isInVehicle ? player.vehicle.body : player.body;
            if (!activeBody) return null;

            const pos = activeBody.translation();
            const rot = activeBody.rotation();
            const linvel = activeBody.linvel();
            const angvel = activeBody.angvel();

            // Helper functions to round and pack vector/quaternion data.
            const roundVecToArray = (v) => [ Number(v.x.toFixed(3)), Number(v.y.toFixed(3)), Number(v.z.toFixed(3)) ];
            const roundQuatToArray = (q) => [ Number(q.x.toFixed(3)), Number(q.y.toFixed(3)), Number(q.z.toFixed(3)), Number(q.w.toFixed(3)) ];

            const currentState = player.state;
            const lastState = player.network.lastSentState;

            // --- Inner helper to create a delta-compressed state object ---
            const createOptimizedStateObject = (current, last = null) => {
                const changes = {};
                let hasChanges = false;

                // --- 1. General State Data (Control mode, animation) ---
                if (!last || current.controlMode !== last.controlMode) {
                    changes.cm = CONTROL_MODE_MAP[current.controlMode];
                    hasChanges = true;
                }
                if (!last || current.animationState !== last.animationState) {
                    changes.as = ANIMATION_STATE_MAP[current.animationState];
                    hasChanges = true;
                }
                
                // Pack boolean flags into a single integer (bitmask).
                let currentPlayerFlags = current.isInVehicle ? PLAYER_STATE_FLAGS.IS_IN_VEHICLE : 0;
                let lastPlayerFlags = last && last.isInVehicle ? PLAYER_STATE_FLAGS.IS_IN_VEHICLE : 0;
                if (!last || currentPlayerFlags !== lastPlayerFlags) {
                    changes.pf = currentPlayerFlags;
                    hasChanges = true;
                }

                // --- 2. Contextual Vehicle Data Optimization ---
                // ONLY process and send vehicle data if the player is actually in the vehicle.
                if (current.controlMode === 'PODRACER') {
                    const currentVehicleState = current.vehicleState;
                    const lastVehicleState = last ? last.vehicleState : null;
                    
                    // --- Pack all vehicle booleans into a single bitmask ---
                    let currentVehicleFlags = 0;
                    if (currentVehicleState.isInFlightMode) { currentVehicleFlags |= VEHICLE_STATE_FLAGS.IS_IN_FLIGHT_MODE; }
                    if (currentVehicleState.isJumping) { currentVehicleFlags |= VEHICLE_STATE_FLAGS.IS_JUMPING; }
                    // ... (and so on for all boolean flags)
                    if (currentVehicleState.isFlightGravityActive) { currentVehicleFlags |= VEHICLE_STATE_FLAGS.IS_FLIGHT_GRAVITY_ACTIVE; }

                    let lastVehicleFlags = 0;
                    if (lastVehicleState) {
                        if (lastVehicleState.isInFlightMode) { lastVehicleFlags |= VEHICLE_STATE_FLAGS.IS_IN_FLIGHT_MODE; }
                        // ... (and so on for all boolean flags)
                        if (lastVehicleState.isFlightGravityActive) { lastVehicleFlags |= VEHICLE_STATE_FLAGS.IS_FLIGHT_GRAVITY_ACTIVE; }
                    }

                    // Only send the bitmask if it has changed.
                    if (!last || currentVehicleFlags !== lastVehicleFlags) {
                        changes.vf = currentVehicleFlags;
                        hasChanges = true;
                    }

                    // --- Pack numeric vehicle data separately ---
                    const vehicleStateChanges = {};
                    let hasNumericVehicleChanges = false;
                    if (!lastVehicleState || Math.abs(currentVehicleState.thrustLevel - lastVehicleState.thrustLevel) > 0.01) {
                        vehicleStateChanges.tl = parseFloat(currentVehicleState.thrustLevel.toFixed(2));
                        hasNumericVehicleChanges = true;
                    }
                    if (!lastVehicleState || currentVehicleState.raceThrustDirection !== lastVehicleState.raceThrustDirection) {
                        vehicleStateChanges.rtd = currentVehicleState.raceThrustDirection;
                        hasNumericVehicleChanges = true;
                    }
                    if (!lastVehicleState || Math.abs(currentVehicleState.currentVisualRoll - lastVehicleState.currentVisualRoll) > 0.01) {
                        vehicleStateChanges.cvr = parseFloat(currentVehicleState.currentVisualRoll.toFixed(3));
                        hasNumericVehicleChanges = true;
                    }

                    if (hasNumericVehicleChanges) {
                        changes.vs_num = vehicleStateChanges;
                        hasChanges = true;
                    }
                }
                
                return hasChanges ? changes : null;
            };
            
            // --- Assemble the final packet ---
            // Physics data is always included as it changes constantly.
            const networkPacket = {
                id: player.id,
                t: performance.now(), // Timestamp
                p: roundVecToArray(pos),
                r: roundQuatToArray(rot),
                lv: roundVecToArray(linvel),
                av: roundVecToArray(angvel)
            };
            
            // Periodically send a full state update to prevent desync, otherwise send deltas.
            const UPDATES_PER_FULL_STATE = 120;
            player.network.updatesSinceLastFullState++;
            if (!lastState || player.network.updatesSinceLastFullState >= UPDATES_PER_FULL_STATE) {
                networkPacket.full_state = createOptimizedStateObject(currentState);
                player.network.updatesSinceLastFullState = 0;
            } else {
                const stateDelta = createOptimizedStateObject(currentState, lastState);
                if (stateDelta) {
                    networkPacket.sc = stateDelta; // 'sc' for state changes
                }
            }
            
            // Store a copy of the current state for the next delta comparison.
            player.network.lastSentState = JSON.parse(JSON.stringify(currentState));
            return networkPacket;
        }

        // ===================================================================
        // --- 📡 NETWORK PACKET PROCESSING (CONTEXT-AWARE) ---
        // ===================================================================

        /**
         * Processes an incoming network packet from a remote player.
         * It decodes the optimized data, updates the remote player's local state representation,
         * and adds the physics data to a buffer for smooth interpolation.
         * @param {object} packet - The received network packet.
         */
        function processNetworkPacket(packet) {
            if (!packet || packet.id === localPlayerId) return;

            const remotePlayer = players.get(packet.id);
            if (!remotePlayer) return;

            // Update network stats for the HUD.
            if (remotePlayer.network.stats) {
                remotePlayer.network.stats.packetsThisSecond++;
            }

            // Buffer the new physics state for temporal interpolation.
            const bufferedState = {
                timestamp: performance.now(),
                position: new THREE.Vector3(packet.p[0], packet.p[1], packet.p[2]),
                rotation: new THREE.Quaternion(packet.r[0], packet.r[1], packet.r[2], packet.r[3])
            };
            remotePlayer.network.stateBuffer.push(bufferedState);
            remotePlayer.network.stateBuffer.sort((a, b) => a.timestamp - b.timestamp);

            // --- Inner helper to apply decoded state changes ---
            const applyStateChanges = (changes, playerState) => {
                if (!changes || !playerState) return;

                const oldAnimationState = playerState.animationState;

                // --- 1. Apply General State Data ---
                if (changes.cm !== undefined) playerState.controlMode = REVERSE_CONTROL_MODE_MAP[changes.cm];
                if (changes.as !== undefined) playerState.animationState = REVERSE_ANIMATION_STATE_MAP[changes.as];
                if (changes.pf !== undefined) {
                    playerState.isInVehicle = (changes.pf & PLAYER_STATE_FLAGS.IS_IN_VEHICLE) !== 0;
                }

                // --- 2. Apply Contextual Vehicle Data ---
                // If vehicle flags are present, decode them.
                if (changes.vf !== undefined) {
                    const flags = changes.vf;
                    const vs = playerState.vehicleState;
                    vs.isInFlightMode = (flags & VEHICLE_STATE_FLAGS.IS_IN_FLIGHT_MODE) !== 0;
                    // ... (and so on for all boolean flags)
                    vs.isFlightGravityActive = (flags & VEHICLE_STATE_FLAGS.IS_FLIGHT_GRAVITY_ACTIVE) !== 0;
                } 
                // CRITICAL: If this is a full state update and vehicle flags are ABSENT,
                // it means the remote player is on foot. We must reset our local representation
                // of their vehicle state to ensure consistency.
                else if (packet.full_state) {
                    const vs = playerState.vehicleState;
                    Object.assign(vs, {
                        isInFlightMode: false, isJumping: false, isAeroBraking: false,
                        // ... (and so on for all vehicle state properties)
                        isFlightGravityActive: false
                    });
                }

                // Apply numeric vehicle data if present.
                if (changes.vs_num) {
                    const vs_num = changes.vs_num;
                    const vs = playerState.vehicleState;
                    if (vs_num.tl !== undefined) vs.thrustLevel = vs_num.tl;
                    if (vs_num.rtd !== undefined) vs.raceThrustDirection = vs_num.rtd;
                    if (vs_num.cvr !== undefined) vs.currentVisualRoll = vs_num.cvr;
                }
                
                // If the animation state changed, trigger the visual update.
                if (playerState.animationState !== oldAnimationState) {
                    playAnimation(playerState.animationState, remotePlayer);
                }
            };

            // Apply either the full state or the delta changes.
            if (packet.full_state) {
                applyStateChanges(packet.full_state, remotePlayer.state);
            } else if (packet.sc) {
                applyStateChanges(packet.sc, remotePlayer.state);
            }

            // Wake up/sleep the remote player's vehicle body based on their state.
            if (remotePlayer.vehicle && remotePlayer.vehicle.body) {
                const vehicleBody = remotePlayer.vehicle.body;
                if (remotePlayer.state.isInVehicle && vehicleBody.isSleeping()) {
                    vehicleBody.wakeUp();
                } else if (!remotePlayer.state.isInVehicle && !vehicleBody.isSleeping()) {
                    vehicleBody.sleep();
                }
            }
        }

        /**
         * Sets up an interval to display network statistics (update rate in Hz).
         */
        function setupNetworkStatsMonitor() {
            const networkStatsHud = document.getElementById('networkStatsHud');
            if (!networkStatsHud) return;

            setInterval(() => {
                if (currentGlobalMode !== GameMode.GAME_MULTIPLAYER || !isGameStarted) {
                    networkStatsHud.style.display = 'none';
                    return;
                }
                networkStatsHud.style.display = 'block';

                let hudContent = '<h3 style="margin: 0 0 5px 0; padding: 0;">Network Stats (Hz)</h3>';
                players.forEach((player) => {
                    if (player.isLocal) return; // Skip local player.
                    if (player.network.stats) {
                        const stats = player.network.stats;
                        stats.lastCalculatedHz = stats.packetsThisSecond;
                        hudContent += `<div>${player.displayName}: <strong>${stats.lastCalculatedHz} Hz</strong></div>`;
                        stats.packetsThisSecond = 0; // Reset counter for the next second.
                    }
                });
                networkStatsHud.innerHTML = hudContent;
            }, 1000);
        }

        /**
         * Sets up an interval to display the frames per second (FPS) counter.
         */
        function setupFpsMonitor() {
            const fpsCounterElement = document.getElementById('fpsCounter');
            if (!fpsCounterElement) return;

            if (isGameStarted) {
                fpsCounterElement.style.display = 'block';
            }

            setInterval(() => {
                if (isGameStarted) {
                    fpsCounterElement.textContent = `${frameCount} FPS`;
                    frameCount = 0; // Reset for the next second's count.
                    fpsCounterElement.style.display = 'block';
                } else {
                    fpsCounterElement.style.display = 'none';
                }
            }, 1000);
        }


        // ===================================================================
        // --- 11. NETWORKING LOGIC (PEERJS) ---
        // ===================================================================
        // This section handles all Peer-to-Peer (P2P) communication using the PeerJS library.
        // It manages the connection lifecycle, player registration, and message routing
        // for the multiplayer mode. The architecture uses a Host as a "matchmaker"
        // to introduce clients, who then form a full-mesh network.

        /**
         * Initializes the local client as the Host of the game session.
         * The Host is responsible for managing the player registry and introducing
         * new players to everyone else in the session.
         */
        function initializePeerAsHost() {
            console.log("Initializing as Host...");
            peer = new Peer(); 

            // Event: Fired when the connection to the PeerJS server is established.
            peer.on('open', (id) => {
                console.log('✅ Host is online. My PeerJS ID is: ' + id);
                localPlayerId = id; 
                document.getElementById('host-id-display').textContent = id;
                
                // The Host adds itself to the central player registry.
                const hostDisplayName = 'Player_1';
                playerRegistry.set(id, hostDisplayName);
                
                // Update the Host's UI to show their own name.
                document.getElementById('connected-players-list').innerHTML = `<div id="player-${id}"><strong>${hostDisplayName} (${id})</strong></div>`;
            });

            // Event: Fired when a new Guest attempts to connect to this Host.
            peer.on('connection', (conn) => {
                // If the lobby is closed (game has started), reject the new connection.
                if (!isLobbyOpen) {
                    console.log(`🚨 Host rejected connection from ${conn.peer}. Lobby is closed.`);
                    conn.on('open', () => {
                        conn.send({ type: 'lobby_closed' });
                        setTimeout(() => conn.close(), 100);
                    });
                    return;
                }
                
                console.log(`🚨 Host received a new connection from: ${conn.peer}. Setting up handlers...`);
                connections.set(conn.peer, conn);
                setupGenericConnectionHandlers(conn); // Attach event handlers to the new connection.
            });

            // Event: Fired on a network error.
            peer.on('error', (err) => {
                console.error("PeerJS Error (Host): ", err);
                document.getElementById('host-id-display').textContent = `Error: ${err.type}`;
            });
        }

        /**
         * Initializes the local client as a Guest, preparing it to join a Host's session.
         */
        function initializePeerAsGuest() {
            console.log("Initializing as Guest...");
            peer = new Peer();

            // Event: Fired when the Guest is connected to the PeerJS server and has an ID.
            peer.on('open', (id) => {
                console.log('✅ Guest is online. My PeerJS ID is: ' + id);
                localPlayerId = id;
            });
            
            // Event: Fired when another peer (introduced by the Host) connects to this Guest.
            // This is crucial for building the full-mesh network.
            peer.on('connection', (conn) => {
                console.log(`Guest: Received connection from ${conn.peer}. Accepting.`);
                connections.set(conn.peer, conn);
                setupGenericConnectionHandlers(conn);
            });

            // Event: Fired on a network error.
            peer.on('error', (err) => {
                console.error("PeerJS Error (Guest): ", err);
                document.getElementById('guest-status-message').textContent = `Error: ${err.type}`;
            });
        }

        /**
         * Initiates a connection from a Guest client to a Host client.
         * @param {string} hostId - The PeerJS ID of the Host to connect to.
         */
        function connectToHost(hostId) {
            console.log(`Guest: Attempting to connect to Host ${hostId}`);
            const connToHost = peer.connect(hostId);
            
            // Event: Fired when the connection to the Host is successfully established.
            connToHost.on('open', () => {
                console.log(`Guest: Connection to Host ${hostId} established.`);
                document.getElementById('guest-status-message').textContent = 'Connected! Sending handshake...';
                document.getElementById('guest-status-message').style.color = 'lightgreen';
                
                connections.set(hostId, connToHost);
                
                // Send an initial 'hello' message to the Host to register.
                connToHost.send({ type: 'hello', senderId: localPlayerId });

                setupGenericConnectionHandlers(connToHost);
            });
        }

        /**
         * Attaches all necessary event handlers for a given PeerJS connection.
         * This function acts as the central message router for all P2P communication.
         * @param {Peer.DataConnection} conn - The connection object.
         */
        function setupGenericConnectionHandlers(conn) {
            // Event: Fired when any data is received over this connection.
            conn.on('data', (data) => {
                switch(data.type) {
                    // --- Message: 'hello' (Guest -> Host) ---
                    // A new player announces their arrival to the Host.
                    case 'hello':
                        if (currentNetworkRole === NetworkRole.HOST) {
                            console.log(`Host: Processing 'hello' from ${conn.peer}. Assigning name...`);

                            // 1. Assign a new name and add to the central registry.
                            const newPlayerDisplayName = `Player_${playerRegistry.size + 1}`;
                            playerRegistry.set(conn.peer, newPlayerDisplayName);
                            
                            // 2. Update the Host's UI.
                            const playerList = document.getElementById('connected-players-list');
                            if (playerList) {
                                playerList.innerHTML += `<div id="player-${conn.peer}">${newPlayerDisplayName} (${conn.peer})</div>`;
                            }
                            
                            // 3. Create the remote player entity on the Host's machine.
                            if (!players.has(conn.peer)) {
                                createPlayer(conn.peer, false, INITIAL_PLAYER_POS, newPlayerDisplayName);
                            }
                            
                            // 4. Send a 'welcome' packet back to the new Guest.
                            // This packet contains the complete, authoritative list of all players.
                            conn.send({
                                type: 'welcome',
                                yourId: conn.peer,
                                playerRegistryData: Array.from(playerRegistry.entries()),
                                gameSettings: {} 
                            });
                            
                            // 5. Notify all OTHER connected players about the newcomer.
                            const notificationPacket = { 
                                type: 'new_peer_joined', 
                                peerId: conn.peer,
                                displayName: newPlayerDisplayName
                            };
                            for (const [peerId, otherConn] of connections.entries()) {
                                if (peerId !== conn.peer) {
                                    otherConn.send(notificationPacket);
                                }
                            }
                        }
                        break;
                        
                    // --- Message: 'welcome' (Host -> New Guest) ---
                    // The new Guest receives the full player list and connects to everyone.
                    case 'welcome':
                        console.log("Guest: Received 'welcome'. Processing player registry from Host...");
                        document.getElementById('guest-status-message').textContent = 'Welcome! Syncing players...';
                        
                        const allPeerIds = [];
                        // Create entities for all players in the registry.
                        for (const [peerId, displayName] of data.playerRegistryData) {
                            allPeerIds.push(peerId);
                            if (!players.has(peerId)) {
                                createPlayer(peerId, data.yourId === peerId, INITIAL_PLAYER_POS, displayName);
                            }
                        }
                        
                        // Form the full-mesh network by connecting to every other peer.
                        for (const id of allPeerIds) {
                            if (id !== localPlayerId && !connections.has(id)) {
                                console.log(`   -> Guest initiating direct connection to peer: ${id}`);
                                const newConn = peer.connect(id);
                                newConn.on('open', () => {
                                    connections.set(id, newConn);
                                    setupGenericConnectionHandlers(newConn);
                                    console.log(`   -> ✅ Guest direct connection to ${id} established.`);
                                });
                            }
                        }
                        
                        document.getElementById('guest-status-message').textContent = 'Ready! Awaiting Host to start the match.';
                        break;
                    
                    // --- Message: 'new_peer_joined' (Host -> Existing Guests) ---
                    // An existing client is notified that a new player has joined the lobby.
                    case 'new_peer_joined':
                        console.log(`Guest: Notification received - New player ${data.displayName} (${data.peerId}) has joined.`);
                        
                        // 1. Create the entity for the new player.
                        if (!players.has(data.peerId)) {
                            createPlayer(data.peerId, false, INITIAL_PLAYER_POS, data.displayName);
                        }
                        
                        // 2. Connect directly to the newcomer to complete the mesh.
                        if (data.peerId !== localPlayerId && !connections.has(data.peerId)) {
                            console.log(`   -> Guest connecting to the newcomer: ${data.peerId}`);
                            const newConn = peer.connect(data.peerId);
                            newConn.on('open', () => {
                                connections.set(data.peerId, newConn);
                                setupGenericConnectionHandlers(newConn);
                                console.log(`   -> ✅ Guest connection to newcomer ${data.peerId} established.`);
                            });
                        }
                        break;
                        
                    // --- Message: 'start_game' (Host -> All Guests) ---
                    // The Host has started the game.
                    case 'start_game':
                        console.log("SIGNAL FROM HOST: Starting the game!");
                        startMultiplayerGame();
                        break;

                    // --- Message: 'peer_disconnected' (Broadcast by Host) ---
                    // A player has disconnected from the session.
                    case 'peer_disconnected':
                        console.log(`Notification: Player ${data.peerId} disconnected.`);
                        if (connections.has(data.peerId)) {
                            connections.get(data.peerId).close();
                            connections.delete(data.peerId);
                        }                                               
                        destroyPlayer(data.peerId); // Clean up the player's resources.
                        break;

                    // --- Message: 'lobby_closed' (Host -> Late Guest) ---
                    // A Guest tried to join after the game has started.
                    case 'lobby_closed':
                        if (currentNetworkRole === NetworkRole.GUEST) {
                            const guestStatus = document.getElementById('guest-status-message');
                            if (guestStatus) {
                                guestStatus.textContent = 'Could not join: The match has already started.';
                                guestStatus.style.color = 'orange';
                            }
                        }
                        break;

                    // --- Message: 'game_update' (Peer -> Peer) ---
                    // Regular state update packet.
                    case 'game_update':
                        processNetworkPacket(data.packet);
                        break;
                }
            });

            // Event: Fired when this specific connection is closed.
            conn.on('close', () => {
                const disconnectedPeerId = conn.peer;
                console.log(`🔌 Connection with ${disconnectedPeerId} has been closed.`);
                
                connections.delete(disconnectedPeerId);
                destroyPlayer(disconnectedPeerId); // Clean up all associated resources.
                
                // If this client is the Host, it must inform all other clients
                // that this peer has left.
                if (currentNetworkRole === NetworkRole.HOST) {
                    console.log(`   -> Host broadcasting disconnection of ${disconnectedPeerId}`);
                    const notificationPacket = { type: 'peer_disconnected', peerId: disconnectedPeerId };
                    for (const [peerId, otherConn] of connections.entries()) {
                        if (peerId !== localPlayerId) { 
                            otherConn.send(notificationPacket);
                        }
                    }
                }
            });
        }

        /**
         * Transitions from the lobby into the active multiplayer game scene.
         */
        function startMultiplayerGame() {
            console.log("🏁 Starting Game (Multiplayer Mode)...");

            // Set global game state.
            isGameStarted = true;
            currentGlobalMode = GameMode.GAME_MULTIPLAYER;

            // Hide all lobby/menu screens.
            document.getElementById('splash-screen').style.display = 'none';
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('host-screen').style.display = 'none';
            document.getElementById('guest-screen').style.display = 'none';
            document.getElementById('instructions').style.display = 'block';

            // Ensure the local player's entity exists.
            if (!players.has(localPlayerId)) {
                createPlayer(localPlayerId, true, INITIAL_PLAYER_POS);
            }
            
            updateInstructions();
            updateCursorAndIndicators();
            
            // Lock the mouse pointer.
            if (controls) {
                setTimeout(() => { controls.lock(); }, 100);
            }

            // Begin sending network updates.
            startNetworkLoop(20); // 20 updates per second.
        }

        // ===================================================================
        // --- 12. APPLICATION ENTRY POINT ---
        // ===================================================================
        
        init();
        animate();

    </script>
</body>
</html>
